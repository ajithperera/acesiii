                          SIAL DIRECT_RPA_UHF  
#                         -------------------

# Template definitions of simple and block indices.
# The maximum number of roots can be modified as needed. 

      index kiter             = 1, cc_iter
      index mindex20          = 1, 20
      index nindex20          = 1, 20
      index kindex20          = 1, 20
      index MAXIMUM_SUBSP_DIM = 1, 20
      index MAX_NO_ROOTS      = 1, 10

      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      mobindex j = bbocc, ebocc
      mobindex j1= bbocc, ebocc
      mobindex j2= bbocc, ebocc
      mobindex j3= bbocc, ebocc
#
      mobindex b = bbvirt, ebvirt
      mobindex b1= bbvirt, ebvirt
      mobindex b2= bbvirt, ebvirt
      mobindex b3= bbvirt, ebvirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      mobindex q = bbocc, ebvirt
      mobindex q1= bbocc, ebvirt
      mobindex q2= bbocc, ebvirt
      mobindex q3= bbocc, ebvirt

# Destributed arrays


      DISTRIBUTED R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
      DISTRIBUTED R1A_MO_M_START_L(A,I,MAX_NO_ROOTS)
      DISTRIBUTED R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
      DISTRIBUTED R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)
      DISTRIBUTED R1A_MO_P_CURRENT_R(A,I)
      DISTRIBUTED R1A_MO_M_CURRENT_L(A,I)
      DISTRIBUTED R1B_MO_P_CURRENT_R(B,J)
      DISTRIBUTED R1B_MO_M_CURRENT_L(B,J)
      DISTRIBUTED R1A_AO_P_CURRENT_R(MU,NU)
      DISTRIBUTED R1A_AO_M_CURRENT_L(MU,NU)
      DISTRIBUTED R1B_AO_P_CURRENT_R(MU,NU)
      DISTRIBUTED R1B_AO_M_CURRENT_L(MU,NU)
      DISTRIBUTED HR1A_AO_P_CURRENT_R(MU,NU) 
      DISTRIBUTED HR1A_AO_M_CURRENT_L(MU,NU) 
      DISTRIBUTED HR1B_AO_P_CURRENT_R(MU,NU) 
      DISTRIBUTED HR1B_AO_M_CURRENT_L(MU,NU) 
      DISTRIBUTED HR1A_MO_P_CURRENT_R(A,I) 
      DISTRIBUTED HR1A_MO_M_CURRENT_L(A,I) 
      DISTRIBUTED HR1B_MO_P_CURRENT_R(B,J) 
      DISTRIBUTED HR1B_MO_M_CURRENT_L(B,J) 
      DISTRIBUTED R1A_MO_P_HIST_R(A,I,MINDEX20)
      DISTRIBUTED R1A_MO_M_HIST_L(A,I,MINDEX20)
      DISTRIBUTED R1B_MO_P_HIST_R(B,J,MINDEX20)
      DISTRIBUTED R1B_MO_M_HIST_L(B,J,MINDEX20)
      DISTRIBUTED HR1A_MO_P_HIST_R(A,I,MINDEX20)
      DISTRIBUTED HR1A_MO_M_HIST_L(A,I,MINDEX20)
      DISTRIBUTED HR1B_MO_P_HIST_R(B,J,MINDEX20)
      DISTRIBUTED HR1B_MO_M_HIST_L(B,J,MINDEX20)
      DISTRIBUTED R1A_MO_P_NEW_R(A,I,NINDEX20)
      DISTRIBUTED R1A_MO_M_NEW_L(A,I,NINDEX20)
      DISTRIBUTED R1B_MO_P_NEW_R(B,J,NINDEX20)
      DISTRIBUTED R1B_MO_M_NEW_L(B,J,NINDEX20)
      DISTRIBUTED HR1A_MO_P_NEW_R(A,I,NINDEX20)
      DISTRIBUTED HR1A_MO_M_NEW_L(A,I,NINDEX20)
      DISTRIBUTED HR1B_MO_P_NEW_R(B,J,NINDEX20)
      DISTRIBUTED HR1B_MO_M_NEW_L(B,J,NINDEX20)
      DISTRIBUTED R1A_MO_P_PICKED_R(A,I)
      DISTRIBUTED R1A_MO_M_PICKED_L(A,I)
      DISTRIBUTED R1B_MO_P_PICKED_R(B,J)
      DISTRIBUTED R1B_MO_M_PICKED_L(B,J)
      DISTRIBUTED HR1A_MO_P_PICKED_R(A,I)
      DISTRIBUTED HR1A_MO_M_PICKED_L(A,I)
      DISTRIBUTED HR1B_MO_P_PICKED_R(B,J)
      DISTRIBUTED HR1B_MO_M_PICKED_L(B,J)
      DISTRIBUTED RESIDUEA_P_VEC_R(A,I)
      DISTRIBUTED RESIDUEA_M_VEC_L(A,I)
      DISTRIBUTED RESIDUEB_P_VEC_R(B,J)
      DISTRIBUTED RESIDUEB_M_VEC_L(B,J)
      DISTRIBUTED CORR_VECA_INTMD_P_R(A,I)
      DISTRIBUTED CORR_VECA_INTMD_M_L(A,I)
      DISTRIBUTED CORR_VECB_INTMD_P_R(B,J)
      DISTRIBUTED CORR_VECB_INTMD_M_L(B,J)
      DISTRIBUTED ORTHO_COEFSA_P_RL(MINDEX20,NINDEX20)
      DISTRIBUTED ORTHO_COEFSA_M_RL(MINDEX20,NINDEX20)
      DISTRIBUTED ORTHO_COEFSB_P_RL(MINDEX20,NINDEX20)
      DISTRIBUTED ORTHO_COEFSB_M_RL(MINDEX20,NINDEX20)
      DISTRIBUTED H_A_DIAGONAL(A,I)
      DISTRIBUTED H_B_DIAGONAL(B,J)
      DISTRIBUTED FOCK_A_OO(I1,I)
      DISTRIBUTED FOCK_B_OO(J1,J)
      DISTRIBUTED FOCK_A_VV(A1,A)
      DISTRIBUTED FOCK_B_VV(B1,B)

# Local and static arrays 

      STATIC GUESS_A(A,I,MAX_NO_ROOTS)
      STATIC GUESS_B(B,J,MAX_NO_ROOTS)

      STATIC A_A_MATRIX_P(NINDEX20,MINDEX20)
      STATIC A_A_MATRIX_M(NINDEX20,MINDEX20)
      STATIC B_A_MATRIX_P(NINDEX20,MINDEX20)
      STATIC B_A_MATRIX_M(NINDEX20,MINDEX20)
      STATIC TMNP_R(NINDEX20,MINDEX20)
      STATIC TMNM_L(NINDEX20,MINDEX20)
      STATIC EIG_VECS_A_P_R(NINDEX20,MINDEX20)
      STATIC EIG_VECS_A_M_R(NINDEX20,MINDEX20)
      STATIC EIG_VECS_B_P_R(NINDEX20,MINDEX20)
      STATIC EIG_VECS_B_M_R(NINDEX20,MINDEX20)
      STATIC TNORM_P_R(NINDEX20,MINDEX20)
      STATIC TNORM_M_L(NINDEX20,MINDEX20)
      STATIC OVLPA_HISTORY_P_R(NINDEX20)
      STATIC OVLPA_HISTORY_M_L(NINDEX20)
      STATIC OVLPB_HISTORY_P_R(NINDEX20)
      STATIC OVLPB_HISTORY_M_L(NINDEX20)
     
# Served arrays

      SERVED APBXXXX(MU,NU,LAMBDA,SIGMA) 
      SERVED AMBXXXX(MU,NU,LAMBDA,SIGMA) 

# Temporaray arrays

      TEMP AOINT(MU,NU,LAMBDA,SIGMA)
      TEMP TAIP_R(A,I)
      TEMP TAIM_L(A,I)
      TEMP TBJP_R(B,J)
      TEMP TBJM_L(B,J) 
#      TEMP TXAP_T(MU,A)
#      TEMP TXAM_T(MU,A)
      TEMP TXAP(MU,A)
      TEMP TXAM(MU,A)
      
      TEMP TXXP_T(MU,NU)
      TEMP TXXM_T(MU,NU)
      TEMP TXXP(MU,NU) 
      TEMP TXXM(MU,NU) 

#      TEMP TXBP_T(MU,B)
#      TEMP TXBM_T(MU,B)
      TEMP TXBP(MU,B)
      TEMP TXBM(MU,B)

      TEMP TXXXX(MU,NU,LAMBDA,SIGMA)
      TEMP TP1XXXX(MU,NU,LAMBDA,SIGMA)
      TEMP TP2XXXX(MU,NU,LAMBDA,SIGMA)
      TEMP TPXXXX(MU,NU,LAMBDA,SIGMA)
      TEMP TMXXXX(MU,NU,LAMBDA,SIGMA)
      TEMP TAXXP(MU,NU)
      TEMP TAXXM(MU,NU)
      TEMP TBXXP(MU,NU)
      TEMP TBXXM(MU,NU)
      TEMP TAPXX_INT(LAMBDA,SIGMA)
      TEMP TBPXX_INT(LAMBDA,SIGMA)
      TEMP TAMXX_INT(LAMBDA,SIGMA)
      TEMP TBMXX_INT(LAMBDA,SIGMA)
      TEMP TAPXX(LAMBDA,SIGMA)
      TEMP TAMXX(LAMBDA,SIGMA)
      TEMP TBPXX(LAMBDA,SIGMA)
      TEMP TBMXX(LAMBDA,SIGMA)
      TEMP TXIP_T(NU,I)
      TEMP TXIM_T(NU,I)
      TEMP TXJP_T(NU,J)
      TEMP TXJM_T(NU,J)
      TEMP TXIP(NU,I)
      TEMP TXIM(NU,I)
      TEMP TXJP(NU,J)
      TEMP TXJM(NU,J)
      TEMP TAIP_T(A,I)
      TEMP TAIM_T(A,I)
      TEMP TBJP_T(B,J)
      TEMP TBJM_T(B,J)
      TEMP TAP_R_T(A,I)
      TEMP TAP_R(A,I)
      TEMP TAM_L_T(A,I)
      TEMP TAM_L(A,I)
      TEMP TBP_R_T(B,J)
      TEMP TBP_R(B,J)
      TEMP TBM_L_T(B,J)
      TEMP TBM_L(B,J)
      TEMP TAI(A,I)
      TEMP TBJ(B,J)
      TEMP T1AI(A,I)
      TEMP T1BJ(B,J)
      TEMP T1AP_R_T(A,I)
      TEMP T1AP_R(A,I)
      TEMP T1AM_L_T(A,I)
      TEMP T1AM_L(A,I)
      TEMP T1BP_R_T(B,J)
      TEMP T1BP_R(B,J)
      TEMP T1BM_L_T(B,J)
      TEMP T1BM_L(B,J)
      TEMP T1AIP_R(A,I)
      TEMP T1AIM_L(A,I)
      TEMP T1BJP_R(B,J)
      TEMP T1BJM_L(B,J)
      TEMP T2AIP_R(A,I)
      TEMP T2AIM_L(A,I)
      TEMP T2BJP_R(B,J)
      TEMP T2BJM_L(B,J)
      TEMP TII(I,I1)
      TEMP TAA(A,A1)
      TEMP TJJ(J,J1)
      TEMP TBB(B,B1)
      TEMP TXI(MU,I)
      TEMP TXA(MU,A)
      TEMP TXJ(MU,J)
      TEMP TXB(MU,B)
      TEMP TAI_P(A,I)
      TEMP TAI_M(A,I)
      TEMP TBJ_P(B,J)
      TEMP TBJ_M(B,J)
    
 
# Scalars 

      SCALAR TARGET_ROOTS
      SCALAR CONV_TOLERANCE
      SCALAR OMEGA_P
      SCALAR OMEGA_M
      SCALAR STWO
      SCALAR HALF 
      SCALAR INV_SQR_TWO
      SCALAR RCOUNT
      SCALAR MCOUNT
      SCALAR NCOUNT
      SCALAR KCOUNT
      SCALAR COUNT_NO_ROOTS
#      SCALAR MAX_NO_ROOTS 
      SCALAR ITER_COUNT
      SCALAR SUBSP_DIM
      SCALAR TMP
      SCALAR SUMP
      SCALAR SUMM
      SCALAR OVLPA_P_MAX_R
      SCALAR OVLPA_M_MAX_L
      SCALAR OVLPB_P_MAX_R
      SCALAR OVLPB_M_MAX_L
      SCALAR OVLPA_P_R_INTMD
      SCALAR OVLPA_M_L_INTMD
      SCALAR OVLPB_P_R_INTMD
      SCALAR OVLPB_M_L_INTMD
      SCALAR OVLPA_P_R
      SCALAR OVLPA_M_L
      SCALAR OVLPB_P_R
      SCALAR OVLPB_M_L
      SCALAR EVECS_A_P_R
      SCALAR EVECS_A_M_L
      SCALAR EVECS_B_P_R
      SCALAR EVECS_B_M_L

#      SCALAR OVLPA_P_MAX_R
#      SCALAR OVLPA_M_MAX_L
      SCALAR NORM_INTMD_P_R
      SCALAR NORM_INTMD_M_L  
      SCALAR NORMA_P_R
      SCALAR NORMA_M_L
      SCALAR NORMB_P_R
      SCALAR NORMB_M_L
      SCALAR NORMA_INTMD_P_R_NEW
      SCALAR NORMA_INTMD_M_L_NEW
      SCALAR NORMA_P_R_NEW
      SCALAR NORMA_M_L_NEW
      SCALAR NORMB_INTMD_P_R_NEW
      SCALAR NORMB_INTMD_M_L_NEW
      SCALAR NORMB_P_R_NEW
      SCALAR NORMB_M_L_NEW
      SCALAR RLP_NORM
      SCALAR RLM_NORM
      SCALAR RANK
      SCALAR SUMA
      SCALAR SUMB
      SCALAR SUMAP
      SCALAR SUMAM
      SCALAR SUMBP
      SCALAR SUMBM

      PROC FORM_INTIAL_GUESS
#     ----------------------

      STWO = 2.0
      HALF = 0.5

      EXECUTE SQUARE_ROOT STWO HALF
      INV_SQR_TWO = 1.0/STWO 

      RCOUNT = 0.0

      PARDO A, I
            DO MAX_NO_ROOTS
               GUESS_A(A,I,MAX_NO_ROOTS) = 0.0
            ENDDO MAX_NO_ROOTS 
      ENDPARDO A, I

      PARDO B, J
            DO MAX_NO_ROOTS
               GUESS_B(B,J,MAX_NO_ROOTS) = 1.0
            ENDDO MAX_NO_ROOTS 
      ENDPARDO B, J

      execute sip_barrier 

      PARDO A, I 


            DO MAX_NO_ROOTS
               RCOUNT += 1.0

               IF RCOUNT == COUNT_NO_ROOTS

                  EXECUTE PLACE_CONSTANTA GUESS_A INV_SQR_TWO

                  TAIP_R(A,I) = GUESS_A(A,I,MAX_NO_ROOTS)
                  TAIM_L(A,I) = GUESS_A(A,I,MAX_NO_ROOTS)
                  
                  PUT R1A_MO_P_START_R(A,I,MAX_NO_ROOTS) = TAIP_R(A,I)
                  PUT R1A_MO_M_START_L(A,I,MAX_NO_ROOTS) = TAIM_L(A,I)

               ENDIF 
           
            ENDDO MAX_NO_ROOTS

      ENDPARDO A, I 

      RCOUNT = 0.0

      PARDO B, J


            DO MAX_NO_ROOTS
               RCOUNT += 1.0

               IF RCOUNT == COUNT_NO_ROOTS

                  EXECUTE PLACE_CONSTANTB GUESS_B INV_SQR_TWO

                  TBJP_R(B,J) = GUESS_B(B,J,MAX_NO_ROOTS)
                  TBJM_L(B,J) = GUESS_B(B,J,MAX_NO_ROOTS)
              
                  PUT R1B_MO_P_START_R(B,J,MAX_NO_ROOTS) = TBJP_R(B,J)
                  PUT R1B_MO_M_START_L(B,J,MAX_NO_ROOTS) = TBJM_L(B,J) 

                ENDIF 

            ENDDO MAX_NO_ROOTS

      ENDPARDO B, J

      execute sip_barrier 
#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     suma = 0.0
     sumb = 0.0
     do a 
     do i 
     do MAX_NO_ROOTS
        get R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
        tmp = R1A_MO_P_START_R(A,I,MAX_NO_ROOTS) * R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
        suma += tmp
     enddo MAX_NO_ROOTS
     enddo i 
     enddo a 
     do b
     do j
     do MAX_NO_ROOTS
        get R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
        tmp = R1B_MO_P_START_R(B,J,MAX_NO_ROOTS) * R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)   
        sumb += tmp
     enddo MAX_NO_ROOTS
     enddo j 
     enddo b 
     execute print_scalar  suma 
     execute print_scalar  sumb
     endif 
#end_debug

      ENDPROC FORM_INTIAL_GUESS
#     -------------------------

     PROC MOVE_GUESS_2CURRENT
#    -------------------------

     RCOUNT = 0.0

     PARDO A, I

           DO MAX_NO_ROOTS
              RCOUNT += 1.0

              IF RCOUNT == COUNT_NO_ROOTS

                 GET R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
                 GET R1A_MO_M_START_L(A,I,MAX_NO_ROOTS)

                 TAIP_R(A,I) =  R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
                 TAIM_L(A,I) =  R1A_MO_M_START_L(A,I,MAX_NO_ROOTS)
  
                 PUT R1A_MO_P_CURRENT_R(A,I) = TAIP_R(A,I)
                 PUT R1A_MO_M_CURRENT_L(A,I) = TAIM_L(A,I)

              ENDIF

           ENDDO MAX_NO_ROOTS

     ENDPARDO A, I

     RCOUNT = 0.0

     PARDO B, J

           DO MAX_NO_ROOTS
              RCOUNT += 1.0

              IF RCOUNT == COUNT_NO_ROOTS

                 GET R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
                 GET R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)

                 TBJP_R(B,J) =  R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
                 TBJM_L(B,J) =  R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)

                 PUT R1B_MO_P_CURRENT_R(B,J) = TBJP_R(B,J)
                 PUT R1B_MO_M_CURRENT_L(B,J) = TBJM_L(B,J)

              ENDIF

           ENDDO MAX_NO_ROOTS
 
     ENDPARDO B, J

     execute sip_barrier

     ENDPROC MOVE_GUESS_2CURRENT
#    ---------------------------

     PROC MOVE_HISTORY_2CURRENT
#    -------------------------

     MCOUNT = 0.0
     PARDO A, I
           DO MINDEX20
              MCOUNT += 1.0

              IF MCOUNT == ITER_COUNT

                 GET R1A_MO_P_HIST_R(A,I,MINDEX20)
                 GET R1A_MO_M_HIST_L(A,I,MINDEX20)

                 TAIP_R(A,I) =  R1A_MO_P_HIST_R(A,I,MINDEX20)
                 TAIM_L(A,I) =  R1A_MO_M_HIST_L(A,I,MINDEX20)
  
                 PUT R1A_MO_P_CURRENT_R(A,I) = TAIP_R(A,I)
                 PUT R1A_MO_M_CURRENT_L(A,I) = TAIM_L(A,I)

              ENDIF

           ENDDO MINDEX20

     ENDPARDO A, I

     MCOUNT = 0.0
     PARDO B, J
           DO MINDEX20
              MCOUNT += 1.0

              IF MCOUNT == ITER_COUNT

                 GET R1B_MO_P_HIST_R(B,J,MINDEX20)
                 GET R1B_MO_M_HIST_L(B,J,MINDEX20)

                 TBJP_R(B,J) =  R1B_MO_P_HIST_R(B,J,MINDEX20)
                 TBJM_L(B,J) =  R1B_MO_M_HIST_L(B,J,MINDEX20)

                 PUT R1B_MO_P_CURRENT_R(B,J) = TBJP_R(B,J)
                 PUT R1B_MO_M_CURRENT_L(B,J) = TBJM_L(B,J)

              ENDIF

           ENDDO MINDEX20
 
     ENDPARDO B, J

     execute sip_barrier

     ENDPROC MOVE_HISTORY_2CURRENT
#    -----------------------------

     PROC SAVE_C_VECTORS
#    --------------------

     MCOUNT = 0.0
     PARDO A, I

           GET R1A_MO_P_CURRENT_R(A,I)
           GET R1A_MO_M_CURRENT_L(A,I)

           TAIP_R(A,I) = R1A_MO_P_CURRENT_R(A,I)
           TAIM_L(A,I) = R1A_MO_M_CURRENT_L(A,I)

           DO MINDEX20
              MCOUNT  += 1.0

              IF MCOUNT == ITER_COUNT

                 PUT R1A_MO_P_HIST_R(A,I,MINDEX20) = TAIP_R(A,I)
                 PUT R1A_MO_M_HIST_L(A,I,MINDEX20) = TAIM_L(A,I)

              ENDIF

            ENDDO MINDEX20

     ENDPARDO A, I

     MCOUNT = 0.0
     PARDO B, J

           GET R1B_MO_P_CURRENT_R(B,J)
           GET R1B_MO_M_CURRENT_L(B,J)

           TBJP_R(B,J) = R1B_MO_P_CURRENT_R(B,J)
           TBJM_L(B,J) = R1B_MO_M_CURRENT_L(B,J)

           DO MINDEX20
              MCOUNT  += 1.0

              IF MCOUNT == ITER_COUNT

                 PUT R1B_MO_P_HIST_R(B,J,MINDEX20) = TBJP_R(B,J)
                 PUT R1B_MO_M_HIST_L(B,J,MINDEX20) = TBJM_L(B,J)
 
              ENDIF

           ENDDO MINDEX20

     ENDPARDO B, J

     execute sip_barrier

    ENDPROC SAVE_C_VECTORS
#   -----------------------

     PROC FORM_MO_FOCK
#    -----------------

     PARDO I, I1

           TII(I1,I) = FOCK_A(I1,I) 
           PUT FOCK_A_OO(I1,I) = TII(I1,I)

     ENDPARDO I, I1

     PARDO A, A1

           TAA(A1,A)   = FOCK_A(A,A1)
           PUT FOCK_A_VV(A1,A) = TAA(A1,A)

     ENDPARDO A, A1

     PARDO J, J1

           TJJ(J1,J)   = FOCK_B(J,J1)
           PUT FOCK_B_OO(J1,J) = TJJ(J1,J)

     ENDPARDO J, J1

     PARDO B, B1

           TBB(B1,B)   = FOCK_B(B,B1)
           PUT FOCK_B_VV(B1,B) = TBB(B1,B)

     ENDPARDO B, B1

     execute sip_barrier 

     ENDPROC FORM_MO_FOCK
#    --------------------

     PROC FORM_FOCK_CONTRIBUTION
#    ---------------------------

     PARDO A, I

           TAIP_R(A,I) = 0.0
           TAIM_L(A,I) = 0.0

           DO I1

              GET R1A_MO_P_CURRENT_R(A,I1)
              GET R1A_MO_M_CURRENT_L(A,I1)
  
              TAIP_R(A,I1) = R1A_MO_P_CURRENT_R(A,I1)
              TAIM_L(A,I1) = R1A_MO_M_CURRENT_L(A,I1)

              GET FOCK_A_OO(I1,I)
              TII(I1,I) = FOCK_A_OO(I1,I)

              TAI_P(A,I) = TAIP_R(A,I1) * TII(I1,I)
              TAI_M(A,I) = TAIM_L(A,I1) * TII(I1,I)
     
              TAIP_R(A,I) += TAI_P(A,I)
              TAIM_L(A,I) += TAI_M(A,I)

           ENDDO I1

           DO A1

              GET R1A_MO_P_CURRENT_R(A1,I)
              GET R1A_MO_M_CURRENT_L(A1,I)
  
              TAIP_R(A1,I) = R1A_MO_P_CURRENT_R(A1,I)
              TAIM_L(A1,I) = R1A_MO_M_CURRENT_L(A1,I)

              GET FOCK_A_VV(A1,A)
              TAA(A1,A) = FOCK_A_VV(A1,A)

              TAI_P(A,I) = TAIP_R(A1,I) * TAA(A1,A)
              TAI_M(A,I) = TAIM_L(A1,I) * TAA(A1,A)
    
              TAIP_R(A,I) += TAI_P(A,I)
              TAIM_L(A,I) += TAI_M(A,I)

           ENDDO A1

           PUT HR1A_MO_P_CURRENT_R(A,I) += TAIP_R(A,I)
           PUT HR1A_MO_M_CURRENT_L(A,I) += TAIM_L(A,I)

     ENDPARDO A, I

     PARDO B, J

           TBJP_R(B,J) = 0.0
           TBJM_L(B,J) = 0.0

           DO J1

              GET R1B_MO_P_CURRENT_R(B,J1)
              GET R1B_MO_M_CURRENT_L(B,J1)
 
              TBJP_R(B,J1) = R1B_MO_P_CURRENT_R(B,J1)
              TBJM_L(B,J1) = R1B_MO_M_CURRENT_L(B,J1)

              GET FOCK_B_OO(J1,J)
              TJJ(J1,J) = FOCK_B_OO(J1,J)

              TBJ_P(B,J) = TBJP_R(B,J1) * TJJ(J1,J)
              TBJ_M(B,J) = TBJM_L(B,J1) * TJJ(J1,J)
    
              TBJP_R(B,J) += TBJ_P(B,J)
              TBJM_L(B,J) += TBJ_M(B,J)

           ENDDO J1

           DO B1

              GET R1B_MO_P_CURRENT_R(B1,J)
              GET R1B_MO_M_CURRENT_L(B1,J)
 
              TBJP_R(B1,J) = R1B_MO_P_CURRENT_R(B1,J)
              TBJM_L(B1,J) = R1B_MO_M_CURRENT_L(B1,J)

              GET FOCK_B_VV(B1,B)
              TBB(B1,B) = FOCK_B_VV(B1,B)

              TBJ_P(B,J) = TBJP_R(B1,J) * TBB(B1,B)
              TBJ_M(B,J) = TBJM_L(B1,J) * TBB(B1,B)
   
              TBJP_R(B,J) += TBJ_P(B,J)
              TBJM_L(B,J) += TBJ_M(B,J)

           ENDDO B1

           PUT HR1B_MO_P_CURRENT_R(B,J) += TBJP_R(B,J)
           PUT HR1B_MO_M_CURRENT_L(B,J) += TBJM_L(B,J)

     ENDPARDO B, J

     execute sip_barrier 

     ENDPROC FORM_FOCK_CONTRIBUTION
#    ---------------------------

     PROC FORM_AO_R1AB_OLD
#    ---------------------

      PARDO MU, NU

        TXXP(MU,NU) = 0.0
        TXXM(MU,NU) = 0.0

        DO I

           TXIP(MU,I) = 0.0
           TXIM(MU,I) = 0.0

           DO A

              GET R1A_MO_P_CURRENT_R(A,I)
              GET R1A_MO_M_CURRENT_L(A,I)
  
              TAIP_R(A,I) = R1A_MO_P_CURRENT_R(A,I)
              TAIM_L(A,I) = R1A_MO_M_CURRENT_L(A,I)

              TXIP_T(MU,I) = TAIP_R(A,I) * CA(MU,A)
              TXIM_T(MU,I) = TAIM_L(A,I) * CA(MU,A)

              TXIP(MU,I)  += TXIP_T(MU,I)
              TXIM(MU,I)  += TXIM_T(MU,I)

           ENDDO A

           TXXP_T(MU,NU) = TXIP(MU,I) * CA(NU,I)
           TXXM_T(MU,NU) = TXIM(MU,I) * CA(NU,I)

           TXXP(MU,NU)  += TXXP_T(MU,NU)
           TXXM(MU,NU)  += TXXM_T(MU,NU)

        ENDDO I

        PUT R1A_AO_P_CURRENT_R(MU,NU) =  TXXP(MU,NU)
        PUT R1A_AO_M_CURRENT_L(MU,NU) =  TXXM(MU,NU)

      ENDPARDO MU, NU

      PARDO MU, NU
 
       TXXP(MU,NU) = 0.0
       TXXM(MU,NU) = 0.0

        DO J

           TXJP(MU,J) = 0.0
           TXJM(MU,J) = 0.0

           DO B

              GET R1B_MO_P_CURRENT_R(B,J)
              GET R1B_MO_M_CURRENT_L(B,J)

              TBJP_R(B,J) = R1B_MO_P_CURRENT_R(B,J)
              TBJM_L(B,J) = R1B_MO_M_CURRENT_L(B,J)

              TXJP_T(MU,J) = TBJP_R(B,J) * CB(MU,B)
              TXJM_T(MU,J) = TBJM_L(B,J) * CB(MU,B)

              TXJP(MU,J)  += TXJP_T(MU,J)
              TXJM(MU,J)  += TXJM_T(MU,J)

           ENDDO B

           TXXP_T(MU,NU) = TXJP(MU,J) * CB(NU,J)
           TXXM_T(MU,NU) = TXjM(MU,J) * CB(NU,J)

           TXXP(MU,NU)  += TXXP_T(MU,NU)
           TXXM(MU,NU)  += TXXM_T(MU,NU)

        ENDDO J

        PUT  R1B_AO_P_CURRENT_R(MU,NU) =  TXXP(MU,NU)
        PUT  R1B_AO_M_CURRENT_L(MU,NU) =  TXXM(MU,NU)

      ENDPARDO MU, NU

      execute sip_barrier 

     ENDPROC FORM_AO_R1AB_OLD
#    ------------------------

    PROC FORM_AO_APLUSB_AMINUSB
#   ---------------------------

     PARDO MU, NU, LAMBDA, SIGMA

           TXXXX(MU,NU,LAMBDA,SIGMA) = 0.0

           PREPARE APBXXXX(MU,NU,LAMBDA,SIGMA) = TXXXX(MU,NU,LAMBDA,SIGMA)
           PREPARE AMBXXXX(MU,NU,LAMBDA,SIGMA) = TXXXX(MU,NU,LAMBDA,SIGMA)

     ENDPARDO MU, NU, LAMBDA, SIGMA

     EXECUTE SERVER_BARRIER

     PARDO MU, NU, LAMBDA

           DO SIGMA

              COMPUTE_INTEGRALS AOINT(MU,NU,LAMBDA,SIGMA)

              TXXXX(MU,NU,LAMBDA,SIGMA) = AOINT(MU,NU,LAMBDA,SIGMA)

              TP1XXXX(MU,SIGMA,LAMBDA,NU) = TXXXX(MU,NU,LAMBDA,SIGMA)
              TP2XXXX(MU,LAMBDA,SIGMA,NU) = TP1XXXX(MU,SIGMA,LAMBDA,NU)

              TP1XXXX(MU,SIGMA,LAMBDA,NU) *= -1.0

              PREPARE AMBXXXX(MU,NU,LAMBDA,SIGMA) += TP1XXXX(MU,LAMBDA,SIGMA,NU)
              PREPARE AMBXXXX(MU,LAMBDA,SIGMA,NU) += TP2XXXX(MU,LAMBDA,SIGMA,NU)

              TP2XXXX(MU,LAMBDA,SIGMA,NU) *= -1.0
              TXXXX(MU,NU,LAMBDA,SIGMA)   *=  2.0

              PREPARE APBXXXX(MU,NU,LAMBDA,SIGMA) += TXXXX(MU,NU,LAMBDA,SIGMA)
              PREPARE APBXXXX(MU,SIGMA,LAMBDA,NU) += TP1XXXX(MU,SIGMA,LAMBDA,NU)
              PREPARE APBXXXX(MU,LAMBDA,SIGMA,NU) += TP1XXXX(MU,LAMBDA,SIGMA,NU)

           ENDDO SIGMA

     ENDPARDO MU, NU, LAMBDA

     EXECUTE SERVER_BARRIER

     ENDPROC FORM_AO_APLUSB_AMINUSB
#    ------------------------------

     PROC HC_MULTIPLY
#    ----------------

     PARDO MU, NU, LAMBDA, SIGMA

           GET R1A_AO_P_CURRENT_R(MU,NU) 
           GET R1A_AO_M_CURRENT_L(MU,NU)
           GET R1B_AO_P_CURRENT_R(MU,NU)
           GET R1B_AO_M_CURRENT_L(MU,NU) 

           TAXXP(MU,NU) = R1A_AO_P_CURRENT_R(MU,NU)
           TAXXM(MU,NU) = R1A_AO_M_CURRENT_L(MU,NU)
           TBXXP(MU,NU) = R1B_AO_P_CURRENT_R(MU,NU)
           TBXXM(MU,NU) = R1B_AO_M_CURRENT_L(MU,NU)

           REQUEST APBXXXX(MU,NU,LAMBDA,SIGMA) SIGMA 
           REQUEST AMBXXXX(MU,NU,LAMBDA,SIGMA) SIGMA 

           TPXXXX(MU,NU,LAMBDA,SIGMA) = APBXXXX(MU,NU,LAMBDA,SIGMA)
           TMXXXX(MU,NU,LAMBDA,SIGMA) = AMBXXXX(MU,NU,LAMBDA,SIGMA)

           TAPXX_INT(LAMBDA,SIGMA)  = TAXXP(MU,NU) * TPXXXX(MU,NU,LAMBDA,SIGMA)
           TAPXX(LAMBDA,SIGMA)     += TAPXX_INT(LAMBDA,SIGMA)

           TBPXX_INT(LAMBDA,SIGMA)  = TBXXP(MU,NU) * TPXXXX(MU,NU,LAMBDA,SIGMA)
           TBPXX(LAMBDA,SIGMA)     += TBPXX_INT(LAMBDA,SIGMA)

           TAMXX_INT(LAMBDA,SIGMA)  = TAXXM(MU,NU) * TMXXXX(MU,NU,LAMBDA,SIGMA)
           TAMXX(LAMBDA,SIGMA)     += TAMXX_INT(LAMBDA,SIGMA)

           TBMXX_INT(LAMBDA,SIGMA)  = TBXXM(MU,NU) * TMXXXX(MU,NU,LAMBDA,SIGMA)
           TBMXX(LAMBDA,SIGMA)     += TBMXX_INT(LAMBDA,SIGMA)

           PUT HR1A_AO_P_CURRENT_R(LAMBDA,SIGMA) = TAPXX(LAMBDA,SIGMA) 
           PUT HR1A_AO_M_CURRENT_L(LAMBDA,SIGMA) = TAMXX(LAMBDA,SIGMA)
           PUT HR1B_AO_P_CURRENT_R(LAMBDA,SIGMA) = TBPXX(LAMBDA,SIGMA)
           PUT HR1B_AO_M_CURRENT_L(LAMBDA,SIGMA) = TBMXX(LAMBDA,SIGMA)

     ENDPARDO MU, NU, LAMBDA, SIGMA
         
     ENDPROC HC_MULTIPLY
#    -------------------

     PROC FORM_MO_R1AB_NEW
#    ---------------------

     PARDO MU, NU

            GET HR1A_AO_P_CURRENT_R(NU,MU)
            GET HR1A_AO_M_CURRENT_L(NU,MU)

            TXXP(NU,MU) = HR1A_AO_P_CURRENT_R(NU,MU)
            TXXM(NU,MU) = HR1A_AO_M_CURRENT_L(NU,MU)

            DO A

               TXAP(NU,A) = TXXP(NU,MU) * CA(MU,A)
               TXAM(NU,A) = TXXP(NU,MU) * CA(MU,A)
                
               DO I

                  TAIP_R(A,I) = TXAP(NU,A) * CA(NU,I)
                  TAIM_L(A,I) = TXAM(NU,A) * CA(NU,I)

                  PUT HR1A_MO_P_CURRENT_R(A,I) += TAIP_R(A,I)
                  PUT HR1A_MO_M_CURRENT_L(A,I) += TAIM_L(A,I)

               ENDDO I

            ENDDO A

     ENDPARDO MU, NU

     PARDO MU, NU

            GET R1B_AO_P_CURRENT_R(NU,MU)
            GET R1B_AO_M_CURRENT_L(NU,MU)

            TXXP(NU,MU) = R1B_AO_P_CURRENT_R(NU,MU)
            TXXM(NU,MU) = R1B_AO_M_CURRENT_L(NU,MU)

            DO B

               TXBP(NU,B) = TXXP(NU,MU) * CB(MU,B)
               TXBM(NU,B) = TXXP(NU,MU) * CB(MU,B)

               DO J

                  TBJP_R(B,J) = TXBP(NU,B) * CB(NU,J)
                  TBJM_L(B,J) = TXBM(NU,B) * CB(NU,J)

                  PUT HR1B_MO_P_CURRENT_R(B,J) += TBJP_R(B,J)
                  PUT HR1B_MO_M_CURRENT_L(B,J) += TBJM_L(B,J)

               ENDDO J

            ENDDO B

     ENDPARDO MU, NU

     execute sip_barrier 
#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     do a
     do i
        get HR1A_MO_P_CURRENT_R(A,I)
        get HR1A_MO_M_CURRENT_L(A,I)
        tmp   = HR1A_MO_P_CURRENT_R(A,I) * HR1A_MO_P_CURRENT_R(A,I)
        sumap += tmp
        tmp   = HR1A_MO_M_CURRENT_L(A,I) * HR1A_MO_M_CURRENT_L(A,I)
        sumam += tmp
     enddo i
     enddo a
     do b
     do j
      
        get HR1B_MO_P_CURRENT_R(B,J)
        get HR1B_MO_M_CURRENT_L(B,J)
        tmp = HR1B_MO_P_CURRENT_R(B,J) * HR1B_MO_P_CURRENT_r(B,J)
        sumbp += tmp
        tmp = HR1B_MO_M_CURRENT_L(B,J) * HR1B_MO_P_CURRENT_r(B,J)
        sumbm += tmp
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     endif
#end_debug

     ENDPROC FORM_MO_R1AB_NEW
#    -------------------------

     PROC DIRECT_AO_HC_MULT
#    ----------------------

     CALL FORM_AO_R1AB_OLD

#     CALL FORM_AO_APLUSB_AMINUSB
#     execute server_barrier 
     
     CALL HC_MULTIPLY

     CALL FORM_FOCK_CONTRIBUTION

     CALL FORM_MO_R1AB_NEW

     ENDPROC DIRECT_AO_HC_MULT
#    ----------------------

     PROC SAVE_HC_VECTORS
#    --------------------

     MCOUNT = 0.0

     PARDO A, I

           GET R1A_MO_P_CURRENT_R(A,I)
           GET R1A_MO_M_CURRENT_L(A,I)

           TAIP_R(A,I) = R1A_MO_P_CURRENT_R(A,I)
           TAIM_L(A,I) = R1A_MO_M_CURRENT_L(A,I)

           DO MINDEX20
              MCOUNT  += 1.0

              IF MCOUNT == ITER_COUNT

                 PUT R1A_MO_P_HIST_R(A,I,MINDEX20) = TAIP_R(A,I)
                 PUT R1A_MO_M_HIST_L(A,I,MINDEX20) = TAIM_L(A,I)

              ENDIF
            ENDDO MINDEX20

     ENDPARDO A, I

     MCOUNT = 0.0

     PARDO B, J

           GET R1B_MO_P_CURRENT_R(B,J)
           GET R1B_MO_M_CURRENT_L(B,J)

           TBJP_R(B,J) = R1B_MO_P_CURRENT_R(B,J)
           TBJM_L(B,J) = R1B_MO_M_CURRENT_L(B,J)

           DO MINDEX20
              MCOUNT  += 1.0

              IF MCOUNT == ITER_COUNT

                 PUT R1B_MO_P_HIST_R(B,J,MINDEX20) = TBJP_R(B,J)
                 PUT R1B_MO_M_HIST_L(B,J,MINDEX20) = TBJM_L(B,J)
  
              ENDIF 

           ENDDO MINDEX20
     ENDPARDO B, J

     execute sip_barrier

    ENDPROC SAVE_HC_VECTORS
#   -----------------------

     PROC CONSTRUCT_A_MATRIX
#    -----------------------

     IF ITER_COUNT == 1.0

# Build A(1,1) for the first iteraion

        SUMP = 0.0
        SUMM = 0.0

        MCOUNT = 0.0

        PARDO A, I
               DO MINDEX20
                  MCOUNT += 1.0

                  IF MCOUNT == ITER_COUNT

                     GET HR1A_MO_P_CURRENT_R(A,I)
                     GET HR1A_MO_M_CURRENT_L(A,I)

                     TAIP_R(A,I) = HR1A_MO_P_CURRENT_R(A,I)
                     TAIM_L(A,I) = HR1A_MO_M_CURRENT_L(A,I)

                     TMP        = TAIP_R(A,I) * TAIP_R(A,I)
                     SUMP      += TMP

                     TMP         = TAIM_L(A,I) * TAIM_L(A,I)
                     SUMM       += TMP

                     DO NINDEX20

                         IF NINDEX20 ==  MINDEX20

                            A_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                            A_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                         ENDIF

                     ENDDO NINDEX20
                  ENDIF

               ENDDO MINDEX20

        ENDPARDO A, I

        SUMP = 0.0
        SUMM = 0.0

        MCOUNT = 0.0

        PARDO B, J
               DO MINDEX20
                  MCOUNT += 1.0
                  
                  IF MCOUNT == ITER_COUNT

                     GET HR1B_MO_P_CURRENT_R(B,J)
                     GET HR1B_MO_M_CURRENT_L(B,J)

                     TBJP_R(B,J) = HR1B_MO_P_CURRENT_R(B,J)
                     TBJM_L(B,J) = HR1B_MO_M_CURRENT_L(B,J)

                     TMP       = TBJP_R(B,J) * TBJP_R(B,J)
                     SUMP     += TMP

                     TMP       = TBJM_L(B,J) * TBJM_L(B,J)
                     SUMM     += TMP

                      DO NINDEX20
                         NCOUNT += 1.0

                         IF NCOUNT == MCOUNT 

                            B_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                            B_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                         ENDIF

                       ENDDO NINDEX20
                  ENDIF

               ENDDO MINDEX20

        ENDPARDO B, J

        execute sip_barrier 

     ELSE

# Build  A(i,j) i<<j  first

        SUMP = 0.0
        SUMM = 0.0

        MCOUNT = 0.0
        NCOUNT = 0.0

        PARDO A, I

               DO MINDEX20
                  MCOUNT += 1.0

                  IF MCOUNT  == SUBSP_DIM

                     GET HR1A_MO_P_CURRENT_R(A,I)
                     GET HR1A_MO_M_CURRENT_L(A,I)

                     TAIP_R(A,I) = HR1A_MO_P_CURRENT_R(A,I)
                     TAIM_L(A,I) = HR1A_MO_M_CURRENT_L(A,I)

                     DO NINDEX20
                        NCOUNT += 1.0

                        IF NCOUNT == MCOUNT

                           TMP       = TAIP_R(A,I)  * TAIP_R(A,I)
                           SUMP     += TMP

                           TMP       = TAIM_L(A,I)  * TAIM_L(A,I)
                           SUMM     += TMP

                           A_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                           A_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                        ENDIF 

                        IF  NCOUNT < MCOUNT

                           GET R1A_MO_P_HIST_R(A,I,NINDEX20)
                           GET R1A_MO_M_HIST_L(A,I,NINDEX20)

                           T1AIP_R(A,I) = R1A_MO_P_HIST_R(A,I,NINDEX20)
                           T1AIM_L(A,I) = R1A_MO_M_HIST_L(A,I,NINDEX20)

                           TMP       = TAIP_R(A,I)  * T1AIP_R(A,I)
                           SUMP     += TMP

                           TMP       = TAIM_L(A,I)  * T1AIM_L(A,I)
                           SUMM     += TMP

                           A_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                           A_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                        ENDIF

                     ENDDO NINDEX20

                  ENDIF

               ENDDO MINDEX20

        ENDPARDO A, I

        SUMP = 0.0
        SUMM = 0.0
        
        MCOUNT = 0.0
        NCOUNT = 0.0

        PARDO B, J

               DO MINDEX20
                  MCOUNT += 1.0

                  IF MCOUNT == SUBSP_DIM

                     GET HR1B_MO_P_CURRENT_R(B,J)
                     GET HR1B_MO_M_CURRENT_L(B,J)

                     TBJP_R(B,J) = HR1B_MO_P_CURRENT_R(B,J)
                     TBJM_L(B,J) = HR1B_MO_M_CURRENT_L(B,J)

                      DO NINDEX20
                         NCOUNT += 1.0

                         IF NCOUNT == MCOUNT

                           TMP       = TBJP_R(B,J)  * TBJP_R(B,J)
                           SUMP     += TMP

                           TMP       = TBJM_L(B,J)  * TBJM_L(B,J)
                           SUMM     += TMP

                           A_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                           A_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                        ENDIF

                        IF NCOUNT < MCOUNT 

                            GET R1B_MO_P_HIST_R(B,J,NINDEX20)
                            GET R1B_MO_M_HIST_L(B,J,NINDEX20)

                            T1BJP_R(B,J) = R1B_MO_P_HIST_R(B,J,NINDEX20)
                            T1BJM_L(B,J) = R1B_MO_M_HIST_L(B,J,NINDEX20)

                            TMP       = TBJP_R(B,J) * T1BJP_R(B,J)
                            SUMP     += TMP

                            TMP       = TBJM_L(B,J) * T1BJM_L(B,J)
                            SUMM     += TMP

                            B_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                            B_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                         ENDIF
 
                      ENDDO NINDEX20

                  ENDIF

               ENDDO MINDEX20

        ENDPARDO B, J

# Build  A(i,j) i>j  now.

        SUMP = 0.0
        SUMM = 0.0
       
        MCOUNT = 0.0
        NCOUNT = 0.0

        PARDO A, I

               DO MINDEX20
                  MCOUNT += 1.0

                  IF MCOUNT < SUBSP_DIM

                     GET R1A_MO_P_HIST_R(A,I,MINDEX20)
                     GET R1A_MO_M_HIST_L(A,I,MINDEX20)

                     TAIP_R(A,I) = R1A_MO_P_HIST_R(A,I,MINDEX20)
                     TAIM_L(A,I) = R1A_MO_M_HIST_L(A,I,MINDEX20)

                     DO NINDEX20
                        NCOUNT += 1.0

                        IF NCOUNT == SUBSP_DIM

                           GET HR1A_MO_P_CURRENT_R(A,I)
                           GET HR1A_MO_M_CURRENT_L(A,I)

                           T1AIP_R(A,I) = HR1A_MO_P_CURRENT_R(A,I)
                           T1AIM_L(A,I) = HR1A_MO_M_CURRENT_L(A,I)

                           TMP       = TAIP_R(A,I) * T1AIP_R(A,I)
                           SUMP     += TMP

                           TMP       = TAIM_L(A,I) * T1AIM_L(A,I)
                           SUMM     += TMP

                           A_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                           A_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                        ENDIF

                     ENDDO NINDEX20

                  ENDIF

               ENDDO MINDEX20

        ENDPARDO A, I

        SUMP = 0.0
        SUMM = 0.0

        MCOUNT = 0.0
        NCOUNT = 0.0

        PARDO B, J

               DO MINDEX20
                  MCOUNT += 1.0

                  IF MCOUNT < SUBSP_DIM

                     GET R1B_MO_P_HIST_R(B,J,MINDEX20)
                     GET R1B_MO_M_HIST_L(B,J,MINDEX20)

                     TBJP_R(B,J) = R1B_MO_P_HIST_R(B,J,MINDEX20)
                     TBJM_L(B,J) = R1B_MO_M_HIST_L(B,J,MINDEX20)

                      DO NINDEX20
                         NCOUNT += 1.0

                         IF NCOUNT == SUBSP_DIM

                            GET HR1B_MO_P_CURRENT_R(B,J)
                            GET HR1B_MO_M_CURRENT_L(B,J)

                            T1BJP_R(B,J) = HR1B_MO_P_CURRENT_R(B,J)
                            T1BJM_L(B,J) = HR1B_MO_M_CURRENT_L(B,J)

                            TMP       = TBJP_R(B,J) * T1BJP_R(B,J)
                            SUMP     += TMP

                            TMP       = TBJM_L(B,J) * T1BJM_L(B,J)
                            SUMM     += TMP

                            B_A_MATRIX_P(NINDEX20,MINDEX20) = SUMP
                            B_A_MATRIX_M(NINDEX20,MINDEX20) = SUMM

                         ENDIF

                       ENDDO NINDEX20
                  ENDIF

               ENDDO MINDEX20

        ENDPARDO B, J

        execute sip_barrier 

    ENDIF

#bgn_debug
    sumap = 0.0
    sumam = 0.0
    do MINDEX20
    do NINDEX20
       tmp = B_A_MATRIX_P(NINDEX20,MINDEX20) * B_A_MATRIX_P(NINDEX20,MINDEX20)
       sumap += tmp
       tmp = B_A_MATRIX_M(NINDEX20,MINDEX20) * B_A_MATRIX_M(NINDEX20,MINDEX20)
       sumam += tmp
    enddo NINDEX20
    enddo MINDEX20
    execute print_scalar sumap
    execute print_scalar sumam
#end_debug

     ENDPROC CONSTRUCT_A_MATRIX
#    ------------------------

     PROC DIAG_A_MATRIX
#    ------------------

# I am sticking to old EIG_NONSYMM (modified to use DGEEV instead
# ancient rg). In ACES IV. For RPA we only need the right eigen-vectors
# only. As a result, the ACES III SIP format is good enough. The ACES IV
# format is now allowing both left and right vectors transfered to the
# SIAL code. 

# A_MATRIX_P and  A_MATRIX_M are very small (maximum order is 
# is currently set to maximum subspace dimension 20. Both arrays
# must be static. 

     EXECUTE EIG_NONSYMM  A_A_MATRIX_P  EIG_VECS_A_P_R
     EXECUTE EIG_NONSYMM  A_A_MATRIX_M  EIG_VECS_A_M_R
     EXECUTE EIG_NONSYMM  B_A_MATRIX_P  EIG_VECS_B_P_R
     EXECUTE EIG_NONSYMM  B_A_MATRIX_M  EIG_VECS_B_M_R

     execute sip_barrier

     ENDPROC DIAG_A_MATRIX
#    ---------------------

# 
# This is a critical step in Davidson algorithm. The new set of vectors are 
# formed from the eigenvectors of the subspace matrix and the original vectors 
# that is used to built the small matrix. Prciesely speaking, 
# A (N,N) = C^(t) H C^(t), the Eigenvectors of A are b(N,N). 
# the new vectors are fromed by  C_new(m,n) = Sum{i} b(i,k) * C_i(m,n) 
# (C_new_k= b(1,k) * C1 + b(2,k) * C2 + ....)(k=1,..N))
#

      PROC FORM_NEW_VECTORS 
#     ---------------------

       NCOUNT      = 0.0
       MCOUNT      = 0.0

       PARDO A, I 

             DO NINDEX20 
                NCOUNT += 1.0

                IF NCOUNT <= ITER_COUNT
                  
                   DO MINDEX20 
                      MCOUNT += 1.0

                      IF MCOUNT <=  ITER_COUNT

                         TMNP_R(MINDEX20,NINDEX20) = EIG_VECS_A_P_R(MINDEX20,NINDEX20)   
                         TMNM_L(MINDEX20,NINDEX20) = EIG_VECS_A_M_R(MINDEX20,NINDEX20)
                         EXECUTE RETURN_SVAL TMNP_R EVECS_A_P_R 
                         EXECUTE RETURN_SVAL TMNM_L EVECS_A_M_L
                         
                         DO KINDEX20 
                            KCOUNT += 1.0
                        
                            IF KCOUNT == MCOUNT

                               GET R1A_MO_P_HIST_R(A,I,KINDEX20)
                               GET R1A_MO_M_HIST_L(A,I,KINDEX20)

                               TAP_R(A,I) = R1A_MO_P_HIST_R(A,I,KINDEX20)
                               TAM_L(A,I) = R1A_MO_M_HIST_L(A,I,KINDEX20)

                               TAP_R_T(A,I) *= EVECS_A_P_R
                               TAM_L_T(A,I) *= EVECS_A_M_L
  
                               TAP_R(A,I)   += TAP_R_T(A,I)
                               TAM_L(A,I)   += TAM_L_T(A,I)

                               PUT R1A_MO_P_NEW_R(A,I,NINDEX20) = TAP_R(A,I)
                               PUT R1A_MO_M_NEW_L(A,I,NINDEX20) = TAM_L(A,I)

                               GET HR1A_MO_P_HIST_R(A,I,KINDEX20)
                               GET HR1A_MO_M_HIST_L(A,I,KINDEX20)

                               T1AP_R(A,I) = HR1A_MO_P_HIST_R(A,I,KINDEX20)
                               T1AM_L(A,I) = HR1A_MO_M_HIST_L(A,I,KINDEX20)

                               T1AP_R_T(A,I) *= EVECS_A_P_R
                               T1AM_L_T(A,I) *= EVECS_A_M_L
 
                               TAP_R(A,I)    += T1AP_R_T(A,I)
                               TAM_L(A,I)    += T1AM_L_T(A,I)

                               PUT HR1A_MO_P_NEW_R(A,I,NINDEX20) = TAP_R(A,I)
                               PUT HR1A_MO_M_NEW_L(A,I,NINDEX20) = TAM_L(A,I)

                            ENDIF 

                         ENDDO KINDEX20

                     ENDIF 

                  ENDDO MINDEX20

                ENDIF 

             ENDDO NINDEX20

       ENDPARDO A, I 

       NCOUNT      = 0.0
       MCOUNT      = 0.0

       PARDO B, J

             DO NINDEX20
                NCOUNT += 1.0

                IF NCOUNT <= ITER_COUNT

                   DO MINDEX20
                      MCOUNT += 1.0

                      IF MCOUNT <=  ITER_COUNT

                         TMNP_R(MINDEX20,NINDEX20) = EIG_VECS_B_P_R(MINDEX20,NINDEX20)
                         TMNM_L(MINDEX20,NINDEX20) = EIG_VECS_B_M_R(MINDEX20,NINDEX20)
                         EXECUTE RETURN_SVAL TMNP_R EVECS_B_P_R 
                         EXECUTE RETURN_SVAL TMNM_L EVECS_B_M_L

                         DO KINDEX20 
                            KCOUNT += 1.0
                        
                            IF KCOUNT == MCOUNT

                               GET R1B_MO_P_HIST_R(B,J,KINDEX20)
                               GET R1B_MO_M_HIST_L(B,J,KINDEX20)

                               TBP_R(B,J) = R1B_MO_P_HIST_R(B,J,KINDEX20)
                               TBM_L(B,J) = R1B_MO_M_HIST_L(B,J,KINDEX20)

                               TBP_R_T(B,J) *= EVECS_B_P_R
                               TBM_L_T(B,J) *= EVECS_B_M_L
  
                               TBP_R(B,J)   += TBP_R_T(B,J)
                               TBM_L(B,J)   += TBM_L_T(B,J)

                               PUT R1B_MO_P_NEW_R(B,J,NINDEX20) = TBP_R(B,J)
                               PUT R1B_MO_M_NEW_L(B,J,NINDEX20) = TBM_L(B,J)

                               GET HR1B_MO_P_HIST_R(B,J,KINDEX20)
                               GET HR1B_MO_M_HIST_L(B,J,KINDEX20)

                               T1BP_R(B,J) = HR1B_MO_P_HIST_R(B,J,KINDEX20)
                               T1BM_L(B,J) = HR1B_MO_M_HIST_L(B,J,KINDEX20)

                               T1BP_R_T(B,J) *= EVECS_B_P_R
                               T1BM_L_T(B,J) *= EVECS_B_M_L

                               TBP_R(B,J)  += T1BP_R_T(B,J)
                               TBM_L(B,J)  += T1BM_L_T(B,J)

                               PUT HR1B_MO_P_NEW_R(B,J,NINDEX20) = TBP_R(B,J)
                               PUT HR1B_MO_M_NEW_L(B,J,NINDEX20) = TBM_L(B,J)

                            ENDIF 

                         ENDDO KINDEX20

                      ENDIF 

                   ENDDO MINDEX20

                ENDIF

             ENDDO  NINDEX20
 
       ENDPARDO B, J

       execute sip_barrier

#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     ncount = 0.0
     do a
     do i
        do nindex20 
        ncount += 1.0
        if ncount == iter_count 
        get HR1A_MO_P_NEW_R(A,I,nindex20)
        get HR1A_MO_M_NEW_L(A,I,nindex20)
        tmp   = HR1A_MO_P_NEW_R(A,I,nindex20) * HR1A_MO_P_NEW_R(A,I,nindex20)
        sumap += tmp
        tmp   = HR1A_MO_M_NEW_L(A,I,nindex20) * HR1A_MO_M_NEW_L(A,I,nindex20)
        sumam += tmp
        endif 
        enddo nindex20
     enddo i
     enddo a
     ncount=0.0
     do b
     do j
        do nindex20
        ncount += 1.0
        if ncount == iter_count
        get HR1B_MO_P_NEW_R(B,J,nindex20)
        get HR1B_MO_M_NEW_L(B,J,nindex20)
        tmp = HR1B_MO_P_NEW_R(B,J,nindex20) * HR1B_MO_P_NEW_R(B,J,nindex20)
        sumbp += tmp
        tmp = HR1B_MO_M_NEW_L(B,J,nindex20) * HR1B_MO_M_NEW_L(B,J,nindex20)
        sumbm += tmp
        endif 
        enddo nindex20
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     endif
#end_debug


       ENDPROC FORM_NEW_VECTORS 
#      ------------------------

     PROC SELECT_VECTOR_TOGO
#    -----------------------

     IF ITER_COUNT == 1.0

        NCOUNT = 0.0

        PARDO A, I 

              DO MINDEX20
                 NCOUNT += 1.0

                 IF NCOUNT  == ITER_COUNT

                    GET R1A_MO_P_NEW_R(A,I,MINDEX20)
                    GET R1A_MO_M_NEW_L(A,I,MINDEX20)

                    GET HR1A_MO_P_NEW_R(A,I,MINDEX20)
                    GET HR1A_MO_M_NEW_L(A,I,MINDEX20)

                    TAP_R(A,I) = R1A_MO_P_NEW_R(A,I,MINDEX20)
                    TAM_L(A,I) = R1A_MO_M_NEW_L(A,I,MINDEX20)

                    T1AP_R(A,I) = HR1A_MO_P_NEW_R(A,I,MINDEX20)
                    T1AM_L(A,I) = HR1A_MO_M_NEW_L(A,I,MINDEX20)

                    PUT R1A_MO_P_PICKED_R(A,I) = TAP_R(A,I)
                    PUT R1A_MO_M_PICKED_L(A,I) = TAM_L(A,I)

                    PUT HR1A_MO_P_PICKED_R(A,I) = T1AP_R(A,I)
                    PUT HR1A_MO_M_PICKED_L(A,I) = T1AM_L(A,I)

                 ENDIF 

              ENDDO MINDEX20

        ENDPARDO A, I 

        NCOUNT = 0.0

        PARDO B, J

              DO MINDEX20
                 NCOUNT += 1.0

                 IF NCOUNT  == ITER_COUNT

                    GET R1B_MO_P_NEW_R(B,J,MINDEX20)
                    GET R1B_MO_M_NEW_L(B,J,MINDEX20)

                    GET HR1B_MO_P_NEW_R(B,J,MINDEX20)
                    GET HR1B_MO_M_NEW_L(B,J,MINDEX20)

                    TBP_R(B,J) = R1B_MO_P_NEW_R(B,J,MINDEX20)
                    TBM_L(B,J) = R1B_MO_M_NEW_L(B,J,MINDEX20)

                    T1BP_R(B,J) = HR1B_MO_P_NEW_R(B,J,MINDEX20)
                    T1BM_L(B,J) = HR1B_MO_M_NEW_L(B,J,MINDEX20)

                    PUT R1B_MO_P_PICKED_R(B,J) = TBP_R(B,J)
                    PUT R1B_MO_M_PICKED_L(B,J) = TBM_L(B,J)

                    PUT HR1B_MO_P_PICKED_R(B,J) = T1BP_R(B,J)
                    PUT HR1B_MO_M_PICKED_L(B,J) = T1BM_L(B,J)

                 ENDIF 

              ENDDO MINDEX20

        ENDPARDO B, J

        execute sip_barrier 

     ELSE 

        NCOUNT = 0.0
        MCOUNT = 0.0
        RCOUNT = 0.0

        PARDO A, I
              
              DO MAX_NO_ROOTS
                 RCOUNT += 1.0

                 IF RCOUNT == COUNT_NO_ROOTS

                     GET R1A_MO_P_START_R(A,I,MAX_NO_ROOTS) 
                     GET R1A_MO_M_START_L(A,I,MAX_NO_ROOTS) 

                     T1AP_R(A,I) = R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
                     T1AM_L(A,I) = R1A_MO_M_START_L(A,I,MAX_NO_ROOTS)

                     DO NINDEX20
                        NCOUNT += 1.0
                        
                        IF NCOUNT <= ITER_COUNT

                           DO MINDEX20
                              MCOUNT += 1.0
          
                              IF MCOUNT <= ITER_COUNT 

                                 GET R1A_MO_P_NEW_R(A,I,MINDEX20)
                                 GET R1A_MO_M_NEW_L(A,I,MINDEX20)

                                 TAP_R(A,I) = R1A_MO_P_NEW_R(A,I,MINDEX20)
                                 TAM_L(A,I) = R1A_MO_M_NEW_L(A,I,MINDEX20)

                                 TMP = T1AP_R(A,I) * TAP_R(A,I)
                                 OVLPA_P_R_INTMD += TMP

                                 TMP = T1AM_L(A,I) * TAM_L(A,I)
                                 OVLPA_M_L_INTMD += TMP

                              ENDIF 

                           ENDDO MINDEX20

                           execute sip_barrier

                           COLLECTIVE OVLPA_P_R += OVLPA_P_R_INTMD
                           COLLECTIVE OVLPA_M_L += OVLPA_M_L_INTMD

                        ENDIF 

                           OVLPA_HISTORY_P_R(NINDEX20) = OVLPA_P_R
                           OVLPA_HISTORY_M_L(NINDEX20) = OVLPA_M_L

                     ENDDO NINDEX20

                 ENDIF 

              ENDDO MAX_NO_ROOTS

        ENDPARDO A, I

        NCOUNT = 0.0
        MCOUNT = 0.0
        RCOUNT = 0.0

        PARDO B, J

              DO MAX_NO_ROOTS
                 RCOUNT += 1.0

                 IF RCOUNT == COUNT_NO_ROOTS

                     GET R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
                     GET R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)

                     T1BP_R(B,J) = R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
                     T1BM_L(B,J) = R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)

                     DO NINDEX20
                        NCOUNT += 1.0
                        
                        IF NCOUNT <= ITER_COUNT

                           DO MINDEX20
                              MCOUNT  += 1.0

                              IF MCOUNT == NCOUNT 

                                 GET R1B_MO_P_NEW_R(B,J,MINDEX20)
                                 GET R1B_MO_M_NEW_L(B,J,MINDEX20)

                                 TBP_R(B,J) = R1B_MO_P_NEW_R(B,J,MINDEX20)
                                 TBM_L(B,J) = R1B_MO_M_NEW_L(B,J,MINDEX20)

                                 TMP = T1BP_R(B,J) * TBP_R(B,J)
                                 OVLPB_P_R_INTMD += TMP

                                 TMP = T1BM_L(B,J) * TBM_L(B,J)
                                 OVLPB_M_L_INTMD += TMP

                              ENDIF
   
                           ENDDO MINDEX20

                           execute sip_barrier 
                
                           COLLECTIVE OVLPB_P_R += OVLPB_P_R_INTMD
                           COLLECTIVE OVLPB_M_L += OVLPB_M_L_INTMD

                        ENDIF

                           OVLPB_HISTORY_P_R(NINDEX20) = OVLPB_P_R
                           OVLPB_HISTORY_M_L(NINDEX20) = OVLPB_M_L

                     ENDDO NINDEX20

                 ENDIF 

              ENDDO MAX_NO_ROOTS

        ENDPARDO B, J

        execute sip_barrier 
#
# This SIPs returns the index corresponding to the maximum value 
# in the first static array. The return scalar gives the pointer
# to vector that has the maximum overlap with the guess. 
# 

         OVLPA_P_MAX_R = 0.0
         OVLPA_M_MAX_L = 0.0
         OVLPB_P_MAX_R = 0.0
         OVLPB_M_MAX_L = 0.0
   
         EXECUTE REPORT_MAXIMUM OVLPA_HISTORY_P_R OVLPA_P_MAX_R
         EXECUTE REPORT_MAXIMUM OVLPA_HISTORY_M_L OVLPA_M_MAX_L
         EXECUTE REPORT_MAXIMUM OVLPB_HISTORY_P_R OVLPB_P_MAX_R
         EXECUTE REPORT_MAXIMUM OVLPB_HISTORY_M_L OVLPB_M_MAX_L
#
# Get vectors corresponding to the maximum overlap and put them
# in the distributed arrrays labelled as _PICKED_ and return.
#
        PARDO A, I

              DO MINDEX20 

                 MCOUNT += 1.0

                 IF MCOUNT == OVLPA_P_MAX_R

                    GET R1A_MO_P_NEW_R(A,I,MINDEX20)
                    GET HR1A_MO_P_NEW_R(A,I,MINDEX20)

                    TAP_R(A,I)  = R1A_MO_P_NEW_R(A,I,MINDEX20)
                    T1AP_R(A,I) = R1A_MO_P_NEW_R(A,I,MINDEX20)

                    PUT R1A_MO_P_PICKED_R(A,I) =  TAP_R(A,I)
                    PUT HR1A_MO_P_PICKED_R(A,I) = T1AP_R(A,I)

                 ENDIF 

                 IF MCOUNT == OVLPA_M_MAX_L

                    GET R1A_MO_M_NEW_L(A,I,MINDEX20)
                    GET HR1A_MO_M_NEW_L(A,I,MINDEX20)

                    TAM_L(A,I)  = R1A_MO_M_NEW_L(A,I,MINDEX20)
                    T1AM_L(A,I) = R1A_MO_M_NEW_L(A,I,MINDEX20)

                    PUT R1A_MO_M_PICKED_L(A,I)  = TAM_L(A,I)
                    PUT HR1A_MO_M_PICKED_L(A,I) = T1AM_L(A,I)

                 ENDIF 

              ENDDO MINDEX20
       
        ENDPARDO A, I

        PARDO B, J

              DO MINDEX20 

                 MCOUNT += 1.0

                 IF MCOUNT == OVLPB_P_MAX_R

                    GET R1B_MO_P_NEW_R(B,J,MINDEX20)
                    GET HR1B_MO_P_NEW_R(B,J,MINDEX20)

                    TBP_R(B,J)  = R1B_MO_P_NEW_R(B,J,MINDEX20)
                    T1BP_R(B,J) = HR1B_MO_P_NEW_R(B,J,MINDEX20)

                    PUT R1B_MO_P_PICKED_R(B,J)  = TBP_R(B,J)
                    PUT HR1B_MO_P_PICKED_R(B,J) = TBP_R(B,J)

                 ENDIF 

                 IF MCOUNT == OVLPA_M_MAX_L

                    GET R1B_MO_M_NEW_L(B,J,MINDEX20)
                    GET HR1B_MO_M_NEW_L(B,J,MINDEX20)

                    TBM_L(B,J)  = R1B_MO_M_NEW_L(B,J,MINDEX20)
                    T1BM_L(B,J) = HR1B_MO_M_NEW_L(B,J,MINDEX20)

                    PUT R1B_MO_M_PICKED_L(B,J)  = TBM_L(B,J)
                    PUT HR1B_MO_M_PICKED_L(B,J) = TBM_L(B,J)
              
                 ENDIF 

              ENDDO MINDEX20

        ENDPARDO B, J

        execute sip_barrier 

     ENDIF 

#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     do a
     do i
        get HR1A_MO_P_PICKED_R(A,I)
        get HR1A_MO_M_PICKED_L(A,I)
        tmp   = HR1A_MO_P_PICKED_R(A,I) * HR1A_MO_P_PICKED_R(A,I)
        sumap += tmp
        tmp   = HR1A_MO_M_PICKED_L(A,I) * HR1A_MO_M_PICKED_L(A,I)
        sumam += tmp
     enddo i
     enddo a
     do b
     do j
        get HR1B_MO_P_PICKED_R(B,J)
        get HR1B_MO_M_PICKED_L(B,J)
        tmp = HR1B_MO_P_PICKED_R(B,J) * HR1B_MO_P_PICKED_R(B,J)
        sumbp += tmp
        tmp = HR1B_MO_M_PICKED_L(B,J) * HR1B_MO_M_PICKED_L(B,J)
        sumbm += tmp
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     do a
     do i
        get R1A_MO_P_PICKED_R(A,I)
        get R1A_MO_M_PICKED_L(A,I)
        tmp   = R1A_MO_P_PICKED_R(A,I) * R1A_MO_P_PICKED_R(A,I)
        sumap += tmp
        tmp   = R1A_MO_M_PICKED_L(A,I) * R1A_MO_M_PICKED_L(A,I)
        sumam += tmp
     enddo i
     enddo a
     do b
     do j
        get R1B_MO_P_PICKED_R(B,J)
        get R1B_MO_M_PICKED_L(B,J)
        tmp = R1B_MO_P_PICKED_R(B,J) * R1B_MO_P_PICKED_R(B,J)
        sumbp += tmp
        tmp = R1B_MO_M_PICKED_L(B,J) * R1B_MO_M_PICKED_L(B,J)
        sumbm += tmp
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     endif
#end_debug

     ENDPROC SELECT_VECTOR_TOGO
#    --------------------------

      PROC FORM_RESIDUAL_VECTOR
#     -------------------------
# 
       PARDO A, I

             GET R1A_MO_P_PICKED_R(A,I)
             GET R1A_MO_M_PICKED_L(A,I)

             GET HR1A_MO_P_PICKED_R(A,I)
             GET HR1A_MO_M_PICKED_L(A,I)

             TAIP_R(A,I) = R1A_MO_P_PICKED_R(A,I)
             TAIM_L(A,I) = R1A_MO_M_PICKED_L(A,I)

             TAIP_R(A,I) *= OMEGA_P
             TAIM_L(A,I) *= OMEGA_M

             TAIP_R(A,I) *= -1.0
             TAIM_L(A,I) *= -1.0

             T1AIP_R(A,I) = HR1A_MO_P_PICKED_R(A,I)
             T1AIM_L(A,I) = HR1A_MO_M_PICKED_L(A,I)
  
             T1AIP_R(A,I) += TAIP_R(A,I)
             T1AIM_L(A,I) += TAIM_L(A,I)

             PUT RESIDUEA_P_VEC_R(A,I) = T1AIP_R(A,I) 
             PUT RESIDUEA_M_VEC_L(A,I) = T1AIM_L(A,I) 

       ENDPARDO A, I

       PARDO B, J

             GET R1B_MO_P_PICKED_R(B,J)
             GET R1B_MO_M_PICKED_L(B,J)

             GET HR1B_MO_P_PICKED_R(B,J)
             GET HR1B_MO_M_PICKED_L(B,J)

             TBJP_R(B,J) = R1B_MO_P_PICKED_R(B,J)
             TBJM_L(B,J) = R1B_MO_M_PICKED_L(B,J)

             TBJP_R(B,J) *= OMEGA_P
             TBJM_L(B,J) *= OMEGA_M

             TBJP_R(B,J) *= -1.0
             TBJM_L(B,J) *= -1.0

             T1BJP_R(B,J) = HR1B_MO_P_PICKED_R(B,J)
             T1BJM_L(B,J) = HR1B_MO_M_PICKED_L(B,J)
 
             T1BJP_R(B,J) += TBJP_R(B,J)
             T1BJM_L(B,J) += TBJM_L(B,J)

             PUT RESIDUEB_P_VEC_R(B,J) = T1BJP_R(B,J)
             PUT RESIDUEB_M_VEC_L(B,J) = T1BJM_L(B,J)

       ENDPARDO B, J

       execute sip_barrier 

       NORM_INTMD_P_R = 0.0
       NORM_INTMD_M_L = 0.0
       NORMA_P_R = 0.0
       NORMA_M_L = 0.0

       PARDO A, I

             GET RESIDUEA_P_VEC_R(A,I)
             GET RESIDUEA_M_VEC_L(A,I)
             
             TAP_R(A,I) = RESIDUEA_P_VEC_R(A,I)
             TAM_L(A,I) = RESIDUEA_M_VEC_L(A,I)

             TMP = TAP_R(A,I) * TAP_R(A,I)
             NORM_INTMD_P_R += TMP

             TMP = TAM_L(A,I) * TAM_L(A,I)
             NORM_INTMD_M_L += TMP

       ENDPARDO A, I
       
       execute sip_barrier 
       
       COLLECTIVE NORMA_P_R += NORM_INTMD_P_R
       COLLECTIVE NORMA_M_L += NORM_INTMD_M_L

       NORM_INTMD_P_R = 0.0
       NORM_INTMD_M_L = 0.0
       NORMB_P_R = 0.0
       NORMB_M_L = 0.0

       PARDO B, J

             GET RESIDUEB_P_VEC_R(B,J)
             GET RESIDUEB_M_VEC_L(B,J)

             TBP_R(B,J) = RESIDUEB_P_VEC_R(B,J)
             TBM_L(B,J) = RESIDUEB_M_VEC_L(B,J)

             TMP = TBP_R(B,J) * TBP_R(B,J)
             NORM_INTMD_P_R += TMP

             TMP = TBM_L(B,J) * TBM_L(B,J)
             NORM_INTMD_M_L += TMP

       ENDPARDO B, J

       execute sip_barrier

       COLLECTIVE NORMB_P_R += NORM_INTMD_P_R
       COLLECTIVE NORMB_M_L += NORM_INTMD_M_L

#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     do a
     do i
        get RESIDUEA_P_VEC_R(A,I)
        get RESIDUEA_M_VEC_L(A,I)
        tmp   = RESIDUEA_P_VEC_R(A,I) * RESIDUEA_P_VEC_R(A,I)
        sumap += tmp
        tmp   = RESIDUEA_M_VEC_L(A,I) *  RESIDUEA_M_VEC_L(A,I)
        sumam += tmp
     enddo i
     enddo a
     do b
     do j
        get RESIDUEB_P_VEC_R(B,J)
        get RESIDUEB_M_VEC_L(B,J)
        tmp = RESIDUEB_P_VEC_R(B,J) *  RESIDUEB_P_VEC_R(B,J)
        sumbp += tmp
        tmp = RESIDUEB_M_VEC_L(B,J) *  RESIDUEB_M_VEC_L(B,J)
        sumbm += tmp
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     endif
#end_debug


      ENDPROC FORM_RESIDUAL_VECTOR
#     ----------------------------

      PROC FORM_CORRECTION_VECTOR
#     ---------------------------

       PARDO A, I

             GET RESIDUEA_P_VEC_R(A,I)
             GET RESIDUEA_M_VEC_L(A,I)

             GET H_A_DIAGONAL(A,I)

             TAIP_R(A,I) = RESIDUEA_P_VEC_R(A,I)
             TAIM_L(A,I) = RESIDUEA_M_VEC_L(A,I)

             TAIP_R(A,I) *= OMEGA_P
             TAIM_L(A,I) *= OMEGA_M

             T1AI(A,I)   =  H_A_DIAGONAL(A,I)
             T1AI(A,I)  *=  -1.0

             T1AIP_R(A,I) = OMEGA_P
             T1AIM_L(A,I) = OMEGA_M

             T1AIP_R(A,I) += T1AI(A,I)
             T1AIM_L(A,I) += T1AI(A,I)

             EXECUTE APPLY_DEN2 TAIP_R T1AIP_R
             EXECUTE APPLY_DEN2 TAIM_L T1AIM_L

             T2AIP_R(A,I) = TAIP_R(A,I)
             T2AIM_L(A,I) = TAIM_L(A,I)

             PUT CORR_VECA_INTMD_P_R(A,I) = TAIP_R(A,I)
             PUT CORR_VECA_INTMD_M_L(A,I) = TAIM_L(A,I)

       ENDPARDO A, I

       PARDO B, J

             GET RESIDUEB_P_VEC_R(B,J)
             GET RESIDUEB_M_VEC_L(B,J)

             GET H_B_DIAGONAL(B,J)

             TBJP_R(B,J) = RESIDUEB_P_VEC_R(B,J)
             TBJM_L(B,J) = RESIDUEB_M_VEC_L(B,J)

             TBJP_R(B,J) *= OMEGA_P
             TBJM_L(B,J) *= OMEGA_M

             T1BJ(B,J)   =  H_B_DIAGONAL(B,J)
             T1BJ(B,J)  *=  -1.0

             T1BJP_R(B,J) = OMEGA_P
             T1BJM_L(B,J) = OMEGA_M

             T1BJP_R(B,J) += T1BJ(B,J)
             T1BJM_L(B,J) += T1BJ(B,J)

             EXECUTE APPLY_DEN2 TBJP_R T1BJP_R
             EXECUTE APPLY_DEN2 TBJM_L T1BJM_L

             T2BJP_R(B,J) = TBJP_R(B,J)
             T2BJM_L(B,J) = TBJM_L(B,J)

             PUT CORR_VECB_INTMD_P_R(B,J) = TBJP_R(B,J)
             PUT CORR_VECB_INTMD_M_L(B,J) = TBJM_L(B,J)

       ENDPARDO B, J

       execute sip_barrier
#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     do a
     do i
        get CORR_VECA_INTMD_P_R(A,I)
        get CORR_VECA_INTMD_M_L(A,I)
        tmp   = CORR_VECA_INTMD_P_R(A,I) * CORR_VECA_INTMD_P_R(A,I)
        sumap += tmp
        tmp   = CORR_VECA_INTMD_M_L(A,I) * CORR_VECA_INTMD_M_L(A,I)
        sumam += tmp
     enddo i
     enddo a
     do b
     do j
        get CORR_VECB_INTMD_P_R(B,J)
        get CORR_VECB_INTMD_M_L(B,J)
        tmp = CORR_VECB_INTMD_P_R(B,J) *  CORR_VECB_INTMD_P_R(B,J)
        sumbp += tmp
        tmp = CORR_VECB_INTMD_M_L(B,J) *  CORR_VECB_INTMD_M_L(B,J)
        sumbm += tmp
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     endif
#end_debug


      ENDPROC FORM_CORRECTION_VECTOR
#     ------------------------------

      PROC FORM_BIORTHOGANAL_VECS
#     ---------------------------

       NORMA_INTMD_P_R_NEW = 0.0
       NORMA_INTMD_M_L_NEW = 0.0
       NORMA_P_R_NEW = 0.0
       NORMA_M_L_NEW = 0.0

       NORMB_INTMD_P_R_NEW = 0.0
       NORMB_INTMD_M_L_NEW = 0.0
       NORMB_P_R_NEW = 0.0
       NORMB_M_L_NEW = 0.0

       MCOUNT = 0.0
       PARDO A, I

             GET CORR_VECA_INTMD_P_R(A,I)
             GET CORR_VECA_INTMD_M_L(A,I)

             TAP_R(A,I) = CORR_VECA_INTMD_P_R(A,I)
             TAM_L(A,I) = CORR_VECA_INTMD_M_L(A,I)

             TMP = TAP_R(A,I) * TAP_R(A,I)
             NORMA_INTMD_P_R_NEW += TMP

             TMP = TAM_L(A,I) * TAM_L(A,I)
             NORMA_INTMD_M_L_NEW += TMP

             DO MINDEX20
                MCOUNT += 1.0

                IF MCOUNT < SUBSP_DIM

                   GET R1A_MO_P_HIST_R(A,I,MINDEX20)
                   GET R1A_MO_M_HIST_L(A,I,MINDEX20)

                   T1AP_R(A,I) = R1A_MO_P_HIST_R(A,I,MINDEX20)
                   T1AM_L(A,I) = R1A_MO_M_HIST_L(A,I,MINDEX20)

                   TMP  = T1AM_L(A,I) * TAP_R(A,I)
                   TMP *= -1.0
                   PUT ORTHO_COEFSA_P_RL(MINDEX20,MINDEX20) += TMP

                   TMP = T1AP_R(A,I) * TAM_L(A,I)
                   TMP *= -1.0
                   PUT ORTHO_COEFSA_M_RL(MINDEX20,MINDEX20) += TMP

                ENDIF 

             ENDDO MINDEX20

       ENDPARDO A, I

       MCOUNT = 0.0 
       PARDO B, J

             GET CORR_VECB_INTMD_P_R(B,J)
             GET CORR_VECB_INTMD_M_L(B,J)

             TBP_R(B,J) = CORR_VECB_INTMD_P_R(B,J)
             TBM_L(B,J) = CORR_VECB_INTMD_M_L(B,J)

             TMP = TBP_R(B,J) * TBP_R(B,J)
             NORMB_INTMD_P_R_NEW += TMP

             TMP = TBM_L(B,J) * TBM_L(B,J)
             NORMB_INTMD_M_L_NEW += TMP

             DO MINDEX20
                MCOUNT += 1.0

                IF MCOUNT < SUBSP_DIM

                   GET R1B_MO_P_HIST_R(B,J,MINDEX20)
                   GET R1B_MO_M_HIST_L(B,J,MINDEX20)

                   T1BP_R(B,J) = R1B_MO_P_HIST_R(B,J,MINDEX20)
                   T1BM_L(B,J) = R1B_MO_M_HIST_L(B,J,MINDEX20)

                   TMP  = T1BM_L(B,J) * TBP_R(B,J)
                   TMP *= -1.0
                   PUT ORTHO_COEFSB_P_RL(MINDEX20,MINDEX20) += TMP

                   TMP = T1BP_R(B,J) * TBM_L(B,J)
                   TMP *= -1.0
                   PUT ORTHO_COEFSB_M_RL(MINDEX20,MINDEX20) += TMP

                ENDIF 

             ENDDO MINDEX20

       ENDPARDO B, J

       execute sip_barrier

       COLLECTIVE  NORMA_P_R_NEW +=  NORMA_INTMD_P_R_NEW
       COLLECTIVE  NORMA_M_L_NEW +=  NORMA_INTMD_M_L_NEW
       COLLECTIVE  NORMB_P_R_NEW +=  NORMB_INTMD_P_R_NEW
       COLLECTIVE  NORMB_M_L_NEW +=  NORMB_INTMD_M_L_NEW

       PARDO A, I

             GET CORR_VECA_INTMD_P_R(A,I)
             GET CORR_VECA_INTMD_M_L(A,I)

             TAP_R(A,I) = CORR_VECA_INTMD_P_R(A,I)
             TAM_L(A,I) = CORR_VECA_INTMD_M_L(A,I)

             TAP_R(A,I) *= NORMA_P_R_NEW
             TAM_L(A,I) *= NORMA_M_L_NEW

             DO MINDEX20

                   GET  ORTHO_COEFSA_P_RL(MINDEX20,MINDEX20)
                   GET  ORTHO_COEFSA_M_RL(MINDEX20,MINDEX20)

                   TNORM_P_R(MINDEX20,MINDEX20) = ORTHO_COEFSA_P_RL(MINDEX20,MINDEX20)
                   TNORM_M_L(MINDEX20,MINDEX20) = ORTHO_COEFSA_M_RL(MINDEX20,MINDEX20)

                   EXECUTE RETURN_SVAL TNORM_P_R RLP_NORM
                   EXECUTE RETURN_SVAL TNORM_M_L RLM_NORM

                   GET R1A_MO_P_HIST_R(A,I,MINDEX20)
                   GET R1A_MO_M_HIST_L(A,I,MINDEX20)

                   T1AP_R(A,I) = R1A_MO_P_HIST_R(A,I,MINDEX20)
                   T1AM_L(A,I) = R1A_MO_M_HIST_L(A,I,MINDEX20)

                   T1AP_R(A,I) *= RLP_NORM
                   T1AM_L(A,I) *= RLM_NORM

                   TAP_R(A,I) += T1AP_R(A,I)
                   TAM_L(A,I) += T1AM_L(A,I)

              ENDDO MINDEX20

              PUT R1A_MO_P_CURRENT_R(A,I) = TAP_R(A,I)
              PUT R1A_MO_M_CURRENT_L(A,I) = TAM_L(A,I)

       ENDPARDO A, I

       PARDO B, J

             GET CORR_VECB_INTMD_P_R(B,J)
             GET CORR_VECB_INTMD_M_L(B,J)

             TBP_R(B,J) = CORR_VECB_INTMD_P_R(B,J)
             TBM_L(B,J) = CORR_VECB_INTMD_M_L(B,J)

             TBP_R(B,J) *= NORMB_P_R_NEW
             TBM_L(B,J) *= NORMB_M_L_NEW

             DO MINDEX20

                   GET  ORTHO_COEFSB_P_RL(MINDEX20,MINDEX20)
                   GET  ORTHO_COEFSB_M_RL(MINDEX20,MINDEX20)

                   TNORM_P_R(MINDEX20,MINDEX20) = ORTHO_COEFSB_P_RL(MINDEX20,MINDEX20)
                   TNORM_M_L(MINDEX20,MINDEX20) = ORTHO_COEFSB_M_RL(MINDEX20,MINDEX20)

                   EXECUTE RETURN_SVAL TNORM_P_R RLP_NORM
                   EXECUTE RETURN_SVAL TNORM_M_L RLM_NORM

                   GET R1B_MO_P_HIST_R(B,J,MINDEX20)
                   GET R1B_MO_M_HIST_L(B,J,MINDEX20)

                   T1BP_R(B,J) = R1B_MO_P_HIST_R(B,J,MINDEX20)
                   T1BM_L(B,J) = R1B_MO_M_HIST_L(B,J,MINDEX20)

                   T1BP_R(B,J) *= RLP_NORM
                   T1BM_L(B,J) *= RLM_NORM

                   TBP_R(B,J) += T1BP_R(B,J)
                   TBM_L(B,J) += T1BM_L(B,J)

              ENDDO MINDEX20

              PUT R1B_MO_P_CURRENT_R(B,J) = TBP_R(B,J)
              PUT R1B_MO_M_CURRENT_L(B,J) = TBM_L(B,J)

       ENDPARDO B, J

       execute sip_barrier

#bgn_debug
     execute get_my_rank rank
     execute print_scalar rank
     if rank == 0.0
     sumap = 0.0
     sumam = 0.0
     sumbp = 0.0
     sumbm = 0.0
     do a
     do i
        get R1A_MO_P_CURRENT_R(A,I)
        get R1A_MO_M_CURRENT_L(A,I)
        tmp   = R1A_MO_P_CURRENT_R(A,I) * R1A_MO_P_CURRENT_R(A,I)
        sumap += tmp
        tmp   = R1A_MO_M_CURRENT_L(A,I) * R1A_MO_M_CURRENT_L(A,I)
        sumam += tmp
     enddo i
     enddo a
     do b
     do j
        get R1B_MO_P_CURRENT_R(B,J)
        get R1B_MO_M_CURRENT_L(B,J)
        tmp = R1B_MO_P_CURRENT_R(B,J) * R1B_MO_P_CURRENT_R(B,J)
        sumbp += tmp
        tmp = R1B_MO_M_CURRENT_L(B,J) * R1B_MO_M_CURRENT_L(B,J) 
        sumbm += tmp
     enddo j
     enddo b
     execute print_scalar  sumap
     execute print_scalar  sumam
     execute print_scalar  sumbp
     execute print_scalar  sumbm
     endif
#end_debug


       ENDPROC FORM_BIORTHOGANAL_VECS
#      ------------------------------

#
#     BEGIN MAIN PROGRAM
#     -----------------
#
# Read the maximum number of roots and the convergence threshold from
# input.

       TARGET_ROOTS   = eom_roots
       CONV_TOLERANCE = eom_tol

       EXECUTE  PRINT_SCALAR  TARGET_ROOTS
       EXECUTE  PRINT_SCALAR  CONV_TOLERANCE

       CREATE R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
       CREATE R1A_MO_M_START_L(A,I,MAX_NO_ROOTS)
       cREATE R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
       CREATE R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)
       CREATE R1A_MO_P_CURRENT_R(A,I)
       CREATE R1A_MO_M_CURRENT_L(A,I)
       CREATE R1B_MO_P_CURRENT_R(B,J)
       CREATE R1B_MO_M_CURRENT_L(B,J)
       CREATE R1A_AO_P_CURRENT_R(MU,NU)
       CREATE R1A_AO_M_CURRENT_L(MU,NU)
       CREATE R1B_AO_P_CURRENT_R(MU,NU)
       CREATE R1B_AO_M_CURRENT_L(MU,NU)
       CREATE HR1A_AO_P_CURRENT_R(MU,NU) 
       CREATE HR1A_AO_M_CURRENT_L(MU,NU) 
       CREATE HR1B_AO_P_CURRENT_R(MU,NU) 
       CREATE HR1B_AO_M_CURRENT_L(MU,NU) 
       CREATE HR1A_MO_P_CURRENT_R(A,I) 
       CREATE HR1A_MO_M_CURRENT_L(A,I) 
       CREATE HR1B_MO_P_CURRENT_R(B,J) 
       CREATE HR1B_MO_M_CURRENT_L(B,J) 
       CREATE R1A_MO_P_HIST_R(A,I,MINDEX20)
       CREATE R1A_MO_M_HIST_L(A,I,MINDEX20)
       CREATE R1B_MO_P_HIST_R(B,J,MINDEX20)
       CREATE R1B_MO_M_HIST_L(B,J,MINDEX20)
       CREATE HR1A_MO_P_HIST_R(A,I,MINDEX20)
       CREATE HR1A_MO_M_HIST_L(A,I,MINDEX20)
       CREATE HR1B_MO_P_HIST_R(B,J,MINDEX20)
       CREATE HR1B_MO_M_HIST_L(B,J,MINDEX20)
       CREATE R1A_MO_P_NEW_R(A,I,NINDEX20)
       CREATE R1A_MO_M_NEW_L(A,I,NINDEX20)
       CREATE R1B_MO_P_NEW_R(B,J,NINDEX20)
       CREATE R1B_MO_M_NEW_L(B,J,NINDEX20)
       CREATE HR1A_MO_P_NEW_R(A,I,NINDEX20)
       CREATE HR1A_MO_M_NEW_L(A,I,NINDEX20)
       CREATE HR1B_MO_P_NEW_R(B,J,NINDEX20)
       CREATE HR1B_MO_M_NEW_L(B,J,NINDEX20)
       CREATE R1A_MO_P_PICKED_R(A,I)
       CREATE R1A_MO_M_PICKED_L(A,I)
       CREATE R1B_MO_P_PICKED_R(B,J)
       CREATE R1B_MO_M_PICKED_L(B,J)
       CREATE HR1A_MO_P_PICKED_R(A,I)
       CREATE HR1A_MO_M_PICKED_L(A,I)
       CREATE HR1B_MO_P_PICKED_R(B,J)
       CREATE HR1B_MO_M_PICKED_L(B,J)
       CREATE RESIDUEA_P_VEC_R(A,I)
       CREATE RESIDUEA_M_VEC_L(A,I)
       CREATE RESIDUEB_P_VEC_R(B,J)
       CREATE RESIDUEB_M_VEC_L(B,J)
       CREATE CORR_VECA_INTMD_P_R(A,I)
       CREATE CORR_VECA_INTMD_M_L(A,I)
       CREATE CORR_VECB_INTMD_P_R(B,J)
       CREATE CORR_VECB_INTMD_M_L(B,J)
       CREATE ORTHO_COEFSA_P_RL(MINDEX20,MINDEX20)
       CREATE ORTHO_COEFSA_M_RL(MINDEX20,MINDEX20)
       CREATE ORTHO_COEFSB_P_RL(MINDEX20,MINDEX20)
       CREATE ORTHO_COEFSB_M_RL(MINDEX20,MINDEX20)
       CREATE H_A_DIAGONAL(A,I)
       CREATE H_B_DIAGONAL(B,J)
#  
       CALL FORM_MO_FOCK
       CALL FORM_AO_APLUSB_AMINUSB
       execute server_barrier 

       COUNT_NO_ROOTS = 0.0

       DO MAX_NO_ROOTS

          COUNT_NO_ROOTS += 1.0

          IF COUNT_NO_ROOTS > TARGET_ROOTS
             EXIT
          ENDIF 

          ITER_COUNT = 0.0
          CALL FORM_INTIAL_GUESS

          CALL MOVE_GUESS_2CURRENT

          DO MAXIMUM_SUBSP_DIM

             ITER_COUNT  += 1.0

             IF ITER_COUNT >= 2.0
                CALL MOVE_HISTORY_2CURRENT
             ENDIF

# Lets denote the eigenvalue problem we are trying to solve as
# H C = E C and {c_1, c_2, c_3...} expansion vector for a given
# root.

             CALL SAVE_C_VECTORS

# The vector-matrix product in the following step  is really the time
# consuming step in this. The Direct AO based alogrithm implemented
# here is described in several papers: G. B. Bacskay,
# Chemical Physics,61,385,1981 and J. Olsen and co-workers,
# Chemical Physics,119,297,1988.

             CALL DIRECT_AO_HC_MULT

             CALL SAVE_HC_VECTORS

#  A(i,j) = <R_i | H | R_j>, where R_i, i=1,2,3... are the sub-space
# vectors. The diagonalization of the sub-space matrix A gives a
# set of vectors of the dimension of the sub-space matrix (N=1,2..)
# that can be used to form a set of N vectors. One of them will be
# chosen to built the correction vector.
#
            CALL CONSTRUCT_A_MATRIX

            CALL DIAG_A_MATRIX

# The FORM_NEW_VECTORS and SELECT_VECTOR_TOGO do two things. The first one
# will form the set of new vectors using the formula
# C_k (m,n) = A_k(1,1)*R_1 + A_k(2,1)*R_2 +... Following that We will
# have C_k  k=1,.., N where N is curent dimension of
# the sub-space). We select a vector from them based on the criteria
# on the maximum overlap criteria with the starting guess vector.

             CALL FORM_NEW_VECTORS

             CALL SELECT_VECTOR_TOGO

             CALL FORM_RESIDUAL_VECTOR

             CALL FORM_CORRECTION_VECTOR

             CALL FORM_BIORTHOGANAL_VECS

          ENDDO MAXIMUM_SUBSP_DIM

       ENDDO MAX_NO_ROOTS


       DELETE R1A_MO_P_START_R(A,I,MAX_NO_ROOTS)
       DELETE R1A_MO_M_START_L(A,I,MAX_NO_ROOTS)
       DELETE R1B_MO_P_START_R(B,J,MAX_NO_ROOTS)
       DELETE R1B_MO_M_START_L(B,J,MAX_NO_ROOTS)
       DELETE R1A_MO_P_CURRENT_R(A,I)
       DELETE R1A_MO_M_CURRENT_L(A,I)
       DELETE R1B_MO_P_CURRENT_R(B,J)
       DELETE R1B_MO_M_CURRENT_L(B,J)
       DELETE R1A_AO_P_CURRENT_R(MU,NU)
       DELETE R1A_AO_M_CURRENT_L(MU,NU)
       DELETE R1B_AO_P_CURRENT_R(MU,NU)
       DELETE R1B_AO_M_CURRENT_L(MU,NU)
       DELETE HR1A_AO_P_CURRENT_R(MU,NU) 
       DELETE HR1A_AO_M_CURRENT_L(MU,NU) 
       DELETE HR1B_AO_P_CURRENT_R(MU,NU) 
       DELETE HR1B_AO_M_CURRENT_L(MU,NU) 
       DELETE HR1A_MO_P_CURRENT_R(A,I) 
       DELETE HR1A_MO_M_CURRENT_L(A,I) 
       DELETE HR1B_MO_P_CURRENT_R(B,J) 
       DELETE HR1B_MO_M_CURRENT_L(B,J) 
       DELETE R1A_MO_P_HIST_R(A,I,MINDEX20)
       DELETE R1A_MO_M_HIST_L(A,I,MINDEX20)
       DELETE R1B_MO_P_HIST_R(B,J,MINDEX20)
       DELETE R1B_MO_M_HIST_L(B,J,MINDEX20)
       DELETE HR1A_MO_P_HIST_R(A,I,MINDEX20)
       DELETE HR1A_MO_M_HIST_L(A,I,MINDEX20)
       DELETE HR1B_MO_P_HIST_R(B,J,MINDEX20)
       DELETE HR1B_MO_M_HIST_L(B,J,MINDEX20)
       DELETE R1A_MO_P_NEW_R(A,I,NINDEX20)
       DELETE R1A_MO_M_NEW_L(A,I,NINDEX20)
       DELETE R1B_MO_P_NEW_R(B,J,NINDEX20)
       DELETE R1B_MO_M_NEW_L(B,J,NINDEX20)
       DELETE HR1A_MO_P_NEW_R(A,I,NINDEX20)
       DELETE HR1A_MO_M_NEW_L(A,I,NINDEX20)
       DELETE HR1B_MO_P_NEW_R(B,J,NINDEX20)
       DELETE HR1B_MO_M_NEW_L(B,J,NINDEX20)
       DELETE R1A_MO_P_PICKED_R(A,I)
       DELETE R1A_MO_M_PICKED_L(A,I)
       DELETE R1B_MO_P_PICKED_R(B,J)
       DELETE R1B_MO_M_PICKED_L(B,J)
       DELETE HR1A_MO_P_PICKED_R(A,I)
       DELETE HR1A_MO_M_PICKED_L(A,I)
       DELETE HR1B_MO_P_PICKED_R(B,J)
       DELETE HR1B_MO_M_PICKED_L(B,J)
       DELETE RESIDUEA_P_VEC_R(A,I)
       DELETE RESIDUEA_M_VEC_L(A,I)
       DELETE RESIDUEB_P_VEC_R(B,J)
       DELETE RESIDUEB_M_VEC_L(B,J)
       DELETE CORR_VECA_INTMD_P_R(A,I)
       DELETE CORR_VECA_INTMD_M_L(A,I)
       DELETE CORR_VECB_INTMD_P_R(B,J)
       DELETE CORR_VECB_INTMD_M_L(B,J)
       DELETE ORTHO_COEFSA_P_RL(MINDEX20,MINDEX20)
       DELETE ORTHO_COEFSA_M_RL(MINDEX20,MINDEX20)
       DELETE ORTHO_COEFSB_P_RL(MINDEX20,MINDEX20)
       DELETE ORTHO_COEFSB_M_RL(MINDEX20,MINDEX20)
       DELETE H_A_DIAGONAL(A,I)
       DELETE H_B_DIAGONAL(B,J)
#  

                          ENDSIAL DIRECT_RPA_UHF
#                         ----------------------

