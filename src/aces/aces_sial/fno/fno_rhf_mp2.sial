#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
      SIAL FNO_MBPT2
#
#
# -----------------------------------------------------------
#
# Declare indeces 
# --------------- 
      index kiter    = 1, cc_iter
      index jiter    = 1, cc_iter
      index   kptr1  = 1, 2
      index   kptr2  = 1, 2
      index   kone   = 1, 1
#
      aoindex mu     = 1, norb
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#                
      aoindex m      = 1, norb
      aoindex n      = 1, norb
      aoindex l      = 1, norb
      aoindex s      = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
#
# Declare arrays
# tran_xxii
      temp AOINT(mu,nu,lambda,sigma)
      temp V0xxxi(mu,nu,lambda,i)
      local L0xxxi(mu,nu,lambda,i)
      temp Txixx(mu,i,nu,lambda)
      temp Txxix(nu,mu,i,lambda)
      temp Txixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      served Vxixj(mu,i,nu,j)
      served Vxxjj(mu,nu,j1,j)
      served Vixxj(i,mu,nu,j)
# tran_piqj
      local Lxiqj(mu,i,q,j)
      temp Txiqj(mu,i,q,j)
      served Vxiqj(mu,i,q,j)
      local Lpiqj(p,i,q,j)
      temp Tpiqj(p,i,q,j)
      temp T1piqj(p,i,q,j)
      served Vpiqj(p,i,q,j)
      served VSpipi(p1,i,p,i1)
      served ASpipi(a,i,a1,i1)
      served Apiqj(a,i,a1,i1)
# mp2 energy
      temp Taiai(a,i,a1,i1)
      temp T1aiai(a,i,a1,i1)
# main
#
      distributed FTa(p,q)
      static pinf(kiter,kptr1)
      temp tpinf(kiter,kptr1)
      temp Tpipi(p,i,p1,i1)
      distributed Pab_aa(a,a1)
      temp Taa(a,a1)
      temp Tab(a,b)
      temp Twork1(p,p1)
      static NCa(a,a1)
      static SPab(a,a1)
      static VVFock_a(a,a1)
      static SF_a(a,a1)
      static VVUa(a,a1)
      temp Tvtzt(a,b)
      static Svtzt(a,b)
      temp TCa(mu,p)
      distributed SCa(mu,p)
      static SFa(p,q)
      temp T1xp(mu,q)
#
# scalars
#
      scalar etemp
      scalar esum
      scalar esumaa
      scalar ecorraa
      scalar mp2_energy
      scalar zero
      scalar one
      scalar mone
      scalar two
      scalar three
      scalar four
      scalar five
      scalar six
      scalar seven
      scalar ncount1
      scalar ncount2
      scalar numvirt
      scalar virtovertwo
      scalar countstart
      scalar rank
#
# -----------------------------------------------------------
#
     PROC TRAN_XXII
#
     execute sip_barrier
#
     PARDO mu, nu, lambda
#
           allocate L0xxxi(mu,nu,lambda,*) 
#
           DO sigma
#
                 compute_integrals AOINT(mu,nu,lambda,sigma)
#
                 DO i
#
                    V0xxxi(mu,nu,lambda,i) = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                    L0xxxi(mu,nu,lambda,i) += V0xxxi(mu,nu,lambda,i) 
#
                 ENDDO i
#
           ENDDO sigma
#
           DO i
#
              Txixx(lambda,i,mu,nu) = L0xxxi(mu,nu,lambda,i) 
              Txxix(nu,mu,i,lambda) = L0xxxi(mu,nu,lambda,i)  
#
              DO i1
#
                 Txixi(lambda,i,mu,i1) = Txixx(lambda,i,mu,nu)*ca(nu,i1)
                 Txxii(nu,mu,i,i1)     = Txxix(nu,mu,i,lambda)*ca(lambda,i1)
                 Tixxi(i1,nu,lambda,i) = L0xxxi(mu,nu,lambda,i)*ca(mu,i1) 
#
                 prepare Vxixj(lambda,i,mu,i1) += Txixi(lambda,i,mu,i1)
                 prepare Vxxjj(nu,mu,i,i1)     += Txxii(nu,mu,i,i1) 
                 prepare Vixxj(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i) 
#
              ENDDO i1 
#
           ENDDO i
#
           deallocate L0xxxi(mu,nu,lambda,*) 
#
     ENDPARDO mu, nu, lambda 
#
     execute server_barrier
#
     ENDPROC TRAN_XXII
#
     PROC TRAN_PIQJ
#
     execute sip_barrier
#
     PARDO mu, i, j
#
           allocate Lxiqj(mu,i,*,j) 
#
           DO nu 
#
              REQUEST Vxixj(mu,i,nu,j) i
#
              DO q
#
                 Txiqj(mu,i,q,j)  = Vxixj(mu,i,nu,j)*ca(nu,q)
                 Lxiqj(mu,i,q,j) += Txiqj(mu,i,q,j)
#
              ENDDO q
#
           ENDDO nu 
#
           DO q
#
              Txiqj(mu,i,q,j)         = Lxiqj(mu,i,q,j) 
              PREPARE Vxiqj(mu,i,q,j) = Txiqj(mu,i,q,j)
#
           ENDDO q
#
           deallocate Lxiqj(mu,i,*,j) 
#
     ENDPARDO mu, i, j
#
     execute sip_barrier
     execute server_barrier
#
     PARDO q, i, j
#
           allocate Lpiqj(*,i,q,j) 
#
           DO mu 
#
              REQUEST Vxiqj(mu,i,q,j) i 
#
              DO p
#
                 Tpiqj(p,i,q,j)  = Vxiqj(mu,i,q,j)*ca(mu,p)
                 Lpiqj(p,i,q,j) += Tpiqj(p,i,q,j)
#
              ENDDO p
#
           ENDDO mu 
#
           DO p
#
              Tpiqj(p,i,q,j)         = Lpiqj(p,i,q,j) 
              PREPARE Vpiqj(p,i,q,j) = Tpiqj(p,i,q,j)
#
           ENDDO p
#
           deallocate Lpiqj(*,i,q,j) 
#
     ENDPARDO q, i, j
#
     execute sip_barrier
     execute server_barrier
#
     PARDO p, i, q, j 
           REQUEST                   Vpiqj(p,i,q,j) p 
           REQUEST                   Vpiqj(p,j,q,i) p 
           Tpiqj(p,i,q,j)          = Vpiqj(p,i,q,j)  
           T1piqj(p,i,q,j)         = Vpiqj(p,j,q,i)  
           Tpiqj(p,i,q,j)         -= T1piqj(p,i,q,j) 
           PREPARE VSpipi(p,i,q,j) = Tpiqj(p,i,q,j) 
#
     ENDPARDO p, i, q, j 

#    DISCARD Vxiqj
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_PIQJ
#
#
     PROC ENERGY
#
#    ------------------------------------------------------------------------
#
     totenerg = 0.0
     esumaa = 0.0
     ecorraa = 0.0 
     execute sip_barrier
#
     PARDO a, a1, i, i1
#     
           request                    Vpiqj(a,i1,a1,i) i
           request                    Vpiqj(a1,i1,a,i) i
           Taiai(a,i1,a1,i)         = Vpiqj(a,i1,a1,i)
           T1aiai(a,i1,a1,i)        = Vpiqj(a1,i1,a,i)
           Taiai(a,i1,a1,i)        *= 2.0
           Taiai(a,i1,a1,i)        -= T1aiai(a,i1,a1,i)
           execute energy_denominator Taiai
           etemp                    = Taiai(a,i1,a1,i)*Vpiqj(a,i1,a1,i)
          #etemp                   *= 0.25
           esumaa                  += etemp
#
     ENDPARDO a, a1, i, i1
#
     execute sip_barrier
     collective ecorraa += esumaa
     execute sip_barrier

     execute print_scalar ecorraa 
#
     mp2_energy  = ecorraa
     totenerg   = mp2_energy + scfeneg
     execute print_scalar mp2_energy  

     one = 1.0
     two = 2.0
     six = 6.0

      do kiter
      do kptr1
         etemp = 0.0
         pinf(kiter,kptr1)  = etemp
      enddo kptr1
      enddo kiter

        do jiter
           ncount2 = 0.0
         DO kptr1
            ncount2 += 1.0
            if ncount2 == two
               etemp              = ecorraa
               etemp             += scfeneg
               tpinf(jiter,kptr1) = etemp
               pinf(jiter,kptr1)  = tpinf(jiter,kptr1)
            endif
         ENDDO kptr1
        enddo jiter

        do jiter
           ncount2 = 0.0
         DO kptr1
            ncount2 += 1.0
            if ncount2 == one
               tpinf(jiter,kptr1) = ecorraa
               pinf(jiter,kptr1)  = tpinf(jiter,kptr1)
            endif
         ENDDO kptr1
        enddo jiter

        execute print_rel_info six pinf
#
     ENDPROC ENERGY
#
# -----------------------------------------------------------
# -----------------------------------------------------------
#      Main prog
# -----------------------------------------------------------
# -----------------------------------------------------------
      execute sip_barrier
#
      zero = 0.0
      mone = -1.0
      one = 1.0
      two = 2.0
      three = 3.0
      four = 4.0
#
      create Pab_aa
      create FTa
      create SCa
#
      pardo mu,p
          TCa(mu,p) = Ca(mu,p)
          put SCa(mu,p) = TCa(mu,p)
      endpardo mu,p
      pardo p,q
          Twork1(p,q) = Fock_a(p,q)
          put FTa(p,q) = Twork1(p,q)
      endpardo p,q
#
      CALL TRAN_XXII
      CALL TRAN_PIQJ
      CALL ENERGY
      execute sip_barrier totenerg
      execute server_barrier
#     Create the second-order 'amplitudes' 
#     ------------------------------------ 
#
      PARDO a, i, a1, i1
            REQUEST                     VSpipi(a,i,a1,i1) i
            Tpipi(a,i,a1,i1)          = VSpipi(a,i,a1,i1)
            execute energy_denominator  Tpipi(a,i,a1,i1)
            PREPARE ASpipi(a,i,a1,i1) = Tpipi(a,i,a1,i1)
      ENDPARDO a, i, a1, i1
#
      PARDO a, i, a1, i1
            REQUEST                    Vpiqj(a,i,a1,i1) i
            Tpipi(a,i,a1,i1)         = Vpiqj(a,i,a1,i1)
            execute energy_denominator Tpipi(a,i,a1,i1)
            PREPARE Apiqj(a,i,a1,i1) = Tpipi(a,i,a1,i1)
      ENDPARDO a, i, a1, i1
#
      execute sip_barrier
      execute server_barrier
#
# Compute the virtual-virtual block of the density correction
#     AAAA/AAAA piece 
#
      PARDO a, a2, i, i1
#
            REQUEST            ASpipi(a,i,a2,i1) i
            Tpipi(a,i,a2,i1) = ASpipi(a,i,a2,i1)
#
            DO a1
#
               REQUEST             ASpipi(a1,i,a2,i1) i
               Taa(a,a1)         = Tpipi(a,i,a2,i1)*ASpipi(a1,i,a2,i1)
               Taa(a,a1)        *= 0.5
               PUT Pab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, a2, i, i1
#     AABB/AABB piece 
#
      PARDO a, b, i, j
#
            REQUEST          Apiqj(a,i,b,j) i
            Tpiqj(a,i,b,j) = Apiqj(a,i,b,j)
#
            DO a1
#
               REQUEST             Apiqj(a1,i,b,j) i
               Taa(a,a1)         = Tpiqj(a,i,b,j)*Apiqj(a1,i,b,j)
               PUT Pab_aa(a,a1) += Taa(a,a1)
#
            ENDDO a1
#
      ENDPARDO a, b, i, j
#
      execute sip_barrier
# make temporary vv density
      execute get_my_rank rank
      if rank == 0.0
          do a
          do a1
              get Pab_aa(a,a1)
              SPab(a,a1) = Pab_aa(a,a1)
          enddo a1
          enddo a
#          pardo a,a1
#              get pab_aa(a,a1)
#              execute dump_amp pab_aa(a,a1)
#          endpardo a,a1
          execute eig SPab NCa
#         do a
#             do a1
#             execute dump_amp SPab(a1,a)
#             enddo a1
#         enddo a
#         do a
#             do a1
#             execute dump_amp NCa(a1,a)
#             enddo a1
#         enddo a
      endif
# make vv mp2 natural orbitals
      execute broadcast_array SPab
      execute broadcast_array NCa
      execute sip_barrier
# zero small natural orbitals
      execute get_my_rank rank
      if rank == 0.0
          execute form_fno SPab NCa
      endif
      execute broadcast_array SPab
      execute broadcast_array NCa
#      do a
#          do a1
#          execute dump_amp NCa(a1,a)
#          enddo a1
#      enddo a
      execute sip_barrier
# Make VV fock matrix in FNO basis
      execute get_my_rank rank
      if rank == 0.0
          DO b
          DO b1
              DO a
                  get FTa(b,b1)
                  Tab(a,b) = FTa(b,b1)*NCa(b1,a)
                  DO a1
                      Taa(a,a1) = Tab(a,b)*NCa(b,a1)
                      VVFock_a(a,a1) += TaA(a,a1)
                  ENDDO a1
              ENDDO A
          ENDDO b1
          ENDDO b
#         do a
#             do a1
#             execute dump_amp VVFock_a(a,a1)
#             enddo a1
#         enddo a
      endif
      execute broadcast_array VVFock_a
      execute broadcast_array VVUa
      execute sip_barrier
# diagonalize VV fno fock matrix
      execute get_my_rank rank
      if rank == 0.0
          execute eig VVFock_a VVUa
          execute sort_fno VVFock_a VVUa
#          do a
#              do a1
#              execute dump_amp VVFock_a(a,a1)
#              enddo a1
##          enddo a
#          do a
#              do a1
#              execute dump_amp VVUa(a,a1)
#              enddo a1
#          enddo a
      endif
      execute broadcast_array VVFock_a
      execute broadcast_array VVUa
      execute sip_barrier
# UUVa now equals Zt
# Vt*Zt
      execute get_my_rank rank
      if rank == 0.0
          DO a
              DO b
                  DO a1
                      Tvtzt(a,b) = NCa(a,a1)*VVUa(a1,b)
                      Svtzt(a,b) += Tvtzt(a,b)
                  ENDDO a1
              ENDDO b
          ENDDO a
#          do a
#              do a1
#              execute dump_amp Svtzt(a,a1)
#              enddo a1
#          enddo a
# Uvirt*(Vt*Zt)
          do mu
              do p
                  TCa(mu,p) = zero
                  Ca(mu,p) = TCa(mu,p)
              enddo p
          enddo mu
#
          DO mu
              DO b
                  DO a
                      get SCa(mu,a)
                      T1xp(mu,b) = SCa(mu,a)*Svtzt(a,b)
                      Ca(mu,b) += T1xp(mu,b)
                  ENDDO a
              ENDDO b
          ENDDO mu
#
          do mu
              do i
                  get SCa(mu,i)
                  Ca(mu,i) = SCa(mu,i)
              enddo i
          enddo mu
      endif
      execute server_barrier
#      pardo mu,p
#          get SCa(mu,p)
#          execute dump_amp SCa(mu,p)
#      endpardo mu,p
#      pardo mu,p
#          execute dump_amp Ca(mu,p)
#      endpardo mu,p
#
# update VV block of main fock matrix
      execute get_my_rank rank
      if rank == 0.0
          do a
              do b
                  Twork1(a,b) = VVFock_a(a,b)
                  PUT FTa(a,b) = Twork1(a,b)
              ENDDO b
          ENDDO a
#
          do p
              do q
                  GET FTa(p,q)
                  Twork1(p,q) = FTa(p,q)
                  SFa(p,q) = Twork1(p,q)
                  Fock_a(p,q) = Twork1(p,q)
              enddo q
          enddo p
      endif
#
      execute scf_rhf Fock_b cb
      execute print_rel_info three Fock_a
      execute print_rel_info zero Ca
#
      pardo mu,p
          execute dump_amp Ca(mu,p)
      endpardo mu,p
      execute server_barrier
# -----------------------------------------------------------
      ENDSIAL FNO_MBPT2
#
#      do a
#          do a1
#              execute dump_amp work1(a,a1)
#          enddo a1
#      enddo a
#      pardo p, p1
#          execute dump_amp fock_a(p,p1)
#      endpardo p, p1
#
