Only in /home/perera/Develop/ACESIII/sip: abort_job.o
Only in /home/perera/Develop/ACESIII/sip: accumulate_block.o
Only in /home/perera/Develop/ACESIII/sip: add_scal2diag.F
Only in /home/perera/Develop/ACESIII/sip: add_scal2diag.o
Only in /home/perera/Develop/ACESIII/sip: allocate_instruction.o
diff junk/apply_den2.F /home/perera/Develop/ACESIII/sip/apply_den2.F
15,18c15,20
<       subroutine apply_den2(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine apply_den2(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
32c34,75
<       include 'epsilon.h'
---
>       include 'int_gen_parms.h'
>       include 'mpif.h'
>       include 'trace.h'
>       include 'parallel_info.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
>       integer*8 indblk, get_block_index
>       integer block, blkndx, seg
>       integer find_current_block
> 
>       integer i, j, ii, source, target, company, comm, ierr
>       integer source_type, target_type
>       integer nindex_source, nindex_target, stack
>       integer*8 isource, itarget 
>       integer n(mx_array_index),ind(mx_array_index) 
>       integer sval1(mx_array_index),sval2(mx_array_index)  
>       integer tval1(mx_array_index),tval2(mx_array_index)  
>       integer msg(len_sip_server_message)
>       integer status(MPI_STATUS_SIZE) 
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
34,39d76
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
41c78,117
<       if (nindex .ne. nindex2) then
---
> c--------------------------------------------------------------------------
> c   Locate the data for both arrays.  
> c--------------------------------------------------------------------------
> 
>       target = op(c_op1_array)
>       source = op(c_result_array)
> 
> c---------------------------------------------------------------------------
> c   Look up source's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(source, array_table(1,source),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,source)
>       isource = get_block_index(source, block, stack, blkndx, x, .true.) 
> 
> c---------------------------------------------------------------------------
> c   Look up target's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(target, array_table(1,target),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,target)
>       itarget = get_block_index(target, block, stack, blkndx, x, .true.) 
> 
> c--------------------------------------------------------------------------
> c   Check the dimensions of both arrays both arrays.  
> c--------------------------------------------------------------------------
>       
>       source_type = array_table(c_array_type, source)
>       target_type = array_table(c_array_type, target)
> 
>       nindex_source = array_table(c_nindex, source)
>       nindex_target = array_table(c_nindex, target)
> 
>       if (nindex_source .ne. nindex_target) then
44,45c120,121
<          print *,'First array has ',nindex,' indices.'
<          print *,'Second array has ',nindex2,' indices.'
---
>          print *,'First array has ',nindex_source,' indices.'
>          print *,'Second array has ',nindex_target,' indices.'
49c125
<       if (nindex .ne. 2) then 
---
>       if (nindex_source .ne. 2) then 
54,57c130,162
< 
<       call do_div2(x,x2,
<      *                      bval(1),eval(1),bval(2),eval(2),
<      *                      bval2(1),eval2(1),bval2(2),eval2(2))
---
> c-------------------------------------------------------------------------
> c   Get segment ranges of the array source.
> c-------------------------------------------------------------------------
> 
>       do i = 1, nindex_source 
>          ind(i) = array_table(c_index_array1+i-1,source)
>          n(i)   = index_table(c_index_size, ind(i))  ! pick up length of index 
>          seg    = index_table(c_current_seg,ind(i)) 
> 
>          call get_index_segment(ind(i), seg, segment_table,
>      *                          nsegment_table, index_table,
>      *                          nindex_table, sval1(i), sval2(i))
> 
>       enddo
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges of the array target.
> c-------------------------------------------------------------------------
> 
>       do i = 1, nindex_target 
>          ind(i) = array_table(c_index_array1+i-1,target)
>          n(i)   = index_table(c_index_size, ind(i))  ! pick up length of index 
>          seg    = index_table(c_current_seg,ind(i)) 
> 
>          call get_index_segment(ind(i), seg, segment_table,
>      *                          nsegment_table, index_table,
>      *                          nindex_table, tval1(i), tval2(i))
> 
>       enddo
> 
>       call do_div2(x(isource),x(itarget),
>      *                      sval1(1),sval2(1),sval1(2),sval2(2),
>      *                      tval1(1),tval2(1),tval1(2),tval2(2))
78,79c183,189
<          val = x(i,j)/div   
<          x(i,j) = val 
---
>          if (dabs(div) .gt. 1.0d-8) then 
>             val = x(i,j)/div   
>             x(i,j) = val 
>          else 
>             write(6,*) 'Eliminating small denominator in apply_den2 '  
>             x(i,j) = 0.0 
>          endif 
Only in /home/perera/Develop/ACESIII/sip: apply_den2_nor.F
Only in /home/perera/Develop/ACESIII/sip: apply_den2_nor.o
Only in /home/perera/Develop/ACESIII/sip: apply_den2.o
diff junk/apply_den4.F /home/perera/Develop/ACESIII/sip/apply_den4.F
15,18c15,20
<       subroutine apply_den4(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine apply_den4(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
31a34,75
>       include 'int_gen_parms.h'
>       include 'mpif.h'
>       include 'trace.h'
>       include 'parallel_info.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
>       integer*8 indblk, get_block_index
>       integer block, blkndx, seg
>       integer find_current_block
> 
>       integer i, j, ii, source, target, company, comm, ierr
>       integer source_type, target_type
>       integer nindex_source, nindex_target, stack
>       integer*8 isource, itarget
>       integer n(mx_array_index),ind(mx_array_index) 
>       integer sval1(mx_array_index),sval2(mx_array_index)  
>       integer tval1(mx_array_index),tval2(mx_array_index)  
>       integer msg(len_sip_server_message)
>       integer status(MPI_STATUS_SIZE) 
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
33,38d76
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
40c78,117
<       if (nindex .ne. nindex2) then
---
> c--------------------------------------------------------------------------
> c   Locate the data for both arrays.  
> c--------------------------------------------------------------------------
> 
>       target = op(c_op1_array)
>       source = op(c_result_array)
> 
> c---------------------------------------------------------------------------
> c   Look up source's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(source, array_table(1,source),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,source)
>       isource = get_block_index(source, block, stack, blkndx, x, .true.) 
> 
> c---------------------------------------------------------------------------
> c   Look up target's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(target, array_table(1,target),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,target)
>       itarget = get_block_index(target, block, stack, blkndx, x, .true.) 
> 
> c--------------------------------------------------------------------------
> c   Check the dimensions of both arrays both arrays.  
> c--------------------------------------------------------------------------
>       
>       source_type = array_table(c_array_type, source)
>       target_type = array_table(c_array_type, target)
> 
>       nindex_source = array_table(c_nindex, source)
>       nindex_target = array_table(c_nindex, target)
> 
>       if (nindex_source .ne. nindex_target) then
43,44c120,121
<          print *,'First array has ',nindex,' indices.'
<          print *,'Second array has ',nindex2,' indices.'
---
>          print *,'First array has ',nindex_source,' indices.'
>          print *,'Second array has ',nindex_target,' indices.'
48c125
<       if (nindex .ne. 4) then 
---
>       if (nindex_source .ne. 4) then 
53,57c130,164
<       call do_div4(x,x2,
<      *                      bval(1),eval(1),bval(2),eval(2),
<      *                      bval(3),eval(3),bval(4),eval(4), 
<      *                      bval2(1),eval2(1),bval2(2),eval2(2),
<      *                      bval2(3),eval2(3),bval2(4),eval2(4)) 
---
> c-------------------------------------------------------------------------
> c   Get segment ranges of the array source.
> c-------------------------------------------------------------------------
> 
>       do i = 1, nindex_source 
>          ind(i) = array_table(c_index_array1+i-1,source)
>          n(i)   = index_table(c_index_size, ind(i))  ! pick up length of index 
>          seg    = index_table(c_current_seg,ind(i)) 
> 
>          call get_index_segment(ind(i), seg, segment_table,
>      *                          nsegment_table, index_table,
>      *                          nindex_table, sval1(i), sval2(i))
> 
>       enddo
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges of the array target.
> c-------------------------------------------------------------------------
> 
>       do i = 1, nindex_target 
>          ind(i) = array_table(c_index_array1+i-1,target)
>          n(i)   = index_table(c_index_size, ind(i))  ! pick up length of index 
>          seg    = index_table(c_current_seg,ind(i)) 
> 
>          call get_index_segment(ind(i), seg, segment_table,
>      *                          nsegment_table, index_table,
>      *                          nindex_table, tval1(i), tval2(i))
> 
>       enddo
> 
>       call do_div4(x(isource),x(itarget),
>      *                      sval1(1),sval2(1),sval1(2),sval2(2),
>      *                      sval1(3),sval2(3),sval1(4),sval2(4), 
>      *                      tval1(1),tval2(1),tval1(2),tval2(2),
>      *                      tval1(3),tval2(3),tval1(4),tval2(4)) 
80,82c187,191
<          div = y(i,j,k,l) 
<          val = x(i,j,k,l)/div   
<          x(i,j,k,l) = val 
---
> c        if (dabs(div) .gt. 1.0d-5) then 
>             div = y(i,j,k,l) 
>             val = x(i,j,k,l)/div   
>             x(i,j,k,l) = val 
> c        endif 
diff junk/apply_den4_nodiag.F /home/perera/Develop/ACESIII/sip/apply_den4_nodiag.F
15,18c15,20
<       subroutine apply_den4_nodiag(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine apply_den4_nodiag(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
34a37,78
>       include 'int_gen_parms.h'
>       include 'mpif.h'
>       include 'trace.h'
>       include 'parallel_info.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
>       integer*8 indblk, get_block_index
>       integer block, blkndx, seg
>       integer find_current_block
> 
>       integer i, j, ii, source, target, company, comm, ierr
>       integer source_type, target_type
>       integer nindex_source, nindex_target, stack
>       integer*8 isource, itarget
>       integer n(mx_array_index),ind(mx_array_index) 
>       integer sval1(mx_array_index),sval2(mx_array_index)  
>       integer tval1(mx_array_index),tval2(mx_array_index)  
>       integer msg(len_sip_server_message)
>       integer status(MPI_STATUS_SIZE) 
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
36,41d79
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
43c81,120
<       if (nindex .ne. nindex2) then
---
> c--------------------------------------------------------------------------
> c   Locate the data for both arrays.  
> c--------------------------------------------------------------------------
> 
>       target = op(c_op1_array)
>       source = op(c_result_array)
> 
> c---------------------------------------------------------------------------
> c   Look up source's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(source, array_table(1,source),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,source)
>       isource = get_block_index(source, block, stack, blkndx, x, .true.) 
> 
> c---------------------------------------------------------------------------
> c   Look up target's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(target, array_table(1,target),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,target)
>       itarget = get_block_index(target, block, stack, blkndx, x, .true.) 
> 
> c--------------------------------------------------------------------------
> c   Check the dimensions of both arrays both arrays.  
> c--------------------------------------------------------------------------
>       
>       source_type = array_table(c_array_type, source)
>       target_type = array_table(c_array_type, target)
> 
>       nindex_source = array_table(c_nindex, source)
>       nindex_target = array_table(c_nindex, target)
> 
>       if (nindex_source .ne. nindex_target) then
46,47c123,124
<          print *,'First array has ',nindex,' indices.'
<          print *,'Second array has ',nindex2,' indices.'
---
>          print *,'First array has ',nindex_source,' indices.'
>          print *,'Second array has ',nindex_target,' indices.'
51c128
<       if (nindex .ne. 4) then 
---
>       if (nindex_source .ne. 4) then 
56,60c133,167
<       call do_div4nd(x,x2,
<      *                      bval(1),eval(1),bval(2),eval(2),
<      *                      bval(3),eval(3),bval(4),eval(4), 
<      *                      bval2(1),eval2(1),bval2(2),eval2(2),
<      *                      bval2(3),eval2(3),bval2(4),eval2(4)) 
---
> c-------------------------------------------------------------------------
> c   Get segment ranges of the array source.
> c-------------------------------------------------------------------------
> 
>       do i = 1, nindex_source 
>          ind(i) = array_table(c_index_array1+i-1,source)
>          n(i)   = index_table(c_index_size, ind(i))  ! pick up length of index 
>          seg    = index_table(c_current_seg,ind(i)) 
> 
>          call get_index_segment(ind(i), seg, segment_table,
>      *                          nsegment_table, index_table,
>      *                          nindex_table, sval1(i), sval2(i))
> 
>       enddo
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges of the array target.
> c-------------------------------------------------------------------------
> 
>       do i = 1, nindex_target 
>          ind(i) = array_table(c_index_array1+i-1,target)
>          n(i)   = index_table(c_index_size, ind(i))  ! pick up length of index 
>          seg    = index_table(c_current_seg,ind(i)) 
> 
>          call get_index_segment(ind(i), seg, segment_table,
>      *                          nsegment_table, index_table,
>      *                          nindex_table, tval1(i), tval2(i))
> 
>       enddo
> 
>       call do_div4nd(x(isource),x(itarget),
>      *                      sval1(1),sval2(1),sval1(2),sval2(2),
>      *                      sval1(3),sval2(3),sval1(4),sval2(4), 
>      *                      tval1(1),tval2(1),tval1(2),tval2(2),
>      *                      tval1(3),tval2(3),tval1(4),tval2(4)) 
Only in /home/perera/Develop/ACESIII/sip: apply_den4_nodiag.o
Only in /home/perera/Develop/ACESIII/sip: apply_den4.o
Only in /home/perera/Develop/ACESIII/sip: array_copy.o
Only in /home/perera/Develop/ACESIII/sip: assign_block.o
Only in /home/perera/Develop/ACESIII/sip: asymm_force_a.F
Only in /home/perera/Develop/ACESIII/sip: asymm_force_a.o
Only in /home/perera/Develop/ACESIII/sip: asymm_force_i.F
Only in /home/perera/Develop/ACESIII/sip: asymm_force_i.o
Only in /home/perera/Develop/ACESIII/sip: balanc.o
Only in /home/perera/Develop/ACESIII/sip: balbak.o
diff junk/blkmgr.F /home/perera/Develop/ACESIII/sip/blkmgr.F
2685d2684
<       include 'timerz.h'
2725,2745c2724
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_act_timer)
<                    call timer_start(pardo_tserver_timer)
<                 endif
< 
< c               call timer_start(timer_ovrhead)
<                call update_timer(current_instr_timer)  
<                call pause_timer(current_instr_unit_timer)
<                call timer_start(current_instr_mpi_timer)
<                call timer_start (current_instr_mpino_timer)
<                call exec_thread_server(0)
<                call update_timer (current_instr_mpino_timer)
<                call update_timer(current_instr_mpi_timer)
<                call resume_timer(current_instr_unit_timer)
<                call timer_start(current_instr_timer)
< c               call update_timer(timer_ovrhead)
< c                call exec_thread_server(0)
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_tserver_timer)
<                    call timer_start(pardo_act_timer)
<                 endif
---
>                 call exec_thread_server(0)
3037d3015
<       include 'timerz.h'
3050,3052d3027
<       call timer_start(current_instr_allocate_timer)
<       call update_timer(current_instr_timer)
< 
3099,3120c3074
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_act_timer)
<                    call timer_start(pardo_tserver_timer)
<                 endif
< 
< c               call timer_start(timer_ovrhead)
< c               call update_timer(current_instr_timer)  
<                call pause_timer(current_instr_unit_timer)
<                call timer_start(current_instr_mpi_timer)
<                call timer_start (current_instr_mpino_timer)
<                call exec_thread_server(0)
<                call update_timer (current_instr_mpino_timer)
<                call update_timer(current_instr_mpi_timer)
<                call resume_timer(current_instr_unit_timer)
< c               call timer_start(current_instr_timer)
< c               call update_timer(timer_ovrhead)  
< c               call exec_thread_server(0)  
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_tserver_timer)
<                    call timer_start(pardo_act_timer)
<                 endif
< 
---
>                call exec_thread_server(0)  
3163,3164d3116
<             call update_timer(current_instr_allocate_timer)
<             call timer_start(current_instr_timer)
3168,3177d3119
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_act_timer)
<                    call timer_start(pardo_tserver_timer)
<                 endif
<                
< c               call timer_start(timer_ovrhead)
< c               call update_timer(current_instr_timer)  
<                call pause_timer(current_instr_unit_timer)
<                call timer_start(current_instr_mpi_timer)
<                call timer_start (current_instr_mpino_timer)
3179,3188d3120
<                call update_timer (current_instr_mpino_timer)
<                call update_timer(current_instr_mpi_timer)
<                call resume_timer(current_instr_unit_timer)
< c               call timer_start(current_instr_timer)
< c               call update_timer(timer_ovrhead)  
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_tserver_timer)
<                    call timer_start(pardo_act_timer)
<                 endif
< 
3207,3228c3139
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_act_timer)
<                    call timer_start(pardo_tserver_timer)
<                 endif
< 
< c               call timer_start(timer_ovrhead)
< c               call update_timer(current_instr_timer)  
<                call pause_timer(current_instr_unit_timer)
<                call timer_start(current_instr_mpi_timer)
<                call timer_start (current_instr_mpino_timer)
<                call exec_thread_server(0)
<                call update_timer (current_instr_mpino_timer)
<                call update_timer(current_instr_mpi_timer)
<                call resume_timer(current_instr_unit_timer)
< c               call timer_start(current_instr_timer)
< c               call update_timer(timer_ovrhead)  
< c               call exec_thread_server(0)   ! do one pass of thread server.
<                 if (pardo_act_timer .ne. 0) then
<                    call update_timer(pardo_tserver_timer)
<                    call timer_start(pardo_act_timer)
<                 endif
< 
---
>                call exec_thread_server(0)   ! do one pass of thread server.
3240,3241d3150
<       call update_timer(current_instr_allocate_timer)
<       call timer_start(current_instr_timer)
3265d3173
<       include 'timerz.h'
3278,3280d3185
<       call timer_start(current_instr_allocate_timer)
<       call update_timer(current_instr_timer)
<       
3322,3341c3227
<           if (pardo_act_timer .ne. 0) then
<              call update_timer(pardo_act_timer)
<              call timer_start(pardo_tserver_timer)
<           endif
< 
< c               call timer_start(timer_ovrhead)
< c               call update_timer(current_instr_timer)  
<                call pause_timer(current_instr_unit_timer)
<                call timer_start(current_instr_mpi_timer)
<                call timer_start (current_instr_mpino_timer)
<                call exec_thread_server(0)
<                call update_timer (current_instr_mpino_timer)
<                call update_timer(current_instr_mpi_timer)
<                call resume_timer(current_instr_unit_timer)
< c               call timer_start(current_instr_timer)
<           if (pardo_act_timer .ne. 0) then
<              call update_timer(pardo_tserver_timer)
<              call timer_start(pardo_act_timer)
<           endif
< 
---
>           call exec_thread_server(0)  
3362,3363d3247
<       call timer_start(current_instr_timer)
<       call update_timer(current_instr_allocate_timer)
3389,3390d3272
<       call timer_start(current_instr_timer)
<       call update_timer(current_instr_allocate_timer)
Only in /home/perera/Develop/ACESIII/sip: blkmgr.o
Only in /home/perera/Develop/ACESIII/sip: block_end_of_loop.o
Only in /home/perera/Develop/ACESIII/sip: block_map_lookup.o
Only in /home/perera/Develop/ACESIII/sip: block_on_server_delay.o
Only in /home/perera/Develop/ACESIII/sip: blocks_to_list.o
diff junk/broadcast_array.F /home/perera/Develop/ACESIII/sip/broadcast_array.F
15,16c15,20
<       subroutine broadcast_array(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine broadcast_array(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24a29
>       include 'trace.h'
25a31,35
>       include 'dbugcom.h'
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
27,29c37,46
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
31,32c48,49
<       integer i, n, company_comm, ierr
<       integer pst_get_company_comm
---
>       integer ierr, array, array_type, ind
>       integer i
34,36c51,87
< c----------------------------------------------------------------------------
< c   Broadcast the data.
< c----------------------------------------------------------------------------
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (ptr, x)
> #else
>       common x
> #endif
> 
>       integer*8 daddr, indx
>       integer*8 get_index_from_base
>       integer n, nindex, val1, val2
>       integer company_comm, pst_get_company_comm
> 
> #ifdef ALTIX
>       ptr = dshptr
> #endif
>       array = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       if (array_type .ne. static_array) then
>          print *,'Error in broadcast_array: Arg must be a static array'
>          call abort_job()
>       endif
> 
>       if (array .lt. 1 .or. array .gt. narray_table) then
>          print *,'Error: Invalid array in get_my_rank, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif
> 
> c---------------------------------------------------------------------------
> c   Locate the array's memory and determine the size of the array.
> c---------------------------------------------------------------------------
> 
>       daddr = address_table(array)
>       indx = get_index_from_base(daddr, x, 2)
>       nindex = array_table(c_nindex,array)
40c91,93
<          n = n * (edim(i)-bdim(i)+1)
---
>          val1 = array_table(c_index_range1+i-1,array)
>          val2 = array_table(c_index_range2+i-1,array)
>          n = n * (val2-val1+1)
42a96,99
> c----------------------------------------------------------------------------
> c   Broadcast the data.
> c----------------------------------------------------------------------------
> 
44c101
<       call mpi_bcast(x, n, MPI_DOUBLE_PRECISION, 0,
---
>       call mpi_bcast(x(indx), n, MPI_DOUBLE_PRECISION, 0,
Only in /home/perera/Develop/ACESIII/sip: broadcast_array.o
Only in /home/perera/Develop/ACESIII/sip: build_proctab.o
Only in /home/perera/Develop/ACESIII/sip: c1b_print.o
diff junk/c1_print.F /home/perera/Develop/ACESIII/sip/c1_print.F
185,188c185,188
< c        write(66,*) ' ' 
< c        write(66,10)  
< c        write(66,20)  
< c        write(66,40)  
---
>          write(66,*) ' ' 
>          write(66,10)  
>          write(66,20)  
>          write(66,40)  
Only in /home/perera/Develop/ACESIII/sip: c1_print.o
Only in /home/perera/Develop/ACESIII/sip: c2aa_print.o
Only in /home/perera/Develop/ACESIII/sip: c2ab_print.o
Only in /home/perera/Develop/ACESIII/sip: c2bb_print.o
Only in /home/perera/Develop/ACESIII/sip: calc_trace.F
Only in /home/perera/Develop/ACESIII/sip: calc_trace.o
Only in /home/perera/Develop/ACESIII/sip: c_blkmgr.h
Only in /home/perera/Develop/ACESIII/sip: c_blkmgr.o
Only in /home/perera/Develop/ACESIII/sip: cco.o
Only in /home/perera/Develop/ACESIII/sip: change_occ_coef.F
Only in /home/perera/Develop/ACESIII/sip: change_occ_coef.o
Only in /home/perera/Develop/ACESIII/sip: change_occ_dens.F
Only in /home/perera/Develop/ACESIII/sip: change_occ_dens.o
Only in /home/perera/Develop/ACESIII/sip: change_vrt_dens.F
Only in /home/perera/Develop/ACESIII/sip: change_vrt_dens.o
Only in /home/perera/Develop/ACESIII/sip: check_array_status.o
diff junk/check_dconf.F /home/perera/Develop/ACESIII/sip/check_dconf.F
15,18c15,21
<       subroutine check_dconf(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine check_dconf(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute check_dconf array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: check_dconf at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in check_dconv  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: check_dconf at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in check_dconv must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in check_dconv, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in check_dconv, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,159
<       call docheck(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
> 
>       call docheck(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: check_dconf.o
diff junk/checkpoint.F /home/perera/Develop/ACESIII/sip/checkpoint.F
81d80
<             msg(3) = 0
Only in /home/perera/Develop/ACESIII/sip: checkpoint.o
Only in /home/perera/Develop/ACESIII/sip: check_where_conditions.o
Only in /home/perera/Develop/ACESIII/sip: chunk_size.o
Only in /home/perera/Develop/ACESIII/sip: collective_sum.o
diff junk/commit_checkpoint.F /home/perera/Develop/ACESIII/sip/commit_checkpoint.F
95,96d94
<          msg(2) = 0
<          msg(3) = 0
Only in /home/perera/Develop/ACESIII/sip: commit_checkpoint.o
Only in /home/perera/Develop/ACESIII/sip: comp_ovl3c.o
Only in /home/perera/Develop/ACESIII/sip: comp_return_h0.o
Only in /home/perera/Develop/ACESIII/sip: compt3_a.o
Only in /home/perera/Develop/ACESIII/sip: compt3_i.o
Only in /home/perera/Develop/ACESIII/sip: compute_aaaa_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_aaaa_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_aaab_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_aaab_integrals.o
diff junk/compute_aabb_batch.F /home/perera/Develop/ACESIII/sip/compute_aabb_batch.F
15,16c15,20
<       subroutine compute_aabb_batch(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine compute_aabb_batch(array_table,
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
18a23
>       include 'mpif.h'
21a27
>       include 'parallel_info.h'
26,28c32,56
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table, array 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table), get_index_from_base
>       integer*8 get_block_data_index
>       integer find_current_block, block 
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer ind, seg, val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
30c58,59
<       double precision dbuf(1)
---
>       double precision x(1)
>       double precision dbuf(1), temp 
33a63
>       pointer (xptr, x)
36c66
<       common dbuf
---
>       common dbuf, x
40,41c70,71
<       integer*8 integral_scr
<       integer maxblk , nsend
---
>       array = op(c_result_array)
>       direct_flag = .false. 
45a76
>       xptr = dshptr
47a79,133
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the 
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(array,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(array, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(array, blk, blkndx, op)
>          call set_block_computed_flag(array, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,array)
>       indblk = get_block_index(array, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Get the segment ranges for each index of the integral array.
> c--------------------------------------------------------------------------
> 
>       nind = array_table(c_nindex,array)
>       if (nind .ne. 4) then
>          print *,'Error: local_integral_block was called with array ',
>      *        array,' which has ',nind,' indices.'
>          print *,'       This routine requires 4 indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nind
>          ind = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,ind)
>          call get_index_segment(ind, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>       block = find_current_block(array, array_table(1,array),
>      *                          index_table, nindex_table,
>      *                          segment_table, nsegment_table,
>      *                          block_map_table, blkndx)
> 
>       stack = array_table(c_array_stack, array)
>       indblk = get_block_data_index(array, block, stack,
>      *                              blkndx, x)
> 
62,63c148,149
<      *   call compute_aabb_integrals(bval(1),eval(1), bval(2),eval(2),
<      *                       bval(3),eval(3),bval(4),eval(4),
---
>      *   call compute_aabb_integrals(val1(1),val2(1), val1(2),val2(2),
>      *                       val1(3),val2(3),val1(4),val2(4),
67c153
<      *                 x, nsend)
---
>      *                 x(indblk), nsend)
Only in /home/perera/Develop/ACESIII/sip: compute_aabb_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_aabb_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_aabc_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_aabc_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_abab_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_abab_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_abac_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_abac_integrals.o
diff junk/compute_abcd_batch.F /home/perera/Develop/ACESIII/sip/compute_abcd_batch.F
15,16c15,20
<       subroutine compute_abcd_batch(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine compute_abcd_batch(array_table,
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
18d21
< 
19a23
>       include 'mpif.h'
22a27
>       include 'parallel_info.h'
27,29c32,56
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table, array 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table), get_index_from_base
>       integer*8 get_block_data_index
>       integer find_current_block, block 
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer ind, seg, val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
31c58,59
<       double precision dbuf(1)
---
>       double precision x(1)
>       double precision dbuf(1), temp 
34a63
>       pointer (xptr, x)
37c66
<       common dbuf
---
>       common dbuf, x
41,42c70,71
<       integer*8 integral_scr
<       integer maxblk , nsend
---
>       array = op(c_result_array)
>       direct_flag = .false. 
46a76
>       xptr = dshptr
48a79,133
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the 
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(array,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(array, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(array, blk, blkndx, op)
>          call set_block_computed_flag(array, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,array)
>       indblk = get_block_index(array, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Get the segment ranges for each index of the integral array.
> c--------------------------------------------------------------------------
> 
>       nind = array_table(c_nindex,array)
>       if (nind .ne. 4) then
>          print *,'Error: local_integral_block was called with array ',
>      *        array,' which has ',nind,' indices.'
>          print *,'       This routine requires 4 indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nind
>          ind = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,ind)
>          call get_index_segment(ind, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>       block = find_current_block(array, array_table(1,array),
>      *                          index_table, nindex_table,
>      *                          segment_table, nsegment_table,
>      *                          block_map_table, blkndx)
> 
>       stack = array_table(c_array_stack, array)
>       indblk = get_block_data_index(array, block, stack,
>      *                              blkndx, x)
> 
63,64c148,149
<      *   call compute_abcd_integrals(bval(1),eval(1), bval(2),eval(2),
<      *                       bval(3),eval(3),bval(4),eval(4),
---
>      *   call compute_abcd_integrals(val1(1),val2(1), val1(2),val2(2),
>      *                       val1(3),val2(3),val1(4),val2(4),
66,68c151,153
<      *                 dbuf(icoord),dbuf(ipcoeff),dbuf(ialpha),
<      *                 ibuf(iccbeg), ibuf(iccend),
<      *                 x, nsend)
---
>      *                 dbuf(icoord),dbuf(ipcoeff),dbuf(ialpha), 
>      *                 ibuf(iccbeg), ibuf(iccend), 
>      *                 x(indblk), nsend)
Only in /home/perera/Develop/ACESIII/sip: compute_abcd_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_abcd_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_atomscf_coeff.f
Only in /home/perera/Develop/ACESIII/sip: compute_atomscf_coeff.o
Only in /home/perera/Develop/ACESIII/sip: compute_atomscf.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch1.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch2.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch3.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch4.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch5.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch6.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch7.o
Only in /home/perera/Develop/ACESIII/sip: compute_batch8.o
diff junk/compute_block.F /home/perera/Develop/ACESIII/sip/compute_block.F
48,50d47
< #ifdef ALTIX
<       include 'sheap.h'
< #endif
71c68
<       integer nindex, nindex1, nindex2
---
>       integer nindex
90,102d86
<       integer uflag, nargs
<       integer type(mx_array_index), bval(mx_array_index), 
<      *        eval(mx_array_index), bdim(mx_array_index),
<      *        edim(mx_array_index)
<       integer*8 indblk
<       integer type1(mx_array_index), bval1(mx_array_index), 
<      *        eval1(mx_array_index), bdim1(mx_array_index),
<      *        edim1(mx_array_index)
<       integer type2(mx_array_index), bval2(mx_array_index), 
<      *        eval2(mx_array_index), bdim2(mx_array_index),
<      *        edim2(mx_array_index)
<       integer*8 indblk1
<       integer*8 indblk2
108,118d91
<       double precision x(1)
< #ifdef ALTIX
<       pointer (dptr, x)
< #else
<       common x
< #endif
< 
< #ifdef ALTIX
<       dptr = dshptr
< #endif
< 
235,307d207
<          call get_upgrade_flag(op(c_user_sub), uflag)
< 
<          if (uflag .eq. 1) then
<             nargs = 0
<             if (op(c_result_array) .ne. 0) then
<                nargs = nargs + 1
< 
< c---------------------------------------------------------------------------
< c   Get system info about the result array's block.
< c---------------------------------------------------------------------------
< 
<             call retrieve_block_info(x, op(c_result_array), 
<      *               array_table, narray_table,
<      *               index_table, nindex_table, segment_table,
<      *               nsegment_table, block_map_table, nblock_map_table,
<      *               scalar_table, nscalar_table,
<      *               address_table, op,
<      *               indblk, nindex,
<      *               type, bval, eval, bdim, edim)
<             endif
< 
<             if (op(c_op1_array) .ne. 0) then
<                nargs = nargs + 1
< 
< c---------------------------------------------------------------------------
< c   Get system info about the current block of the 1st operand array.
< c---------------------------------------------------------------------------
< 
<                call retrieve_block_info(x, op(c_op1_array), 
<      *               array_table, narray_table,
<      *               index_table, nindex_table, segment_table,
<      *               nsegment_table, block_map_table, nblock_map_table,
<      *               scalar_table, nscalar_table,
<      *               address_table, op,
<      *               indblk1, nindex1,
<      *               type1, bval1, eval1, bdim1, edim1)
<             endif   
< 
<             if (op(c_op2_array) .ne. 0) then
<                nargs = nargs + 1
< 
< c---------------------------------------------------------------------------
< c   Get system info about the current block of the 2nd operand array.
< c---------------------------------------------------------------------------
< 
<                call retrieve_block_info(x, op(c_op2_array), 
<      *               array_table, narray_table,
<      *               index_table, nindex_table, segment_table,
<      *               nsegment_table, block_map_table, nblock_map_table,
<      *               scalar_table, nscalar_table,
<      *               address_table, op,
<      *               indblk2, nindex2,
<      *               type2, bval2, eval2, bdim2, edim2)
<             endif   
< 
<             if (nargs .gt. 0) then 
<              
< c---------------------------------------------------------------------------
< c   Call user-written code with only system info arguments.
< c---------------------------------------------------------------------------
< 
<                   call exec_user_sub2(op(c_user_sub), x(indblk), 
<      *                  nindex, type, 
<      *                  bval, eval, bdim, edim,
<      *                 x(indblk1), nindex1, type1, bval1, eval1,
<      *                  bdim1, edim1,
<      *                 x(indblk2), nindex2, type2, bval2, eval2,
<      *                  bdim2, edim2, nargs)
<          else
<             print *,'Error:User instruction with upgrade, but no args.'
<             call abort_job()
<          endif   ! uflag
<       else  
318d217
<          endif
Only in /home/perera/Develop/ACESIII/sip: compute_block.o
Only in /home/perera/Develop/ACESIII/sip: compute_derivative_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_diis.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals1.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals2.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals3.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals4.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals5.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals6.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals7.o
Only in /home/perera/Develop/ACESIII/sip: compute_integrals8.o
diff junk/compute_no4c_batch.F /home/perera/Develop/ACESIII/sip/compute_no4c_batch.F
15,16c15,20
<       subroutine compute_no4c_batch(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine compute_no4c_batch(array_table,
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
18d21
< 
19a23
>       include 'mpif.h'
22a27
>       include 'parallel_info.h'
27,29c32,56
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table, array 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table), get_index_from_base
>       integer*8 get_block_data_index
>       integer find_current_block, block 
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer ind, seg, val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
31c58,59
<       double precision dbuf(1)
---
>       double precision x(1)
>       double precision dbuf(1), temp 
34a63
>       pointer (xptr, x)
37c66
<       common dbuf
---
>       common dbuf, x
41,42c70,71
<       integer*8 integral_scr
<       integer maxblk , nsend
---
>       array = op(c_result_array)
>       direct_flag = .false. 
46a76
>       xptr = dshptr
48a79,133
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the 
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(array,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(array, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(array, blk, blkndx, op)
>          call set_block_computed_flag(array, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,array)
>       indblk = get_block_index(array, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Get the segment ranges for each index of the integral array.
> c--------------------------------------------------------------------------
> 
>       nind = array_table(c_nindex,array)
>       if (nind .ne. 4) then
>          print *,'Error: local_integral_block was called with array ',
>      *        array,' which has ',nind,' indices.'
>          print *,'       This routine requires 4 indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nind
>          ind = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,ind)
>          call get_index_segment(ind, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>       block = find_current_block(array, array_table(1,array),
>      *                          index_table, nindex_table,
>      *                          segment_table, nsegment_table,
>      *                          block_map_table, blkndx)
> 
>       stack = array_table(c_array_stack, array)
>       indblk = get_block_data_index(array, block, stack,
>      *                              blkndx, x)
> 
63,64c148,149
<      *   call compute_no4c_integrals(bval(1),eval(1), bval(2),eval(2),
<      *                       bval(3),eval(3),bval(4),eval(4),
---
>      *   call compute_no4c_integrals(val1(1),val2(1), val1(2),val2(2),
>      *                       val1(3),val2(3),val1(4),val2(4),
66,68c151,154
<      *                 dbuf(icoord),dbuf(ipcoeff),dbuf(ialpha),
<      *                 ibuf(iccbeg), ibuf(iccend),
<      *                 x, nsend)
---
>      *                 dbuf(icoord),dbuf(ipcoeff),dbuf(ialpha), 
>      *                 ibuf(iccbeg), ibuf(iccend), 
>      *                 x(indblk), nsend)
> 
Only in /home/perera/Develop/ACESIII/sip: compute_no4c_batch.o
Only in /home/perera/Develop/ACESIII/sip: compute_no4c_integrals.o
diff junk/compute_Sderivative_integrals.F /home/perera/Develop/ACESIII/sip/compute_Sderivative_integrals.F
15,16c15,20
<       subroutine compute_Sderivative_integrals(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine compute_Sderivative_integrals(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
25a30,33
>       include 'interpreter.h'
>       include 'trace.h'
>       include 'parallel_info.h'
>       include 'mpif.h'
28c36,37
<       include 'trace.h'
---
>       include 'machine_types.h'
>       include 'dbugcom.h'
32a42,71
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer array, ind(mx_array_index), nindex, ierr
>       integer block, blkndx, shandle, seg
>       integer*8 iderblk(4,3), indblk, get_block_data_index
>       integer stack, handle, handle2, icenter, match
>       integer find_current_block
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer iatom, igrad, flopcount
>       integer component
> 
>       integer i, j, k
>       integer a1,a2,b1,b2,c1,c2,d1,d2
>       integer index 
>       integer nsend
>       integer der_flags(12)
>       
>       integer my_comm_rank, comm
>       integer*8 c_loc64, ixx
> 
43,48c82
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
< 
<       integer der_flags(12)
<       integer k
---
>       integer flag, iarray 
51d84
<  
56a90,127
> c----------------------------------------------------------------------------
> c   Locate the data for the intermediate block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       if (nindex .ne. 4) then 
>          write(6,*) ' ERROR : number of indices wrong when calling ',
>      *              ' compute_Sderivative_integrals ', nindex 
>          call abort_job()
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,ind(i))
>          call get_index_segment(ind(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
>       a1 = val1(1)
>       a2 = val2(1)
>       b1 = val1(2)
>       b2 = val2(2)
>       c1 = val1(3)
>       c2 = val2(3)
>       d1 = val1(4)
>       d2 = val2(4)
> 
>       block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>       stack = array_table(c_array_stack,array)
>       indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, dbuf)
> 
69,70c140
<          call contract_erd_2der(bval(1),eval(1),bval(2),eval(2),
<      *               bval(3),eval(3),bval(4),eval(4),
---
>          call contract_erd_2der(a1,a2,b1,b2,c1,c2,d1,d2,
75c145
<      *               x, dbuf(ix_hess))
---
>      *               dbuf(indblk), dbuf(ix_hess))
83,84c153
<          call tester_MRT2(bval(1),eval(1),bval(2),eval(2),
<      *               bval(3),eval(3),bval(4),bval(4),
---
>          call tester_MRT2(a1,a2,b1,b2,c1,c2,d1,d2,
89c158
<      *               x, dbuf(ix_hess))
---
>      *               dbuf(indblk), dbuf(ix_hess))
96,97c165
<          call tester_MRT3(bval(1),eval(1),bval(2),eval(2),
<      *               bval(3),eval(3),bval(4),bval(4),
---
>          call tester_MRT3(a1,a2,b1,b2,c1,c2,d1,d2,
102c170
<      *               x)
---
>      *               dbuf(indblk))
108,109c176
<          call tester_MRT4(bval(1),eval(1),bval(2),eval(2),
<      *               bval(3),eval(3),bval(4),bval(4),
---
>          call tester_MRT4(a1,a2,b1,b2,c1,c2,d1,d2,
114c181
<      *               x)
---
>      *               dbuf(indblk))
120d186
< 
Only in /home/perera/Develop/ACESIII/sip: compute_Sderivative_integrals.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch1.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch2.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch3.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch4.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch5.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch6.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch7.o
Only in /home/perera/Develop/ACESIII/sip: compute_ubatch8.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals1.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals2.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals3.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals4.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals6.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals7.o
Only in /home/perera/Develop/ACESIII/sip: compute_uintegrals8.o
diff junk/contract_blocks.F /home/perera/Develop/ACESIII/sip/contract_blocks.F
53c53
<       integer*8 iy, ix1, ix2, daddr, ii 
---
>       integer*8 iy, ix1, ix2, daddr
80,82c80
<      *        nx2a(mx_array_index), nx2b(mx_array_index),
<      *        nyg(mx_array_index), nx1g(mx_array_index),
<      *        nx2g(mx_array_index)
---
>      *        nx2a(mx_array_index), nx2b(mx_array_index)
105,106c103,110
<          if(gpu_enabled) then
<            call cwork_gpu_alloc()
---
> 
>          istat = allocate_scratch_block(scr, iscr1, handle1,
>      *                           array_table, narray_table,
>      *                           index_table, nindex_table, 
>      *                           block_map_table)
>          if (istat .ne. 0) then
>             print *,'Error: Unable to allocate scratch blocks.'
>             call abort_job()
108,133c112,119
<            istat = allocate_scratch_block(scr, iscr1, handle1,
<      *                             array_table, narray_table,
<      *                             index_table, nindex_table, 
<      *                             block_map_table)
<            if (istat .ne. 0) then
<               print *,'Error: Unable to allocate scratch blocks.'
<               call abort_job()
<            endif
< 
<            istat = allocate_scratch_block(scr, iscr2, handle2,
<      *                             array_table, narray_table,
<      *                             index_table, nindex_table,
<      *                             block_map_table)
<            if (istat .ne. 0) then
<               print *,'Error: Unable to allocate scratch blocks.'
<               call abort_job()
<            endif
< 
<            istat = allocate_scratch_block(scr, iscr3, handle3,
<      *                             array_table, narray_table,
<      *                             index_table, nindex_table,
<      *                             block_map_table)
<            if (istat .ne. 0) then
<               print *,'Error: Unable to allocate scratch blocks.'
<               call abort_job()
<            endif
---
> 
>          istat = allocate_scratch_block(scr, iscr2, handle2,
>      *                           array_table, narray_table,
>      *                           index_table, nindex_table,
>      *                           block_map_table)
>          if (istat .ne. 0) then
>             print *,'Error: Unable to allocate scratch blocks.'
>             call abort_job()
135a122,131
>          istat = allocate_scratch_block(scr, iscr3, handle3,
>      *                           array_table, narray_table,
>      *                           index_table, nindex_table,
>      *                           block_map_table)
>          if (istat .ne. 0) then
>             print *,'Error: Unable to allocate scratch blocks.'
>             call abort_job()
>          endif
>       endif
> 
320,332d315
< 
<       if((gpu_enabled) .and. (ytype .ne. scalar_value) .and.
<      *    (ytype .ne. static_array) .and.
<      *    (x1_type .ne. static_array) .and.
<      *    (x2_type .ne. static_array)) then
<               
<  
<         call cwork_gpu(y(iy), ny, nya(1), nyb(1), indy(1),
<      *            x1(ix1), n1, nx1a(1), nx1b(1), indx1(1),
<      *            x2(ix2), n2, nx2a(1), nx2b(1), indx2(1))
<       
<       else
< 
338c321
<       
---
> 
350d332
< c            print *,'cwork2422'
381d362
< c            print *,'cwork2422'
387d367
< c            print *,'cwork2221'
414d393
< c            print *,'cwork2443'
429d407
< c            print *,'cwork2644'
455c433
< c            print *,'cwork1322'
---
> 
470d447
< c            print *,'cwork3321'
487d463
< c           print *,'cwork4331'
503d478
< c           print *,'cwork4643'
528d502
< c            print *,'cwork4622'
561c535
< c             print *,'cwork4421'
---
> 
580c554
< c            print *,'cwork4421'
---
> 
604d577
< c            print *,'cwork4442'
855,856d827
<       endif
< 
Only in /home/perera/Develop/ACESIII/sip: contract_blocks.o
Only in /home/perera/Develop/ACESIII/sip: copy_ab.o
Only in /home/perera/Develop/ACESIII/sip: copy_ba.o
diff junk/copy_ff.F /home/perera/Develop/ACESIII/sip/copy_ff.F
15,18c15,20
<       subroutine copy_ff(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine copy_ff(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
25c27
< c   execute copy_ff Array1 Array2
---
> c   execute copy_ab Array1 Array2
35a38,72
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, na, nb  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer inda(mx_array_index)
>       integer indb(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
37,42c74,76
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
44,47c78,132
<       if (nindex .eq. 2) call copy2ff(x,x2,nindex,
<      *                              bdim(1),edim(2),bdim(1),edim(2))
<       return
<       end
---
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_diagonal routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in remove_diagonal routine 
>      *            must be static.'
>          call abort_job()
>       endif
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in remove_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          na = array_table(c_index_original+i-1,array)
>          nb = array_table(c_index_original+i-1,evec_array)
> 
>          inda(i) = index_table(c_index_size, na)  ! pick up length of index
>          indb(i) = index_table(c_index_size, nb)  ! pick up length of index
>  
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
> c     na = index_table(c_index_size, ind(1))  ! pick up length of index
> c     nb = index_table(c_index_size, ind(1))  ! pick up length of index
> 
>       if (nindex .eq. 2) call copy2ff(x(iarray),x(ievec),nindex,
>      *                              inda(1),inda(2),indb(1),indb(2)) 
> 
>       return 
>       end 
Only in /home/perera/Develop/ACESIII/sip: copy_ff.o
diff junk/copy_fock.F /home/perera/Develop/ACESIII/sip/copy_fock.F
15,18c15,20
<       subroutine copy_fock(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine copy_fock(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
30a33
>       include 'trace.h'
31a35,83
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ifock, get_index_from_base
>       integer i, j, n
>       integer array, fock_array
>       integer nindex
>       integer ind(mx_array_index)
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
>       array = op(c_result_array)
>       fock_array = op(c_op1_array)
>       if (array .eq. 0 .or. fock_array .eq. 0) then
>          print *,'Error: COPY_FOCK routine requires 2 array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       if (fock_array .ne. 9 .and. 
>      *    fock_array .ne. 10) then
>          print *,'Error: COPY_FOCK requires a Fock array as arg. 2'
>          call abort_job()
>       endif
33,38c85
<       double precision x(*) 
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
>       nindex = array_table(c_nindex, array)
40,42c87,99
<       integer i, n
<  
<       n = edim(1) - bdim(1) + 1 
---
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,fock_array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ifock  = get_index_from_base(address_table(fock_array), x, 2)
> 
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
>       
44c101
<          x2(i) = x(i)
---
>          x(ifock+i-1) = x(iarray+i-1)
51,52c108,109
<       if (type(1) .eq. moaindex) then
<          call copy_diag(x2, n, epsilon)
---
>       if (index_table(c_index_type,ind(1)) .eq. moaindex) then
>          call copy_diag(x(ifock), n, epsilon)
54c111
<          call copy_diag(x2, n, epsilonb)
---
>          call copy_diag(x(ifock), n, epsilonb)
Only in /home/perera/Develop/ACESIII/sip: copy_fock.o
Only in /home/perera/Develop/ACESIII/sip: corder.o
Only in /home/perera/Develop/ACESIII/sip: crash.o
Only in /home/perera/Develop/ACESIII/sip: create_current_block.o
Only in /home/perera/Develop/ACESIII/sip: cstype.h
Only in /home/perera/Develop/ACESIII/sip: CVS
Only in /home/perera/Develop/ACESIII/sip: cwork0111.o
Only in /home/perera/Develop/ACESIII/sip: cwork0222.o
Only in /home/perera/Develop/ACESIII/sip: cwork0333.o
Only in /home/perera/Develop/ACESIII/sip: cwork0444.o
Only in /home/perera/Develop/ACESIII/sip: cwork0666.o
Only in /home/perera/Develop/ACESIII/sip: cwork1322.o
Only in /home/perera/Develop/ACESIII/sip: cwork2221.o
Only in /home/perera/Develop/ACESIII/sip: cwork2422.o
Only in /home/perera/Develop/ACESIII/sip: cwork2443.o
Only in /home/perera/Develop/ACESIII/sip: cwork2644.o
Only in /home/perera/Develop/ACESIII/sip: cwork2644_unopt.o
Only in /home/perera/Develop/ACESIII/sip: cwork3321.o
Only in /home/perera/Develop/ACESIII/sip: cwork4331.o
Only in /home/perera/Develop/ACESIII/sip: cwork4421.o
Only in /home/perera/Develop/ACESIII/sip: cwork4442.o
Only in /home/perera/Develop/ACESIII/sip: cwork4442_unopt.o
Only in /home/perera/Develop/ACESIII/sip: cwork4622.o
Only in /home/perera/Develop/ACESIII/sip: cwork4622_unopt.o
Only in /home/perera/Develop/ACESIII/sip: cwork4643.o
Only in /home/perera/Develop/ACESIII/sip: cwork4643_unopt.o
Only in /home/perera/Develop/ACESIII/sip: cwork6441.o
Only in /home/perera/Develop/ACESIII/sip: cwork6441_unopt.o
Only in /home/perera/Develop/ACESIII/sip: cwork6621.o
Only in /home/perera/Develop/ACESIII/sip: cwork6621_unopt.o
Only in /home/perera/Develop/ACESIII/sip: cwork6642.o
Only in /home/perera/Develop/ACESIII/sip: cwork6642_unopt.o
Only in junk/: cworkGPU.cu
Only in /home/perera/Develop/ACESIII/sip: dcont2.o
Only in /home/perera/Develop/ACESIII/sip: deallocate_instruction.o
Only in /home/perera/Develop/ACESIII/sip: dens2jobarc.F
Only in /home/perera/Develop/ACESIII/sip: dens2jobarc.o
diff junk/der2_comp.F /home/perera/Develop/ACESIII/sip/der2_comp.F
15,16c15,20
<       subroutine der2_comp(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine der2_comp(array_table,
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
18a23
>       include 'mpif.h'
21a27
>       include 'parallel_info.h'
26,28c32,56
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table, array 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table), get_index_from_base
>       integer*8 get_block_data_index
>       integer find_current_block, block 
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer ind, seg, val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
30c58,59
<       double precision dbuf(1)
---
>       double precision x(1)
>       double precision dbuf(1), temp 
33a63
>       pointer (xptr, x)
36c66
<       common dbuf
---
>       common dbuf, x
40,42c70,71
<       integer nsend
<       integer maxblk
<       integer*8 integral_scr
---
>       array = op(c_result_array)
>       direct_flag = .false. 
46a76
>       xptr = dshptr
49,51c79,108
<       if (nindex .ne. 4) then
<          print *,'Error: der2_comp was called with array ',
<      *        'which has ',nindex,' indices.'
---
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the 
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(array,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(array, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(array, blk, blkndx, op)
>          call set_block_computed_flag(array, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,array)
>       indblk = get_block_index(array, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Get the segment ranges for each index of the integral array.
> c--------------------------------------------------------------------------
> 
>       nind = array_table(c_nindex,array)
>       if (nind .ne. 4) then
>          print *,'Error: local_integral_block was called with array ',
>      *        array,' which has ',nind,' indices.'
55a113,133
>       do i = 1, nind
>          ind = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,ind)
>          call get_index_segment(ind, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>       block = find_current_block(array, array_table(1,array),
>      *                          index_table, nindex_table,
>      *                          segment_table, nsegment_table,
>      *                          block_map_table, blkndx)
> 
>       stack = array_table(c_array_stack, array)
>       indblk = get_block_data_index(array, block, stack,
>      *                              blkndx, x)
> 
70,71c148,149
<      *   call compute_der_batch(bval(1),eval(1), bval(2),eval(2),
<      *                       bval(3),eval(3),bval(4),eval(4),
---
>      *   call compute_der_batch(val1(1),val2(1), val1(2),val2(2),
>      *                       val1(3),val2(3),val1(4),val2(4),
75c153
<      *                 x, nsend)
---
>      *                 x(indblk), nsend)
Only in /home/perera/Develop/ACESIII/sip: der2_comp.o
diff junk/der4_comp.F /home/perera/Develop/ACESIII/sip/der4_comp.F
15,16c15,20
<       subroutine der4_comp(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine der4_comp(array_table,
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
18a23
>       include 'mpif.h'
21a27
>       include 'parallel_info.h'
26,29c32,51
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
< 
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table, array 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table), get_index_from_base
>       integer*8 get_block_data_index
>       integer find_current_block, block 
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
31c53,56
<       integer maxblk, nsend
---
>       integer ind, seg, val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
33c58,59
<       double precision dbuf(1)
---
>       double precision x(1)
>       double precision dbuf(1), temp 
37c63
<       inter (xptr, x)
---
>       pointer (xptr, x)
40c66
<       common dbuf
---
>       common dbuf, x
43a70,72
>       array = op(c_result_array)
>       direct_flag = .false. 
> 
46a76
>       xptr = dshptr
49,51c79,108
<       if (nindex .ne. 4) then
<          print *,'Error: der4_comp was called with an array ',
<      *        ' which has ',nindex,' indices.'
---
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the 
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(array,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(array, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(array, blk, blkndx, op)
>          call set_block_computed_flag(array, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,array)
>       indblk = get_block_index(array, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Get the segment ranges for each index of the integral array.
> c--------------------------------------------------------------------------
> 
>       nind = array_table(c_nindex,array)
>       if (nind .ne. 4) then
>          print *,'Error: local_integral_block was called with array ',
>      *        array,' which has ',nind,' indices.'
55a113,133
>       do i = 1, nind
>          ind = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,ind)
>          call get_index_segment(ind, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>       block = find_current_block(array, array_table(1,array),
>      *                          index_table, nindex_table,
>      *                          segment_table, nsegment_table,
>      *                          block_map_table, blkndx)
> 
>       stack = array_table(c_array_stack, array)
>       indblk = get_block_data_index(array, block, stack,
>      *                              blkndx, x)
> 
70,71c148,149
<      *   call compute_der2_batch(bval(1),eval(1), bval(2),eval(2),
<      *                       bval(3),eval(3),bval(4),eval(4),
---
>      *   call compute_der2_batch(val1(1),val2(1), val1(2),val2(2),
>      *                       val1(3),val2(3),val1(4),val2(4),
75c153
<      *                 x, nsend)
---
>      *                 x(indblk), nsend)
Only in /home/perera/Develop/ACESIII/sip: der4_comp.o
Only in /home/perera/Develop/ACESIII/sip: der_int_setup.o
Only in /home/perera/Develop/ACESIII/sip: descramble_matrix.o
Only in /home/perera/Develop/ACESIII/sip: destroy_instruction.o
Only in /home/perera/Develop/ACESIII/sip: determine_array_indices.o
Only in /home/perera/Develop/ACESIII/sip: determine_current_block_size.o
Only in /home/perera/Develop/ACESIII/sip: determine_timeslice.o
Only in /home/perera/Develop/ACESIII/sip: Develop
Only in /home/perera/Develop/ACESIII/sip: diag.o
Only in /home/perera/Develop/ACESIII/sip: diis_setup.o
Only in /home/perera/Develop/ACESIII/sip: dipole_moment.o
Only in /home/perera/Develop/ACESIII/sip: doloop.o
Only in /home/perera/Develop/ACESIII/sip: dropmo_expand_basis.o
Only in /home/perera/Develop/ACESIII/sip: dump_amp.o
Only in /home/perera/Develop/ACESIII/sip: dump_block.o
Only in /home/perera/Develop/ACESIII/sip: ecp_cont.F
Only in /home/perera/Develop/ACESIII/sip: ecp_cont.o
diff junk/eigen_calc.F /home/perera/Develop/ACESIII/sip/eigen_calc.F
15,18c15,20
<       subroutine eigen_calc(x, nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine eigen_calc(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
35a38
>       include 'parallel_info.h'
36a40,80
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       evec_array = op(c_op1_array)
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: EIG routine requires 2 array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
38,51c82,87
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer n, ierr, junk
< 
<       ierr = 0
<       if (nindex .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig, line ',current_line,' Number of array',
<      *           ' indices must be 2, actual number is ',nindex
---
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in EIG routine must be static.'
>          call abort_job()
54,57c90,101
<       if (nindex2 .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig, line ',current_line,' Number of array',
<      *           ' indices must be 2, actual number is ',nindex2
---
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
>       nindex = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in EIG must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
60c104,113
<       if (ierr .ne. 0) call abort_job()
---
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
62,63c115,116
<       n = edim(1) - bdim(1) + 1
<       call diag(x, x2, junk, n, 0, 0, 0)
---
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
>       call diag(x(iarray), x(ievec), junk, n, 0, 0, 0)
Only in /home/perera/Develop/ACESIII/sip: eigen_calc.o
diff junk/eigen_nonsymm_calc.F /home/perera/Develop/ACESIII/sip/eigen_nonsymm_calc.F
15,18c15,20
<       subroutine eigen_nonsymm_calc(x, nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine eigen_nonsymm_calc(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
37a40,42
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
39,44c44,71
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       common /epsilon/epsilon(1000), epsilonb(1000)
>       double precision epsilon, epsilonb
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
46c73,75
<       integer n
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
48,49c77,100
<       if (nindex .ne. nindex2) then
<          print *,'Error: Both arrays in EIG_NONSYMM must use ',
---
>       array = op(c_result_array)
>       evec_array = op(c_op1_array)
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: EIG routine requires 2 array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in EIG routine must be static.'
>          call abort_job()
>       endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
>       nindex = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in EIG must use ',
52c103
<          print *,'Second array has ',nindex2,' indices.'
---
>          print *,'Second array has ',nindex_evec,' indices.'
56c107,118
<       n = eval(1) - bval(1) + 1
---
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
61c123
<       call diag_nonsymm(x, x2, n)
---
>       call diag_nonsymm(x(iarray), x(ievec), n)
Only in /home/perera/Develop/ACESIII/sip: eigen_nonsymm_calc.o
diff junk/eig_inv.F /home/perera/Develop/ACESIII/sip/eig_inv.F
15,18c15,20
<       subroutine eig_inv(x, nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine eig_inv(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
36a39,79
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       evec_array = op(c_op1_array)
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: EIG routine requires 2 array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
38,52c81,90
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer n, ierr, junk
< 
<       ierr = 0
<       if (nindex .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig_inv, line ',current_line,
<      *           ' Number of array',
<      *           ' indices must be 2, actual number is ',nindex
---
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in EIG routine must be static.'
>          call abort_job()
55,59c93,100
<       if (nindex2 .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig_inv, line ',current_line,
<      *           ' Number of array',
<      *           ' indices must be 2, actual number is ',nindex2
---
>       nindex = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in EIG must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
62c103,109
<       if (ierr .ne. 0) call abort_job()
---
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
64c111,112
<       n = edim(1) - bdim(1) + 1
---
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
66c114,115
<       call diag(x, x2, junk, n, 0, 0, 1)
---
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
>       call diag(x(iarray), x(ievec), junk, n, 0, 0, 1)
Only in /home/perera/Develop/ACESIII/sip: eig_inv.o
diff junk/eig_sr.F /home/perera/Develop/ACESIII/sip/eig_sr.F
15,18c15,20
<       subroutine eig_sr(x, nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine eig_sr(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
21c23,24
< c   The matrix is also diagonalized on output and inverted. 
---
> c   The matrix is also diagonalized on output and the square root applied 
> c   to each sample.
36a40,80
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       evec_array = op(c_op1_array)
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: EIG routine requires 2 array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
38,52c82,91
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer n, ierr, junk
< 
<       ierr = 0
<       if (nindex .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig_sr, line ',current_line,
<      *           ' Number of array',
<      *           ' indices must be 2, actual number is ',nindex
---
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in EIG routine must be static.'
>          call abort_job()
55,59c94,101
<       if (nindex2 .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig_sr, line ',current_line,
<      *           ' Number of array',
<      *           ' indices must be 2, actual number is ',nindex2
---
>       nindex = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in EIG must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
62c104,110
<       if (ierr .ne. 0) call abort_job()
---
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
64c112,113
<       n = edim(1) - bdim(1) + 1
---
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
66c115,116
<       call diag(x, x2, junk, n, 0, 1, 0)
---
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
>       call diag(x(iarray), x(ievec), junk, n, 0, 1, 0)
diff junk/eig_sr_inv.F /home/perera/Develop/ACESIII/sip/eig_sr_inv.F
15,18c15,20
<       subroutine eig_sr_inv(x, nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine eig_sr_inv(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
21c23,24
< c   The matrix is also diagonalized on output and inverted. 
---
> c   The matrix is also diagonalized on output. The square root and inverse
> c   operators are also applied.
36a40,85
>       include 'epsilon.h'
>       include 'parallel_info.h' 
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
>       array = op(c_result_array)
>       evec_array = op(c_op1_array)
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: EIG routine requires 2 array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
38,52c87,92
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer n, ierr, junk
< 
<       ierr = 0
<       if (nindex .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig_sr_inv, line ',current_line,
<      *           ' Number of array',
<      *           ' indices must be 2, actual number is ',nindex
---
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in EIG routine must be static.'
>          call abort_job()
55,59c95,102
<       if (nindex2 .ne. 2) then
<          ierr = ierr + 1
<          print *,'Error in eig_sr_inv, line ',current_line,
<      *           ' Number of array',
<      *           ' indices must be 2, actual number is ',nindex2
---
>       nindex = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in EIG must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
62c105,111
<       if (ierr .ne. 0) call abort_job()
---
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
64c113,114
<       n = edim(1) - bdim(1) + 1
---
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
66c116,117
<       call diag(x, x2, junk, n, 1, 1, 1)
---
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
>       call diag(x(iarray), x(ievec), junk, n, 1, 1, 1)
Only in /home/perera/Develop/ACESIII/sip: eig_sr_inv.o
Only in /home/perera/Develop/ACESIII/sip: eig_sr.o
Only in /home/perera/Develop/ACESIII/sip: elmhes.F
Only in /home/perera/Develop/ACESIII/sip: elmhes.o
Only in /home/perera/Develop/ACESIII/sip: eltran.F
Only in /home/perera/Develop/ACESIII/sip: eltran.o
diff junk/energy_abdenominator.F /home/perera/Develop/ACESIII/sip/energy_abdenominator.F
15,16c15,20
<       subroutine energy_abdenominator(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_abdenominator(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23a28,29
>       include 'trace.h'
>       include 'mpif.h'
24a31,58
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
26,28c60,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
31,34c111,126
<          call epsab_divide2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),
<      *                    bdim(2), edim(2),
---
> 
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call epsab_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
39c131
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_abdenominator.o
diff junk/energy_adenominator.F /home/perera/Develop/ACESIII/sip/energy_adenominator.F
15,16c15,20
<       subroutine energy_adenominator(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_adenominator(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23a28,29
>       include 'trace.h'
>       include 'mpif.h'
24a31,58
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
26,28c60,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
31,34c111,126
<          call epsa_divide2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),
<      *                    bdim(2), edim(2),
---
> 
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call epsa_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
39c131
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_adenominator.o
diff junk/energy_bdenominator.F /home/perera/Develop/ACESIII/sip/energy_bdenominator.F
15,16c15,20
<       subroutine energy_bdenominator(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_bdenominator(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23a28,29
>       include 'trace.h'
>       include 'mpif.h'
24a31,58
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
26,28c60,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
31,34c111,126
<          call epsb_divide2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),
<      *                    bdim(2), edim(2),
---
> 
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call epsb_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
39c131
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_bdenominator.o
diff junk/energy_denominator.F /home/perera/Develop/ACESIII/sip/energy_denominator.F
15,16c15,20
<       subroutine energy_denominator(x, nindex, type, bval, 
<      *                              eval, bdim, edim)
---
>       subroutine energy_denominator(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24a29,30
>       include 'trace.h'
>       include 'mpif.h'
25a32,59
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
27,29c61,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
32,35c111,114
<          call eps_divide4(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4), 
---
>          call eps_divide4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4), 
38,43c117,122
<          call eps_divide6(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
<      *                   bval(5),eval(5),type(5),
<      *                   bval(6),eval(6),type(6),
---
>          call eps_divide6(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
>      *                   val1(5),val2(5),type(5),
>      *                   val1(6),val2(6),type(6),
46,48c125,139
<          call eps_divide2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),bdim(2),edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif 
> 
>          call eps_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
52,53c143,144
<      *      'must have either 6, 4 or 2 indices.'
<          print *,'array has ',nindex,' indices.'
---
>      *      'must have either 4 or 2 indices.'
>          print *,'array ',array,' has ',nindex,' indices.'
222,224c313,315
<             if (a .ne. i) write(6,*) ' Small denominator being ',
<      *         'eliminated in energy_denominator',
<      *         ' a, i', a,i, 'den' ,eps, 'value', x(a,i)
---
>             if (a .ne. i) write(6,*) ' Small denominator being
>      *         eliminated in energy_denominator',
>      *         'a, i', a,i, 'den' ,eps, 'value', x(a,i)
Only in /home/perera/Develop/ACESIII/sip: energy_denominator.o
diff junk/energy_denominator_reg_deriv.F /home/perera/Develop/ACESIII/sip/energy_denominator_reg_deriv.F
15,16c15,20
<       subroutine energy_denominator_reg_deriv(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_denominator_reg_deriv(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
24a29,30
>       include 'trace.h'
>       include 'mpif.h'
26a33,53
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
28,30c55,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif
33,36c111,114
<          call eps_divide4_reg_deriv(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
---
>          call eps_divide4_reg_deriv(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
39,44c117,122
<          call eps_divide6_reg_deriv(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
<      *                   bval(5),eval(5),type(5),
<      *                   bval(6),eval(6),type(6),
---
>          call eps_divide6_reg_deriv(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
>      *                   val1(5),val2(5),type(5),
>      *                   val1(6),val2(6),type(6),
47,49c125,139
<          call eps_divide2_reg_deriv(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),bdim(2), edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call eps_divide2_reg_deriv(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
52c142
<          print *,'Error in energy_denominator_reg_deriv Result array ',
---
>          print *,'Error in energy_denominator: Result array ',
54c144
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_denominator_reg_deriv.o
diff junk/energy_product.F /home/perera/Develop/ACESIII/sip/energy_product.F
15,16c15,20
<       subroutine energy_product(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_product(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
24a29,30
>       include 'trace.h'
>       include 'mpif.h'
25a32,52
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
27,29c54,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif
32,35c111,114
<          call eps_prod4(x, bval(1),eval(1),type(1),
<      *                    bval(2),eval(2),type(2),
<      *                    bval(3),eval(3),type(3),
<      *                    bval(4),eval(4),type(4),
---
>          call eps_prod4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
38,43c117,122
<          call eps_prod6(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
<      *                   bval(5),eval(5),type(5),
<      *                   bval(6),eval(6),type(6),
---
>          call eps_prod6(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
>      *                   val1(5),val2(5),type(5),
>      *                   val1(6),val2(6),type(6),
46,48c125,139
<          call eps_prod2(x, bval(1),eval(1),type(1),
<      *                     bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),bdim(2),edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call eps_prod2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
51c142
<          print *,'Error in energy_product: Result array ',
---
>          print *,'Error in energy_denominator: Result array ',
53c144
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_product.o
diff junk/energy_reg_denominator.F /home/perera/Develop/ACESIII/sip/energy_reg_denominator.F
15,16c15,20
<       subroutine energy_reg_denominator(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_reg_denominator(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
24a29,30
>       include 'trace.h'
>       include 'mpif.h'
26a33,53
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
28,30c55,108
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif
33,36c111,114
<          call eps_reg_divide4(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
---
>          call eps_reg_divide4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
39,44c117,122
<          call eps_reg_divide6(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
<      *                   bval(5),eval(5),type(5),
<      *                   bval(6),eval(6),type(6),
---
>          call eps_reg_divide6(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
>      *                   val1(5),val2(5),type(5),
>      *                   val1(6),val2(6),type(6),
47,49c125,139
<          call eps_reg_divide2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),bdim(2),edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call eps_reg_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
52c142
<          print *,'Error in energy_reg_denominator: Result array ',
---
>          print *,'Error in energy_denominator: Result array ',
54c144
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_reg_denominator.o
diff junk/energy_reg_product.F /home/perera/Develop/ACESIII/sip/energy_reg_product.F
15,16c15,20
<       subroutine energy_reg_product(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine energy_reg_product(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
24a29,30
>       include 'trace.h'
>       include 'mpif.h'
26a33,53
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
28,30c55,109
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif
33,36c112,115
<          call eps_reg_prod4(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
---
>          call eps_reg_prod4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
39,44c118,123
<          call eps_reg_prod6(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4),
<      *                   bval(5),eval(5),type(5),
<      *                   bval(6),eval(6),type(6),
---
>          call eps_reg_prod6(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4),
>      *                   val1(5),val2(5),type(5),
>      *                   val1(6),val2(6),type(6),
47,49c126,140
<          call eps_reg_prod2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),bdim(2),edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif
> 
>          call eps_reg_prod2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
52c143
<          print *,'Error in energy_reg_product: Result array ',
---
>          print *,'Error in energy_denominator: Result array ',
54c145
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: energy_reg_product.o
Only in /home/perera/Develop/ACESIII/sip: energy_tdenominator.o
diff junk/energy_ty_denominator.F /home/perera/Develop/ACESIII/sip/energy_ty_denominator.F
45c45,46
<       double precision sind, shift  
---
>       double precision shift  
>       integer sind 
Only in /home/perera/Develop/ACESIII/sip: energy_ty_denominator.o
Only in /home/perera/Develop/ACESIII/sip: eomroot_print_new.F.skip
Only in /home/perera/Develop/ACESIII/sip: eomroot_print_new.o
Only in /home/perera/Develop/ACESIII/sip: eomroot_print.o
Only in /home/perera/Develop/ACESIII/sip: fassign.o
Only in /home/perera/Develop/ACESIII/sip: fetch_block.o
Only in /home/perera/Develop/ACESIII/sip: find_block_destination.o
Only in /home/perera/Develop/ACESIII/sip: find_current_block_map.o
Only in /home/perera/Develop/ACESIII/sip: find_free_msg_buffer.o
Only in /home/perera/Develop/ACESIII/sip: find_matching_indices.o
Only in /home/perera/Develop/ACESIII/sip: find_non_matching_indices.o
Only in /home/perera/Develop/ACESIII/sip: fmult.o
diff junk/fock_denominator.F /home/perera/Develop/ACESIII/sip/fock_denominator.F
15,16c15,20
<       subroutine fock_denominator(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine fock_denominator(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23a28
>       include 'interpreter.h'
24a30
>       include 'mpif.h'
25a32,59
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
27,29c61,66
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
32a70,111
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
> 
34,37c113,116
<          call fock_divide4(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4), 
---
>          call fock_divide4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4), 
40,42c119,133
<          call fock_divide2(x, bval(1),eval(1),type(1),
<      *                    bdim(1), edim(1),
<      *                    bval(2),eval(2),type(2),bdim(2),edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif 
> 
>          call fock_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                    na1, na2,
>      *                    val1(2),val2(2),type(2),ni1,ni2,
45c136
<          print *,'Error in fock_denominator: Result array ',
---
>          print *,'Error in energy_denominator: Result array ',
47c138
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: fock_denominator.o
diff junk/fock_der.F /home/perera/Develop/ACESIII/sip/fock_der.F
15,16c15,20
<       subroutine fock_der(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine fock_der(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24a29,32
>       include 'mpif.h'
>       include 'interpreter.h'
>       include 'trace.h'
>       include 'parallel_info.h'
25a34,37
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
27,29c39,47
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
31c49,159
<       integer nsend
---
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
> 
>       integer*8 address_table(narray_table)
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer*8 get_block_data_index
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack, intermediate 
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer find_current_block
>       integer block
>       integer igrad, component 
> 
>       double precision dummy, y
>       integer flopcount
>       integer*8 arg64(10)
>       logical*8 l8false
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Overlap_der requires a 2-index argument 
>      *               array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
> 
> c---------------------------------------------------------------------------
> c   Compute data block of integrals.
> c---------------------------------------------------------------------------
34,35c162
<          call comp_fock_der(x, bval(1), eval(1), bval(2), 
<      *                      eval(2), nsend) 
---
>          call comp_fock_der(x(indblk), a1, a2, b1, b2, nsend) 
Only in /home/perera/Develop/ACESIII/sip: fock_der.o
Only in /home/perera/Develop/ACESIII/sip: form_fnob.o
Only in /home/perera/Develop/ACESIII/sip: form_fno.o
Only in /home/perera/Develop/ACESIII/sip: form_fock_rohf.o
diff junk/form_iad.F /home/perera/Develop/ACESIII/sip/form_iad.F
15,18c15,20
<       subroutine form_iad(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine form_iad(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24c26,61
<       include 'epsilon.h'
---
>       include 'trace.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, na, nb  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer inda(mx_array_index)
>       integer indb(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
26,39c63,118
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer na1, na2, nb1, nb2
< 
<       na1 = edim(1)-bdim(1) + 1
<       na2 = edim(2)-bdim(2) + 1
<       nb1 = edim2(1)-bdim2(1) + 1
<       nb2 = edim2(2)-bdim2(2) + 1
<       call do_formiad(x,x2,nindex,na1,na2,nb1,nb2)
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_diagonal routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in remove_diagonal routine 
>      *            must be static.'
>          call abort_job()
>       endif
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in remove_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          na = array_table(c_index_array1+i-1,array)
>          nb = array_table(c_index_array1+i-1,evec_array)
> 
>          inda(i) = index_table(c_index_size, na)  ! pick up length of index
>          indb(i) = index_table(c_index_size, nb)  ! pick up length of index
>  
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
> c     na = index_table(c_index_size, ind(1))  ! pick up length of index
> c     nb = index_table(c_index_size, ind(1))  ! pick up length of index
> 
>       call do_formiad(x(iarray),x(ievec),nindex,
>      *                              inda(1),inda(2),indb(1),indb(2)) 
Only in /home/perera/Develop/ACESIII/sip: form_iad.o
diff junk/form_ibd.F /home/perera/Develop/ACESIII/sip/form_ibd.F
15,18c15,20
<       subroutine form_ibd(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine form_ibd(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24c26,61
<       include 'epsilon.h'
---
>       include 'trace.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, na, nb  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer inda(mx_array_index)
>       integer indb(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
26,39c63,118
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer na1, na2, nb1, nb2
< 
<       na1 = edim(1)-bdim(1) + 1
<       na2 = edim(2)-bdim(2) + 1
<       nb1 = edim2(1)-bdim2(1) + 1
<       nb2 = edim2(2)-bdim2(2) + 1
<       call do_formibd(x,x2,nindex,na1,na2,nb1,nb2)
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_diagonal routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in remove_diagonal routine 
>      *            must be static.'
>          call abort_job()
>       endif
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in remove_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          na = array_table(c_index_array1+i-1,array)
>          nb = array_table(c_index_array1+i-1,evec_array)
> 
>          inda(i) = index_table(c_index_size, na)  ! pick up length of index
>          indb(i) = index_table(c_index_size, nb)  ! pick up length of index
>  
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
> c     na = index_table(c_index_size, ind(1))  ! pick up length of index
> c     nb = index_table(c_index_size, ind(1))  ! pick up length of index
> 
>       call do_formibd(x(iarray),x(ievec),nindex,
>      *                              inda(1),inda(2),indb(1),indb(2)) 
45c124
< 	implicit none
---
>       implicit none
Only in /home/perera/Develop/ACESIII/sip: form_ibd.o
Only in /home/perera/Develop/ACESIII/sip: form_R.o
Only in /home/perera/Develop/ACESIII/sip: generate_scratch_filename.o
Only in /home/perera/Develop/ACESIII/sip: get_actual_blocksize.o
Only in /home/perera/Develop/ACESIII/sip: get_barrier_master.o
Only in /home/perera/Develop/ACESIII/sip: get_block_map_entry.o
Only in /home/perera/Develop/ACESIII/sip: get_ijk.o
Only in /home/perera/Develop/ACESIII/sip: get_index_segment.o
Only in /home/perera/Develop/ACESIII/sip: get_loop_index.o
diff junk/get_my_rank.f /home/perera/Develop/ACESIII/sip/get_my_rank.f
15,16c15,20
<       subroutine get_my_rank(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine get_my_rank(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
18c22,23
< c   Returns the rank of the current processor in the scalar variable.
---
> c   Determines the processor rank and sets it in the scalar defined by the
> c   c_result_array field of the op argument.
27,29c32,41
<       double precision x
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
31c43,70
<       x = me   ! save the rank in the scalar table.
---
>       integer ierr, array, array_type, ind
>       integer i
> 
>       array = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       if (array_type .ne. scalar_value) then
>          print *,'Error in get_my_rank: Arg must be a scalar'
>          call abort_job()
>       endif
> 
>       if (array .lt. 1 .or. array .gt. narray_table) then
>          print *,'Error: Invalid array in get_my_rank, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif
> 
>       ind =  array_table(c_scalar_index, array)
>       if (ind .lt. 1 .or. ind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in print_scalar, ',
>      *           'line ',current_line
>          print *,'Index for array ',array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
>       endif
> 
>       scalar_table(ind) = me   ! save the rank in the scalar table.
Only in /home/perera/Develop/ACESIII/sip: get_my_rank.o
Only in /home/perera/Develop/ACESIII/sip: get_operation_desc.o
Only in /home/perera/Develop/ACESIII/sip: get_pardo_master.o
Only in /home/perera/Develop/ACESIII/sip: get_prefetch_flag.o
diff junk/get_restart_status.f /home/perera/Develop/ACESIII/sip/get_restart_status.f
15,19c15,23
<       subroutine get_restart_status(x, nindex, type, bval,
<      *                              eval, bdim, edim)
< c---------------------------------------------------------------------------
< c   Returns 1 or 0 in the scalar argument, depending on whether the current
< c   SIAL program has been restarted or not.  If the SIAL program has been
---
>       subroutine get_restart_status(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
> c----------------------------------------------------------------------------
> c   Returns 1 or 0 in the array argument, depending on whether the current
> c   SIAL program has been restarted or not.  If the SIAL program has been 
22c26,27
< c----------------------------------------------------------------------------
---
> c-----------------------------------------------------------------------------
>   
25a31,32
>       include 'parallel_info.h'
>       include 'dbugcom.h'
28,30c35,44
<       double precision x
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
31a46
>       integer array, array_type, ind
33a49,64
>       array = op(c_result_array)
>       if (array .eq. 0) then
>          print *,'Error: get_restart_status must be called with a ',
>      *           'scalar argument.'
>          call abort_job()
>       else
>          array_type = array_table(c_array_type, array)
>          if (array_type .ne. scalar_value) then 
>             print *,
>      *       'Error: checkpoint instruction requires a scalar ',
>      *       'as its argument.'
>             call abort_job()
>          endif
>       endif
> 
>       ind =  array_table(c_scalar_index, array)
38c69
<          val = 0.0
---
>          val = 0.0 
41c72
<       x = val
---
>       scalar_table(ind) = val
Only in /home/perera/Develop/ACESIII/sip: get_restart_status.o
Only in /home/perera/Develop/ACESIII/sip: get_sip_blocksize.o
Only in /home/perera/Develop/ACESIII/sip: get_where_conditionals.o
Only in /home/perera/Develop/ACESIII/sip: global_accumulate.o
Only in /home/perera/Develop/ACESIII/sip: handle_call.o
Only in /home/perera/Develop/ACESIII/sip: handle_cycle.o
Only in /home/perera/Develop/ACESIII/sip: handle_exit.o
Only in /home/perera/Develop/ACESIII/sip: handle_fsp_op.o
Only in /home/perera/Develop/ACESIII/sip: handle_goto.o
Only in /home/perera/Develop/ACESIII/sip: handle_return.o
Only in /home/perera/Develop/ACESIII/sip: handle_sp_op.o
Only in /home/perera/Develop/ACESIII/sip: handle_sss_op.o
Only in /home/perera/Develop/ACESIII/sip: hcont1.o
Only in /home/perera/Develop/ACESIII/sip: hcontxy.o
Only in /home/perera/Develop/ACESIII/sip: hqr2.o
Only in /home/perera/Develop/ACESIII/sip: hqr.F
Only in /home/perera/Develop/ACESIII/sip: hqr.o
Only in /home/perera/Develop/ACESIII/sip: libsip.a
Only in /home/perera/Develop/ACESIII/sip: list_to_blocks.o
Only in /home/perera/Develop/ACESIII/sip: load_balance_off.o
Only in /home/perera/Develop/ACESIII/sip: load_balance_on.o
diff junk/loadb.F /home/perera/Develop/ACESIII/sip/loadb.F
44d43
<       include 'timerz.h'
107,108d105
< c      call timer_start (timer_ovrhead)
<       call timer_start (pardo_tserver_timer)   
110d106
< 
116,117d111
< c      call update_timer (pardo_tserver_timer)
< c      call update_timer (timer_ovrhead)
119,120d112
< c      call timer_start (timer_ovrhead)
< c      call timer_start (pardo_tserver_timer)   
122d113
< 
128,129d118
<       call update_timer (pardo_tserver_timer)
< c      call update_timer (timer_ovrhead)
Only in /home/perera/Develop/ACESIII/sip: loadb.o
diff junk/load_pre_defined_routines.f /home/perera/Develop/ACESIII/sip/load_pre_defined_routines.f
112c112
<       external apply_den2, apply_den4, apply_den4_nodiag
---
>       external apply_den2, apply_den2_nor, apply_den4, apply_den4_nodiag
187d186
<       external temp_x
193a193,218
> c --------------------------------------------------------------------
> c VFL Instruction needed for DEA/DIP updated AUG. 14 2012
> c --------------------------------------------------------------------
> c
>       external write_scfdata
>       external set_np2
>       external sdrop
>       external asymm_force_i
>       external symm_force_ij
> c
> c -------------------------------------------------------------------- 
> c Watson Instruction needed to write the density out
> c -------------------------------------------------------------------- 
> c     
>       external dens2jobarc
>       external change_occ_dens,change_vrt_dens
>       external add_scal2diag,calc_trace,v_nuc_nuc,vccs_change_x
>       external write_coefficients,read_coefficients
>       external scf_atom_coeff
> c
> c -------------------------------------------------------------------- 
> c Watson Instruction needed to write the density out
> c -------------------------------------------------------------------- 
> c     
>       external asymm_force_a
> 
198,200d222
<       call set_upgrade_flag(dummy) 
<       dummy = load_user_sub('udenominator'//char(0), udenominator)
<       call set_upgrade_flag(dummy)
203d224
<       call set_upgrade_flag(dummy) 
206d226
<       call set_upgrade_flag(dummy) 
209d228
<       call set_upgrade_flag(dummy) 
212d230
<       call set_upgrade_flag(dummy) 
215d232
<       call set_upgrade_flag(dummy) 
242d258
<       call set_upgrade_flag(dummy) 
244d259
<       call set_upgrade_flag(dummy) 
246d260
<       call set_upgrade_flag(dummy) 
248d261
<       call set_upgrade_flag(dummy) 
250d262
<       call set_upgrade_flag(dummy) 
258d269
<       call set_upgrade_flag(dummy) 
260d270
<       call set_upgrade_flag(dummy) 
263d272
<       call set_upgrade_flag(dummy) 
267d275
<       call set_upgrade_flag(dummy) 
269d276
<       call set_upgrade_flag(dummy) 
271d277
<       call set_upgrade_flag(dummy) 
276d281
<       call set_upgrade_flag(dummy) 
278d282
<       call set_upgrade_flag(dummy) 
280d283
<       call set_upgrade_flag(dummy) 
287a291
> 
290d293
<       call set_upgrade_flag(dummy) 
293d295
<       call set_upgrade_flag(dummy) 
296c298,314
<       call set_upgrade_flag(dummy) 
---
>       dummy = load_user_sub('read_grad'//char(0), read_grad)
>       dummy = load_user_sub('udenominator'//char(0), udenominator)
>       dummy = load_user_sub('set_index'//char(0), set_index)
>       dummy = load_user_sub('remove_single'//char(0), remove_single)
>       dummy = load_user_sub('remove_double'//char(0), remove_double)
>       dummy = load_user_sub('remove_single_double'//char(0), 
>      *                       remove_single_double)
>       dummy = load_user_sub('remove_ssss'//char(0), remove_ssss)
>       dummy = load_user_sub('remove_dddd'//char(0), remove_dddd)
>       dummy = load_user_sub('remove_xsxs'//char(0), remove_xsxs)
>       dummy = load_user_sub('remove_xxss'//char(0), remove_xxss)
>       dummy = load_user_sub('remove_xdxs'//char(0), remove_xdxs)
>       dummy = load_user_sub('remove_xsxd'//char(0), remove_xsxd)
>       dummy = load_user_sub('remove_xxsd'//char(0), remove_xxsd)
>       dummy = load_user_sub('remove_xdxd'//char(0), remove_xdxd)
>       dummy = load_user_sub('remove_xxdd'//char(0), remove_xxdd)
>       dummy = load_user_sub('remove_xs'//char(0), remove_xs)
298d315
<       call set_upgrade_flag(dummy) 
300d316
<       call set_upgrade_flag(dummy) 
302d317
<       call set_upgrade_flag(dummy) 
304d318
<       call set_upgrade_flag(dummy) 
306d319
<       call set_upgrade_flag(dummy) 
308d320
<       call set_upgrade_flag(dummy) 
310d321
<       call set_upgrade_flag(dummy) 
312d322
<       call set_upgrade_flag(dummy) 
314,316c324,325
<       call set_upgrade_flag(dummy) 
< c     dummy = load_user_sub('copy_ab'//char(0), copy_ab)
< c     dummy = load_user_sub('copy_ba'//char(0), copy_ba)
---
>       dummy = load_user_sub('copy_ab'//char(0), copy_ab)
>       dummy = load_user_sub('copy_ba'//char(0), copy_ba)
318,319c327
<       call set_upgrade_flag(dummy) 
< c     dummy = load_user_sub('open_amp'//char(0), open_amp)
---
>       dummy = load_user_sub('open_amp'//char(0), open_amp)
323d330
<       call set_upgrade_flag(dummy) 
327d333
<       call set_upgrade_flag(dummy) 
329d334
<       call set_upgrade_flag(dummy) 
331d335
<       call set_upgrade_flag(dummy) 
334d337
<       call set_upgrade_flag(dummy) 
337d339
<       call set_upgrade_flag(dummy) 
340d341
<       call set_upgrade_flag(dummy) 
342d342
<       call set_upgrade_flag(dummy) 
344d343
<       call set_upgrade_flag(dummy) 
346d344
<       call set_upgrade_flag(dummy) 
348d345
<       call set_upgrade_flag(dummy) 
350d346
<       call set_upgrade_flag(dummy) 
352d347
<       call set_upgrade_flag(dummy) 
354d348
<       call set_upgrade_flag(dummy) 
356d349
<       call set_upgrade_flag(dummy) 
358d350
<       call set_upgrade_flag(dummy) 
360d351
<       call set_upgrade_flag(dummy) 
362d352
<       call set_upgrade_flag(dummy) 
364d353
<       call set_upgrade_flag(dummy) 
366d354
<       call set_upgrade_flag(dummy) 
369d356
<       call set_upgrade_flag(dummy) 
372d358
<       call set_upgrade_flag(dummy) 
375d360
<       call set_upgrade_flag(dummy) 
378d362
<       call set_upgrade_flag(dummy) 
381d364
<       call set_upgrade_flag(dummy) 
384d366
<       call set_upgrade_flag(dummy) 
387d368
<       call set_upgrade_flag(dummy) 
390d370
<       call set_upgrade_flag(dummy) 
393d372
<       call set_upgrade_flag(dummy) 
396d374
<       call set_upgrade_flag(dummy) 
399d376
<       call set_upgrade_flag(dummy) 
402d378
<       call set_upgrade_flag(dummy) 
405d380
<       call set_upgrade_flag(dummy) 
408d382
<       call set_upgrade_flag(dummy) 
411d384
<       call set_upgrade_flag(dummy) 
414d386
<       call set_upgrade_flag(dummy) 
416d387
<       call set_upgrade_flag(dummy) 
419,421c390,391
<       call set_upgrade_flag(dummy) 
< c     dummy = load_user_sub('smooth'//char(0), smooth)
< c     dummy = load_user_sub('smooth4'//char(0), smooth4)
---
>       dummy = load_user_sub('smooth'//char(0), smooth)
>       dummy = load_user_sub('smooth4'//char(0), smooth4)
424d393
<       call set_upgrade_flag(dummy) 
426c395
<       call set_upgrade_flag(dummy) 
---
>       dummy = load_user_sub('apply_den2_nor'//char(0), apply_den2_nor)
428d396
<       call set_upgrade_flag(dummy) 
431d398
<       call set_upgrade_flag(dummy) 
435,438c402,405
< c     dummy = load_user_sub('compute_aaaa_batch'//char(0),
< c    *                       compute_aaaa_batch)
< c     dummy = load_user_sub('compute_aaab_batch'//char(0),
< c    *                       compute_aaab_batch)
---
>       dummy = load_user_sub('compute_aaaa_batch'//char(0),
>      *                       compute_aaaa_batch)
>       dummy = load_user_sub('compute_aaab_batch'//char(0),
>      *                       compute_aaab_batch)
441,447c408,413
<       call set_upgrade_flag(dummy) 
< c     dummy = load_user_sub('compute_aabc_batch'//char(0),
< c    *                       compute_aabc_batch)
< c     dummy = load_user_sub('compute_abab_batch'//char(0),
< c    *                       compute_abab_batch)
< c     dummy = load_user_sub('compute_abac_batch'//char(0),
< c    *                       compute_abac_batch)
---
>       dummy = load_user_sub('compute_aabc_batch'//char(0),
>      *                       compute_aabc_batch)
>       dummy = load_user_sub('compute_abab_batch'//char(0),
>      *                       compute_abab_batch)
>       dummy = load_user_sub('compute_abac_batch'//char(0),
>      *                       compute_abac_batch)
450d415
<       call set_upgrade_flag(dummy) 
453d417
<       call set_upgrade_flag(dummy) 
456d419
<       call set_upgrade_flag(dummy) 
459d421
<       call set_upgrade_flag(dummy) 
461d422
<       call set_upgrade_flag(dummy) 
465d425
<       call set_upgrade_flag(dummy) 
467d426
<       call set_upgrade_flag(dummy) 
469d427
<       call set_upgrade_flag(dummy) 
471d428
<       call set_upgrade_flag(dummy) 
473d429
<       call set_upgrade_flag(dummy) 
481d436
<       call set_upgrade_flag(dummy) 
483d437
<       call set_upgrade_flag(dummy) 
487d440
<       call set_upgrade_flag(dummy) 
496d448
<       call set_upgrade_flag(dummy) 
498d449
<       call set_upgrade_flag(dummy) 
500d450
<       call set_upgrade_flag(dummy) 
502d451
<       call set_upgrade_flag(dummy) 
505d453
<       call set_upgrade_flag(dummy) 
507d454
<       call set_upgrade_flag(dummy) 
509d455
<       call set_upgrade_flag(dummy) 
511d456
<       call set_upgrade_flag(dummy) 
515d459
<       call set_upgrade_flag(dummy) 
518d461
<       call set_upgrade_flag(dummy) 
521d463
<       call set_upgrade_flag(dummy) 
523d464
<       call set_upgrade_flag(dummy) 
525d465
<       call set_upgrade_flag(dummy) 
528d467
<       call set_upgrade_flag(dummy) 
530d468
<       call set_upgrade_flag(dummy) 
532d469
<       call set_upgrade_flag(dummy) 
535d471
<       call set_upgrade_flag(dummy) 
537d472
<       call set_upgrade_flag(dummy) 
539d473
<       call set_upgrade_flag(dummy) 
543d476
<       call set_upgrade_flag(dummy) 
596d528
<       dummy = load_user_sub('temp_x'//char(0), temp_x)
602a535,564
> c --------------------------------------------------------------------
> c VFL Instruction needed for DEA/DIP updated AUG. 14 2012
> c --------------------------------------------------------------------
> c
>       dummy = load_user_sub('write_scfdata'//char(0), write_scfdata)
>       dummy = load_user_sub('set_np2'//char(0), set_np2)
>       dummy = load_user_sub('sdrop'//char(0), sdrop)
>       dummy = load_user_sub('asymm_force_i'//char(0), asymm_force_i)
>       dummy = load_user_sub('symm_force_ij'//char(0), symm_force_ij)
> c
> c --------------------------------------------------------------------
> c Watson instruction needed to write out density
> c -------------------------------------------------------------------- 
> c
>       dummy = load_user_sub('dens2jobarc'//char(0), dens2jobarc)
>       dummy = load_user_sub('change_occ_dens'//char(0), change_occ_dens)
>       dummy = load_user_sub('change_vrt_dens'//char(0), change_vrt_dens)
>       dummy = load_user_sub('add_scal2diag'//char(0), add_scal2diag)
>       dummy = load_user_sub('calc_trace'//char(0), calc_trace)
>       dummy = load_user_sub('v_nuc_nuc'//char(0), v_nuc_nuc)
> c      dummy = load_user_sub('vccs_change_x'//char(0), vccs_change_x)
>       dummy = load_user_sub('write_coefficients'//char(0),
>      +                       write_coefficients)
>       dummy = load_user_sub('read_coefficients'//char(0),
>      +                       read_coefficients)
>       dummy = load_user_sub('scf_atom_coeff'//char(0), scf_atom_coeff)
> 
> 
>       dummy = load_user_sub('asymm_force_a'//char(0), asymm_force_a)
> c
Only in /home/perera/Develop/ACESIII/sip: load_pre_defined_routines.o
Only in /home/perera/Develop/ACESIII/sip: local_integral_block.o
Only in /home/perera/Develop/ACESIII/sip: Makefile
Only in junk/: Makefile.in
Only in /home/perera/Develop/ACESIII/sip: maxamp_print.o
Only in /home/perera/Develop/ACESIII/sip: multiply_static_block.o
diff junk/norm_fac.F /home/perera/Develop/ACESIII/sip/norm_fac.F
15,18c15,21
<       subroutine norm_fac(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine norm_fac(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
21,22c24,27
< c The scalar2 is replaced by dsqrt(scalar1). 
< c scalar1 is replaced by 1.0/scalar1
---
> c The scalar1 is raised to the scalar2 power and replaced. 
> c
> c scalar1 = scalar1**scalar2 
> c   
28,37c33,118
< 
<       double precision x
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       x2 = dsqrt(x)
<       x  = 1.0d0/x2
---
>       include 'parallel_info.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, xind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array_type .ne. scalar_value) then
>          print *,'Error: The argument in square_root   
>      *            must be a scalar.'  
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       sind =  array_table(c_scalar_index, array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',array,' is ',sind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
>       endif
> 
> c----------------------------------------------------------------------------
> c   Locate the power.
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       xind =  array_table(c_scalar_index, evec_array)
>       if (xind .lt. 1 .or. xind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,'is',xind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
>       endif
>  
> c      scalar_table(sind) = scalar_table(sind)**scalar_table(xind)     
>       scalar_table(xind)= dsqrt( scalar_table(sind) )
>       scalar_table(sind)=(1.0d0/(dsqrt( scalar_table(sind) )))
Only in /home/perera/Develop/ACESIII/sip: norm_fac.o
Only in /home/perera/Develop/ACESIII/sip: nuc_dipole_derivative.o
diff junk/nuc_dipole_moment.F /home/perera/Develop/ACESIII/sip/nuc_dipole_moment.F
15,18c15,21
<       subroutine nuc_dipole_moment(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine nuc_dipole_moment(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20,22c23,27
< c   Usage: nuc_dipole_moment scalar1 scalar2
< c   scalar1 indicates x, y, or z moment to be computed.
< c   scalar2 is the result.
---
> c
> c The scalar1 is raised to the scalar2 power and replaced. 
> c
> c scalar1 = scalar1**scalar2 
> c   
29,35c34,62
< 
< 	double precision x 
< 	integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)  
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer natoms, imoment
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, xind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer stack
38,39c65,70
< 
<       integer imoment, natoms, i
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
42,45c73,88
< 
<       if (nindex .ne. 0) then
<          print *,'Error: nuc_dipole_moment at line ',current_line
<          print *,'First arg. must be a scalar.'
---
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar that tells whether X Y or Z nuclear dipole moment
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array_type .ne. scalar_value) then
>          print *,'Error: The argument in nn_dipole_moment
>      *            must be a scalar.'  
>          print *,(op(i),i=1,loptable_entry)
49,52c92,98
<       if (nindex2 .ne. 0) then
<          print *,'Error: nuc_dipole_moment at line ',current_line,
<      *           'must be called with scalar in 2nd arg.'
<          call abort_job()
---
>       sind =  array_table(c_scalar_index, array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>         print *,'Scalar table index out of range in nn_dipole_moment, ',
>      *          'line ',current_line
>         print *,'Index for array ',array,' is ',sind,' should be ',
>      *          'between 1 and ',nscalar_table
>         call abort_job()
54a101,118
> c----------------------------------------------------------------------------
> c   Locate the scalar that will hold the nuclear dipole moment
> C
> C   !!!  On input, this scalar has the number of atoms  !!!
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       xind =  array_table(c_scalar_index, evec_array)
>       if (xind .lt. 1 .or. xind .gt. nscalar_table) then
>         print *,'Scalar table index out of range in nn_dipole_moment, ',
>      *          'line ',current_line
>         print *,'Index for array ',evec_array,'is',xind,' should be ',
>      *          'between 1 and ',nscalar_table
>         call abort_job()
>       endif
60,62c124,126
<       if ( abs (x - 1) .LT. 0.0001 ) imoment = 1
<       if ( abs (x - 2) .LT. 0.0001 ) imoment = 2
<       if ( abs (x - 3) .LT. 0.0001 ) imoment = 3
---
>       if ( abs (scalar_table(sind) - 1) .LT. 0.0001 ) imoment = 1
>       if ( abs (scalar_table(sind) - 2) .LT. 0.0001 ) imoment = 2
>       if ( abs (scalar_table(sind) - 3) .LT. 0.0001 ) imoment = 3
64,65c128,129
<       natoms = x2
<       x2 = 0.0D0
---
>       natoms = scalar_table(xind)
>       scalar_table(xind) = 0.0D0
84d147
<          call abort_job()
86c149
<       x2 = DNUC
---
>       scalar_table(xind) = DNUC
Only in /home/perera/Develop/ACESIII/sip: nuc_dipole_moment.o
Only in /home/perera/Develop/ACESIII/sip: open_aat_database.o
Only in /home/perera/Develop/ACESIII/sip: open_amp.o
diff junk/optable_loop.f /home/perera/Develop/ACESIII/sip/optable_loop.f
1c1
< Ci  Copyright (c) 2003-2010 University of Florida
---
> C  Copyright (c) 2003-2010 University of Florida
61,62d60
<       integer tmpop
< c      integer pardo_overhead_timer, thread_server_timer
65,76d62
< c           Nakul
<       integer instruction_blk_timer
<       integer instruction_mpi_timer
<       integer instruction_times_timer
<       integer instruction_mpitimes_timer
<       integer instruction_unit_timer
<       integer instruction_allocate_timer
<       integer instruction_total_timer
<       integer pardo_tot_timer
<       integer pardo_blk_timer
< c           Nakul
< 
92,93d77
< c      save pardo_overhead_timer, thread_server_timer
< 
101,102d84
< c      pardo_act_timer = -10
< c      pardo_tserver_timer = -10
150,155d131
< c--------------------------------------------------------------------------
< c   Nakul
< c--------------------------------------------------------------------------
< 
<          call timer_start(timer_optl)
< 
175,176d150
< 
< 
178d151
< 
182,185d154
< 
<             
<             call timer_start(timer_ovrhead)
< 
215,268d183
<               
< 
< c---------------------------------------------------------------------------
< c   Record time for stuff done in pardo - Nakul
< c---------------------------------------------------------------------------
<                if (do_timer) then
<                    if (opcode .eq. endpardo_op) then
<                       call update_timer(pardo_act_timer)
<                       call update_timer(pardo_times_timer)
<                       pardo_act_timer = 0
<                       pardo_tserver_timer = 0
<                       pardo_times_timer = 0
< 
< c                      pardo_act_timer = -10
< c                      pardo_tserver_timer = -10
< c                     print *,"Time for pardo end: ",mpi_wtime(),
< c     *                     "for ", pardo_overhead_timer,
< c     *                      iop,
< c     *                     pardo_timer, pardo_block_wait_timer,
< c     *                     optable(c_lineno,iop);
<                    endif
<                endif
<            
<               tmpop = iop                
<               if (do_timer) then
<                 if (opcode .eq. pardo_op) then
< c                   pardo_tot_timer = 
< c                            optable(c_instr_time, tmpop)
<                   call unpack_pardo_timer(optable(c_instr_timer,tmpop),
<      *                   pardo_tot_timer, pardo_blk_timer)
< c                 if (pardo_tot_timer .gt. 32000)
< c     *              print *, "problem 1 at line ",optable(c_lineno,iop)
< c                 pardo_tserver_timer = 
< c     *                      optable(c_pardo_tserver_timer, tmpop)
<                   if (pardo_tot_timer .ne. 0) 
<      *                  pardo_tserver_timer = pardo_blk_timer + 2
< c                  call update_timer(pardo_times_timer)
< 
<                   endif
<               endif
< c---------------------------------------------------------------------------
< c   End Record time for stuff done in pardo - Nakul
< c---------------------------------------------------------------------------
< 
<                call unpack_pardo_timer(optable(c_instr_timer,tmpop),
<      *                      pardo_tot_timer, pardo_blk_timer)
< c                 if (pardo_tot_timer .gt. 32000)
< c     *              print *, "problem 2 at line ",optable(c_lineno,iop)
<                if (pardo_tot_timer .ne. 0) 
<      *               pardo_ovrhead_timer = pardo_blk_timer + 3
< c               pardo_times_timer = pardo_ovrhead_timer + 1
<      *                  
< c               call timer_start(pardo_ovrhead_timer)
< 
284,323d198
< 
< c               call update_timer(pardo_ovrhead_timer)
<                
<                pardo_ovrhead_timer = 0
< 
< c---------------------------------------------------------------------------
< c   Record time for stuff done in pardo - Nakul
< c---------------------------------------------------------------------------
<            if (do_timer) then
<                if (opcode .eq. pardo_op) then
<                   call unpack_pardo_timer(optable(c_instr_timer,tmpop),
<      *                     pardo_tot_timer, pardo_blk_timer)
< c                 if (pardo_tot_timer .gt. 32000)
< c     *              print *, "problem 3 at line ",optable(c_lineno,iop)
< c                 pardo_act_timer = 
< c     *                          optable(c_pardo_act_timer, tmpop)
< c                 pardo_tserver_timer = 
< c     *                       optable(c_pardo_tserver_timer, tmpop)
<                   if (pardo_tot_timer .ne. 0) then
<                     pardo_act_timer = pardo_blk_timer + 1
<                     pardo_tserver_timer = pardo_blk_timer + 2
<                     pardo_ovrhead_timer = pardo_blk_timer + 3
<                     pardo_times_timer = pardo_blk_timer + 4
<                   endif
< 
<                   call timer_start(pardo_act_timer)
< 
<                   call timer_start(pardo_times_timer)
< 
< c                  print *,"Time for pardo begin: ",mpi_wtime(),
< c     *                     "for ", pardo_overhead_timer, 
< c     *                      iop, 
< c     *                     pardo_timer, pardo_block_wait_timer,
< c     *                      optable(c_lineno,tmpop);
<                endif
<           endif
< c---------------------------------------------------------------------------
< c   End Record time for stuff done in pardo - Nakul
< c---------------------------------------------------------------------------
< 
330d204
< 
338,339d211
<             call update_timer(timer_ovrhead)
< 
346,349c218
<      *          iop .gt. end_op) then 
< c               print *,"I just skipped !!"
<                 go to 900 
<             endif
---
>      *          iop .gt. end_op) go to 900 
358,359c227,228
< c            if (icount .ge. timer_count) then
< c               icount = 0
---
>             if (icount .ge. timer_count) then
>                icount = 0
372c241
< c               if (t2-t1 .gt. timeslice) then
---
>                if (t2-t1 .gt. timeslice) then
375,379d243
< c                  if (pardo_act_timer .ne. -10) then
<                      call update_timer(pardo_act_timer)
<                      call timer_start(pardo_tserver_timer)
<                      call timer_start(timer_ovrhead)
< c                  endif 
381,385d244
< c                  if (pardo_act_timer .ne. -10) then
<                     call update_timer(timer_ovrhead) 
<                     call update_timer(pardo_tserver_timer) 
<                     call timer_start(pardo_act_timer)
< c                  endif
390,391c249,250
< c               endif
< c            endif 
---
>                endif
>             endif 
393c252
< c            icount = icount + 1
---
>             icount = icount + 1
401,415d259
<             instruction_timer = 0
<             instruction_blk_timer = 0
<             instruction_mpi_timer = 0
<             instruction_times_timer = 0
<             instruction_mpitimes_timer = 0
<             instruction_unit_timer = 0
<             instruction_allocate_timer = 0
<             instruction_total_timer = 0
<             current_instr_timer = 0
<             current_instr_blk_timer = 0
<             current_instr_mpi_timer = 0
<             current_instr_mpino_timer = 0
<             current_instr_unit_timer = 0
<             current_instr_allocate_timer = 0
< 
419,468d262
<                   
< c                  if (optable(c_lineno, iop) .eq. 7626) then
< c                      print *, '7626 :', optable(c_instr_timer, iop),
< c     *                          'instruction_timer = ',
< c    *                          instruction_timer
< c                 endif
< 
< 
< c                  if (instruction_timer .gt. 32000)
< c     *              print *, "problem 4 at line ",optable(c_lineno,iop)
< c                  if (instruction_timer .eq. 0)
< c     *              print *, 'timer 0 at line ', optable(c_lineno,iop)
< c                  instruction_blk_timer = optable(c_instr_blk_timer,iop)
< c                  instruction_mpi_timer = optable(c_instr_mpi_timer,iop)
<                   if (instruction_timer .ne. 0) then
<                     instruction_blk_timer = instruction_timer + 1
<                     instruction_mpi_timer = instruction_timer + 2
<                     instruction_times_timer = instruction_timer + 3
<                     instruction_mpitimes_timer = 
<      *                               instruction_timer + 4
<                     instruction_unit_timer = instruction_timer + 5
<                     instruction_allocate_timer = instruction_timer + 6
<                     instruction_total_timer = instruction_timer + 7
<                     current_instr_timer = instruction_timer
<                     current_instr_blk_timer = instruction_blk_timer
<                     current_instr_mpi_timer = instruction_mpi_timer
<                     current_instr_mpino_timer = 
<      *                                   instruction_mpitimes_timer
<                     current_instr_unit_timer = instruction_unit_timer
<                     current_instr_allocate_timer = 
<      *                                      instruction_allocate_timer
<                     current_instr_total_timer = 
<      *                                      instruction_total_timer 
< 
<                   endif
< c                print *, 'current_instr_timer =', current_instr_timer,  
< c     *                                'iop =', iop, 'line=',current_line
<                  
< c                  if (instruction_timer .gt. 999999 .or.
< c     *                 instruction_timer .lt. 0) then
< c                      print *, me, ' instruction_total_timer=',
< c     *                 instruction_total_timer, ' instruction_timer = ',
< c     *                 instruction_timer, ' instruction_times_timer =',
< c     *                 instruction_times_timer, 
< c     *                 'instruction_unit_timer =',
< c     *                 instruction_unit_timer, ' linenum =',
< c     *                 optable(c_lineno, iop)
< c                  endif
< 
<                   call timer_start(instruction_total_timer)
470,473d263
< c				  print *, 'instruction_timer = ', instruction_timer
< c				  print *,'instruction_times_timer = ',instruction_times_timer
<                   call timer_start(instruction_times_timer)
<                   call timer_start(instruction_unit_timer)
477d266
< 
486,487d274
< 
< 
489,506c276,277
<                 if (optable(c_opcode,iop) .ne. pardo_op) then
<                     call update_timer(instruction_timer)
<                     call update_timer(instruction_times_timer)
<                     call update_timer(instruction_unit_timer)
<                     call update_timer(instruction_total_timer)
<                     current_instr_timer = 0
<                     current_instr_blk_timer = 0
<                     current_instr_mpi_timer = 0
<                     current_instr_mpino_timer = 0
<                     current_instr_unit_timer = 0
<                     current_instr_allocate_timer = 0
<                     current_instr_total_timer = 0
<                     instruction_times_timer = 0
<                     instruction_timer=0
<                     instruction_unit_timer=0
<                     instruction_allocate_timer=0
<                     instruction_total_timer=0
<                 endif
---
>                 if (optable(c_opcode,iop) .ne. pardo_op)
>      *             call update_timer(instruction_timer)
523,530d293
<      
<        
< c--------------------------------------------------------------------------
< c   Nakul
< c--------------------------------------------------------------------------
< 
<       call update_timer(timer_optl)
<      
Only in /home/perera/Develop/ACESIII/sip: optable_loop.o
Only in /home/perera/Develop/ACESIII/sip: optable_loop_sim.o
diff junk/overlap_der.F /home/perera/Develop/ACESIII/sip/overlap_der.F
15,16c15,20
<       subroutine overlap_der(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine overlap_der(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24a29,30
>       include 'mpif.h'
>       include 'interpreter.h'
25a32,114
>       include 'trace.h'
>       include 'parallel_info.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
> 
>       integer*8 address_table(narray_table)
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer*8 get_block_data_index
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack, intermediate 
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer find_current_block
>       integer block
>       integer igrad, component 
> 
>       double precision dummy, y
>       integer flopcount
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
27,29c116,144
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Overlap_der requires a 2-index argument 
>      *               array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
31c146,153
<       integer nsend
---
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
38,39c160
<          call comp_overlap_der(x, bval(1), eval(1), bval(2),
<      *                      eval(2), nsend) 
---
>          call comp_overlap_der(x(indblk), a1, a2, b1, b2, nsend) 
Only in /home/perera/Develop/ACESIII/sip: overlap_der.o
diff junk/pardo_loadb.f /home/perera/Develop/ACESIII/sip/pardo_loadb.f
64,65d63
< 
< 
143,147c141
<      *                      pardo_timer, pardo_block_wait_timer)
< 
< c            print *, "pardo_timer =", pardo_timer, 
< c     *               "pardo_block_wait_timer =", pardo_block_wait_timer
< 
---
>      *                      pardo_timer, pardo_block_wait_timer) 
149d142
<             
179,180d171
<          call timer_start (pardo_ovrhead_timer)
< 
187,188c178
< c               call timer_start (timer_ovrhead)
<                call timer_start (pardo_tserver_timer)
---
> 
190,191d179
<                call update_timer (pardo_tserver_timer)
< c               call update_timer (timer_ovrhead)
206,207d193
<          call update_timer (pardo_ovrhead_timer)
< 
218d203
< 
266d250
< 
317d300
< 
325d307
< 
374d355
< 
Only in /home/perera/Develop/ACESIII/sip: pardo_loadb.o
Only in /home/perera/Develop/ACESIII/sip: pardo_loadb_update_batch.o
diff junk/pardo_loop.f /home/perera/Develop/ACESIII/sip/pardo_loop.f
49,51d48
< 
< c      integer pardo_overhead_timer
< 
68d64
< 
172,176c168
<      *                  pardo_timer, pardo_block_wait_timer)
<             
< c            print *, "pardo_timer =", pardo_timer, 
< c     *               "pardo_block_wait_timer =", pardo_block_wait_timer
< 
---
>      *                 pardo_timer, pardo_block_wait_timer)
267d258
<     
274d264
<          
361d350
< 
377c366
<     
---
> 
Only in /home/perera/Develop/ACESIII/sip: pardo_loop.o
diff junk/pardo_sects.f /home/perera/Develop/ACESIII/sip/pardo_sects.f
15,26c15,22
<       subroutine pardo_sects(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
< c--------------------------------------------------------------------------
< c   Usage: execute pardo_sects scalar1 scalar2
< c          
< c   scalar1 is type of calculation.
< c   scalar2 is output.
< c   
< c--------------------------------------------------------------------------
< 
---
>       subroutine pardo_sects(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
> c---------------------------------------------------------------------------
> c----------------------------------------------------------------------------
28a25
>       include 'mpif.h'
30d26
<       include 'int_gen_parms.h'
31a28,51
>       include 'int_gen_parms.h'
>       include 'dbugcom.h'
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer ierr, array, array_type, ind
>       integer type, i, j, k, nsects, vcount, ocount, vseg, oseg
> 
> c --------------------------------------------------------------------------- 
> c Define the input scalar --> type of segmentation 
> c --------------------------------------------------------------------------- 
> 
>       array = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       if (array_type .ne. scalar_value) return
33,46c53,55
<       double precision x
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer i, j, k
<       integer vcount
<       integer oseg, vseg, nsects
< 
<       if (nindex .ne. 0) then
<          print *,'Error: pardo_sects at line ',current_line
<          print *,'First arg. must be a scalar.'
---
>       if (array .lt. 1 .or. array .gt. narray_table) then
>          print *,'Error: scalar in pardo_sects, line ',
>      *     current_line
50,53c59,65
<       if (nindex2 .ne. 0) then
<          print *,'Error: pardo_sects at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       ind =  array_table(c_scalar_index, array)
>       if (ind .lt. 1 .or. ind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in pardo_sects, ',
>      *           'line ',current_line
>          print *,'Index for array ',array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
55a68,69
>       type = scalar_table(ind)
> 
60c74,93
<       oseg = x2  ! The number of occupied triplets 
---
>       array = op(c_op1_array)
>       array_type = array_table(c_array_type, array)
>       if (array_type .ne. scalar_value) return
> 
>       if (array .lt. 1 .or. array .gt. narray_table) then
>          print *,'Error: scalar in pardo_sects, line ',
>      *     current_line
>          call abort_job()
>       endif
> 
>       ind =  array_table(c_scalar_index, array)
>       if (ind .lt. 1 .or. ind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in pardo_sects, ',
>      *           'line ',current_line
>          print *,'Index for array ',array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
>       endif
> 
>       oseg = scalar_table(ind)  ! The number of occupied triplets 
67c100
<       if (x .eq. 1) then
---
>       if (type .eq. 1) then
82c115
<          x2 = nsects  
---
>          scalar_table(ind) = nsects  
92c125
<       if (x .eq. 2) then
---
>       if (type .eq. 2) then
107c140
<          x2 = nsects  
---
>          scalar_table(ind) = nsects  
117c150
<       if (x .eq. 3) then
---
>       if (type .eq. 3) then
131c164
<          x2 = nsects  
---
>          scalar_table(ind) = nsects  
141c174
<       if (x .eq. 3) then
---
>       if (type .eq. 3) then
158c191
<          x2 = nsects
---
>          scalar_table(ind) = nsects
Only in /home/perera/Develop/ACESIII/sip: pardo_sects.o
Only in /home/perera/Develop/ACESIII/sip: pardo_timer.o
diff junk/place_one2b.F /home/perera/Develop/ACESIII/sip/place_one2b.F
15,18c15,21
<       subroutine place_one2b(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one2b(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one2b array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one2b at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one2b at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone2b(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone2b(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one2b.o
diff junk/place_one2.F /home/perera/Develop/ACESIII/sip/place_one2.F
15,18c15,21
<       subroutine place_one2(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one2(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one2 array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one2 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one2 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone2(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone2(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
53d162
< 
54a164
> 
Only in /home/perera/Develop/ACESIII/sip: place_one2.o
diff junk/place_one3b.F /home/perera/Develop/ACESIII/sip/place_one3b.F
15,18c15,21
<       subroutine place_one3b(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one3b(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one3b array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one3b at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one3b at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone3b(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone3b(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one3b.o
diff junk/place_one3.F /home/perera/Develop/ACESIII/sip/place_one3.F
15,18c15,21
<       subroutine place_one3(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one3(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one3 array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one3 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one3 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone3(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone3(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
53d162
< 
Only in /home/perera/Develop/ACESIII/sip: place_one3.o
diff junk/place_one4b.F /home/perera/Develop/ACESIII/sip/place_one4b.F
15,18c15,21
<       subroutine place_one4b(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one4b(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one4b array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one4b at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one4b at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone4b(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone4b(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one4b.o
diff junk/place_one4.F /home/perera/Develop/ACESIII/sip/place_one4.F
15,18c15,21
<       subroutine place_one4(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one4(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one4 array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one4 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one4 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone4(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone4(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
53d162
< 
Only in /home/perera/Develop/ACESIII/sip: place_one4.o
diff junk/place_one5b.F /home/perera/Develop/ACESIII/sip/place_one5b.F
15,18c15,21
<       subroutine place_one5b(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one5b(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one5b array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one5b at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one5b at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone5b(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone5b(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
68a179,180
>       if (b1 .eq. 1 .and. b2 .eq. 1) then
> 
71,82c183,199
< c       if(a .eq. nbeta_occupied-4 
< c    *        .and. b .eq. 1)then
< c          array1(a,b) = sval  
< c          write(6,*) ' IP ARRAY ', a, b, array1(a,b)  
< c       endif
< c       if(a .eq. nbeta_occupied+1 
< c    *        .and. b .eq. 1)then
< c          array1(a,b) = sval  
< c          write(6,*) ' EA ARRAY ', a, b, array1(a,b)  
< c       endif
<         if(a .eq. nbeta_occupied+1 
<      *        .and. b .eq. nbeta_occupied-2)then
---
>         if(a .eq. nbeta_occupied-4) then   
>            array1(a,b) = sval  
>            write(6,*) ' IP ARRAY ', a, b, array1(a,b)  
>         endif
>         if(a .eq. nbeta_occupied+5) then   
>            array1(a,b) = sval  
>            write(6,*) ' EA ARRAY ', a, b, array1(a,b)  
>         endif
>       enddo  
>       enddo  
> 
>       else 
> 
>       do a = a1, a2 
>       do b = b1, b2 
>         if(a .eq. nbeta_occupied+2 
>      *        .and. b .eq. nbeta_occupied-1)then
87a205,206
> 
>       endif 
Only in /home/perera/Develop/ACESIII/sip: place_one5b.o
diff junk/place_one5.F /home/perera/Develop/ACESIII/sip/place_one5.F
15,18c15,21
<       subroutine place_one5(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one5(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one5 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one5 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one5 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone5(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone5(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
53d162
< 
69c178,195
<       write(6,*) ' alpha_occupied: ', nalpha_occupied  
---
> 
>       if (b1 .eq. 1 .and. b2 .eq. 1) then
> 
>       do a = a1, a2 
>       do b = b1, b2 
>         if(a .eq. nalpha_occupied-4) then   
>            array1(a,b) = sval  
>            write(6,*) ' IP ARRAY ', a, b, array1(a,b)  
>         endif
>         if(a .eq. nalpha_occupied+5) then   
>            array1(a,b) = sval  
>            write(6,*) ' EA ARRAY ', a, b, array1(a,b)  
>         endif
>       enddo  
>       enddo  
> 
>       else  
> 
72,83c198,199
< c       if(a .eq. nalpha_occupied-4 
< c    *        .and. b .eq. 1)then
< c          array1(a,b) = sval  
< c          write(6,*) ' IP ARRAY ', a, b, array1(a,b)  
< c       endif
< c       if(a .eq. nalpha_occupied+1 
< c    *        .and. b .eq. 1)then
< c          array1(a,b) = sval  
< c          write(6,*) ' EA ARRAY ', a, b, array1(a,b)  
< c       endif
<         if(a .eq. nalpha_occupied+1 
<      *        .and. b .eq. nalpha_occupied-2)then
---
>         if(a .eq. nalpha_occupied+2 
>      *        .and. b .eq. nalpha_occupied-1)then
88a205,206
> 
>       endif 
Only in /home/perera/Develop/ACESIII/sip: place_one5.o
diff junk/place_one6b.F /home/perera/Develop/ACESIII/sip/place_one6b.F
15,18c15,21
<       subroutine place_one6b(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one6b(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one6b array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one6b at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one6b at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone6b(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone6b(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one6b.o
diff junk/place_one6.F /home/perera/Develop/ACESIII/sip/place_one6.F
15,18c15,21
<       subroutine place_one6(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one6(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one6 array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one6 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one6 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone6(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone6(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
53,54d162
< 
< 
Only in /home/perera/Develop/ACESIII/sip: place_one6.o
diff junk/place_oneb.F /home/perera/Develop/ACESIII/sip/place_oneb.F
15,18c15,21
<       subroutine place_oneb(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_oneb(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_oneb array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_oneb at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_oneb at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceoneb(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceoneb(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_oneb.o
diff junk/place_one_dea_2.F /home/perera/Develop/ACESIII/sip/place_one_dea_2.F
15,18c15,21
<       subroutine place_one_dea_2(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_2(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_2 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_2 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_2 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea2(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea2(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_2.o
diff junk/place_one_dea_3.F /home/perera/Develop/ACESIII/sip/place_one_dea_3.F
15,18c15,21
<       subroutine place_one_dea_3(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_3(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_3 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_3 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_3 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea3(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea3(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_3.o
diff junk/place_one_dea_4.F /home/perera/Develop/ACESIII/sip/place_one_dea_4.F
15,18c15,21
<       subroutine place_one_dea_4(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_4(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_4 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_4 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_4 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea4(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea4(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_4.o
diff junk/place_one_dea_5.F /home/perera/Develop/ACESIII/sip/place_one_dea_5.F
15,18c15,21
<       subroutine place_one_dea_5(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_5(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_5 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_5 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_5 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea5(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea5(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_5.o
diff junk/place_one_dea_6.F /home/perera/Develop/ACESIII/sip/place_one_dea_6.F
15,18c15,21
<       subroutine place_one_dea_6(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_6(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_6 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_6 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_6 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea6(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea6(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_6.o
diff junk/place_one_dea_7.F /home/perera/Develop/ACESIII/sip/place_one_dea_7.F
15,18c15,21
<       subroutine place_one_dea_7(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_7(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_7 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_7 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_7 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea7(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea7(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_7.o
diff junk/place_one_dea_8.F /home/perera/Develop/ACESIII/sip/place_one_dea_8.F
15,18c15,21
<       subroutine place_one_dea_8(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea_8(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea_8 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea_8 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea_8 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea8(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea8(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dea_8.o
diff junk/place_one_dea.F /home/perera/Develop/ACESIII/sip/place_one_dea.F
15,18c15,21
<       subroutine place_one_dea(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dea(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dea array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dea at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dea at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedea(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedea(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
65c175,180
<       double precision array1(a1:a2,b1:b2), sval   
---
>       double precision array1(a1:a2,b1:b2), sval, ediff    
> 
> c     write(6,*) ' RANGE :', a1, a2, b1, b2, sval  
> c     write(6,*) ' alpha_occupied: ', nalpha_occupied  
> c     write(6,*) ' beta_occupied: ', nbeta_occupied  
>       ediff = dabs(1.0 - dabs(sval)) 
67,69c182
<       write(6,*) ' RANGE :', a1, a2, b1, b2, sval  
<       write(6,*) ' alpha_occupied: ', nalpha_occupied  
<       write(6,*) ' beta_occupied: ', nbeta_occupied  
---
>       if (ediff .lt. 0.000001) then  
78a192,214
>       endif 
> 
>       if (ediff .gt. 0.000001) then  
>       do a = a1, a2 
>       do b = b1, b2 
>          array1(a,b) = 0.0 
>       enddo  
>       enddo  
> 
>       do a = a1, a2 
>       do b = b1, b2 
>         if(b .eq. nbeta_occupied+2 
>      *        .and. a .eq. nalpha_occupied+1)then
>            array1(a,b) =  sval  
>            array1(b,a) =  -1.0D0*sval   
>            write(6,*) 'C VECTOR ', a, b, array1(a,b)  
>         endif
>       enddo  
>       enddo  
> 
> 
>       endif 
>       
Only in /home/perera/Develop/ACESIII/sip: place_one_dea.o
diff junk/place_one_dip_2.F /home/perera/Develop/ACESIII/sip/place_one_dip_2.F
15,18c15,21
<       subroutine place_one_dip_2(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_2(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_2 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_2 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_2 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip2(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip2(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_2.o
diff junk/place_one_dip_3.F /home/perera/Develop/ACESIII/sip/place_one_dip_3.F
15,18c15,21
<       subroutine place_one_dip_3(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_3(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_3 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_3 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_3 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip3(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip3(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_3.o
diff junk/place_one_dip_4.F /home/perera/Develop/ACESIII/sip/place_one_dip_4.F
15,18c15,21
<       subroutine place_one_dip_4(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_4(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_4 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_4 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_4 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip4(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip4(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_4.o
diff junk/place_one_dip_5.F /home/perera/Develop/ACESIII/sip/place_one_dip_5.F
15,18c15,21
<       subroutine place_one_dip_5(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_5(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_5 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_5 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_5 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip5(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip5(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_5.o
diff junk/place_one_dip_6.F /home/perera/Develop/ACESIII/sip/place_one_dip_6.F
15,18c15,21
<       subroutine place_one_dip_6(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_6(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_6 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_6 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_6 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip6(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip6(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_6.o
diff junk/place_one_dip_7.F /home/perera/Develop/ACESIII/sip/place_one_dip_7.F
15,18c15,21
<       subroutine place_one_dip_7(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_7(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_7 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_7 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_7 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip7(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip7(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_7.o
diff junk/place_one_dip_8.F /home/perera/Develop/ACESIII/sip/place_one_dip_8.F
15,18c15,21
<       subroutine place_one_dip_8(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip_8(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip_8 array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip_8 at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip_8 at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip8(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip8(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one_dip_8.o
diff junk/place_one_dip.F /home/perera/Develop/ACESIII/sip/place_one_dip.F
15,18c15,21
<       subroutine place_one_dip(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one_dip(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one_dip array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one_dip at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one_dip at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceonedip(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceonedip(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
65c175
<       double precision array1(a1:a2,b1:b2), sval   
---
>       double precision array1(a1:a2,b1:b2), sval, ediff    
70,75c180,208
<       do a = a1, a2 
<       do b = b1, b2 
<         if(a .eq. nbeta_occupied 
<      *        .and. b .eq. nalpha_occupied)then
<            array1(a,b) = sval  
<            write(6,*) 'C VECTOR ', a, b, array1(a,b)  
---
> 
>       ediff = dabs(1.0 - dabs(sval))
> 
>       if (ediff .lt. 0.000001) then
>       do a = a1, a2
>       do b = b1, b2
>         if(b .eq. nbeta_occupied
>      *        .and. a .eq. nalpha_occupied)then
>            array1(a,b) = sval
>            write(6,*) 'C VECTOR ', a, b, array1(a,b)
>         endif
>       enddo
>       enddo
>       endif
> 
>       if (ediff .gt. 0.000001) then
>       do a = a1, a2
>       do b = b1, b2
>          array1(a,b) = 0.0
>       enddo
>       enddo
> 
>       do a = a1, a2
>       do b = b1, b2
>         if(b .eq. nbeta_occupied-1 
>      *        .and. a .eq. nalpha_occupied)then
>            array1(a,b) =  sval
>            array1(b,a) =  -sval 
>            write(6,*) 'C VECTOR ', a, b, array1(a,b)
77,78c210,216
<       enddo  
<       enddo  
---
>       enddo
>       enddo
> 
> 
>       endif
> 
> 
Only in /home/perera/Develop/ACESIII/sip: place_one_dip.o
diff junk/place_one.F /home/perera/Develop/ACESIII/sip/place_one.F
15,18c15,21
<       subroutine place_one(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_one(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_one array scalar
---
> c
26a30,74
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
28,37c76,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_one at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_one at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplaceone(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplaceone(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_one.o
diff junk/place_sval.F /home/perera/Develop/ACESIII/sip/place_sval.F
15,18c15,21
<       subroutine place_sval(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine place_sval(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute place_sval array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: place_sval at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,44c87,154
<       if (nindex2 .ne. 0) then
<          print *,'Error: place_sval at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
47,48c157,158
<       call doplace(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
>       call doplace(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: place_sval.o
Only in /home/perera/Develop/ACESIII/sip: prefetch_context.o
Only in /home/perera/Develop/ACESIII/sip: prefetch_off.o
Only in /home/perera/Develop/ACESIII/sip: prefetch_on.o
Only in /home/perera/Develop/ACESIII/sip: prepare_block.o
Only in /home/perera/Develop/ACESIII/sip: prequest_block.o
Only in /home/perera/Develop/ACESIII/sip: pre_request_block.o
Only in /home/perera/Develop/ACESIII/sip: print_eom_dens_info.o
Only in /home/perera/Develop/ACESIII/sip: print_opcounter.o
Only in /home/perera/Develop/ACESIII/sip: print_rel_info.o
diff junk/print_scalar.f /home/perera/Develop/ACESIII/sip/print_scalar.f
15,16c15,20
<       subroutine print_scalar(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine print_scalar(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
28,34c32,75
<       double precision x
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
< 
<       if (me .eq. 0) 
<      *      print *,'Task ',me,' Scalar value = ',
<      *      x,' at line number ',current_line
---
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer ierr, array, array_type, ind
>       integer i
> 
>       array = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       if (array_type .ne. scalar_value) return
> 
>       if (array .lt. 1 .or. array .gt. narray_table) then
>          print *,'Error: Invalid array in print_scalar, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif
> 
>       ind =  array_table(c_scalar_index, array)
>       if (ind .lt. 1 .or. ind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in print_scalar, ',
>      *           'line ',current_line
>          print *,'Index for array ',array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
>       endif
> 
>       if (dbg) then
>          print *,'Task ',me,' Scalar #',array,': value = ',
>      *      scalar_table(ind),' at line number ',current_line
>          call prt_time('Worker time')
>       else
>          if (me .eq. 0) 
>      *      print *,'Task ',me,' Scalar #',array,': value = ',
>      *      scalar_table(ind),' at line number ',current_line
>       endif
Only in /home/perera/Develop/ACESIII/sip: print_scalar.o
Only in /home/perera/Develop/ACESIII/sip: read_coefficients.F
Only in /home/perera/Develop/ACESIII/sip: read_coefficients.o
diff junk/read_grad.F /home/perera/Develop/ACESIII/sip/read_grad.F
15,16c15,20
<       subroutine read_grad(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine read_grad(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
18,19c22,23
< c   Divides each sample of the block given by the array argument by the 
< c       eps = f_alpha(i)+f_beta(i)-f_alpha(a)-f_beta(a)
---
> c     The 4-index array (hessian at present) is read in and summed 
> c     into an array in a common block. 
24c28,57
<       include 'epsilon.h'
---
>       include 'trace.h'
>       include 'mpif.h'
>       include 'int_gen_parms.h'
>       include 'hess.h' 
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer*8 addr, get_index_from_base
26,28c59,105
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
33c110
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
37c114
<       call add_grad(x,bval(1),eval(1),bval(2),eval(2))
---
>       call add_grad(x(indblk),val1(1),val2(1),val1(2),val2(2))
Only in /home/perera/Develop/ACESIII/sip: read_grad.o
diff junk/read_hess.F /home/perera/Develop/ACESIII/sip/read_hess.F
15,16c15,20
<       subroutine read_hess(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine read_hess(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24a29
>       include 'mpif.h'
31,33c36,57
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer*8 addr, get_index_from_base
35c59
<       double precision xx(1)
---
>       double precision x(1)
37c61
<       pointer (dptr, xx)
---
>       pointer (dptr, x)
39c63
<       common xx
---
>       common x
48a73,109
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
> 
52,53c113
<          print *,'array has ',nindex,' indices at line ',
<      *            current_line,'.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
57,59c117,119
<       call add_hess(x,bval(1),eval(1),bval(2),eval(2),
<      *                        bval(3),eval(3),bval(4),eval(4),
<      *                        xx(ix_hess))
---
>       call add_hess(x(indblk),val1(1),val2(1),val1(2),val2(2),
>      *                        val1(3),val2(3),val1(4),val2(4),
>      *                        x(ix_hess))
Only in /home/perera/Develop/ACESIII/sip: read_hess.o
diff junk/read_list_to_blocks.F /home/perera/Develop/ACESIII/sip/read_list_to_blocks.F
192,194d191
<             do i = 1, len_sip_server_message
<                 msg(i) = 0
<             enddo
255,257d251
<             do i = 1, len_sip_server_message
<                 msg(i) = 0
<             enddo
341,344d334
< 
<         do i = 1, len_sip_server_message
<             msg(i) = 0
<         enddo
Only in /home/perera/Develop/ACESIII/sip: read_list_to_blocks_no_mpi_io.o
Only in /home/perera/Develop/ACESIII/sip: read_list_to_blocks.o
diff junk/remove_atom_rud1.F /home/perera/Develop/ACESIII/sip/remove_atom_rud1.F
15,16c15,20
<       subroutine remove_atom_rud1(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine remove_atom_rud1(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
24,27c28,107
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       include 'trace.h'
>       include 'mpif.h'
>       include 'epsilon.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
> 
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif
31,34c111,114
<          call doremove_atom_rud1(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4))
---
>          call doremove_atom_rud1(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4))
38c118
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: remove_atom_rud1.o
diff junk/remove_atom_rud2.F /home/perera/Develop/ACESIII/sip/remove_atom_rud2.F
15,16c15,20
<       subroutine remove_atom_rud2(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine remove_atom_rud2(array_table, narray_table,
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table,
>      *                      address_table, op)
24,27c28,107
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       include 'trace.h'
>       include 'mpif.h'
>       include 'epsilon.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table,
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
> 
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif
31,34c111,114
<          call doremove_atom_rud2(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4))
---
>          call doremove_atom_rud2(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4))
38c118
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: remove_atom_rud2.o
Only in /home/perera/Develop/ACESIII/sip: remove_dddd.o
diff junk/remove_dd.F /home/perera/Develop/ACESIII/sip/remove_dd.F
15,18c15,21
<       subroutine remove_dd(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_dd(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,126
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_dd must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
37c128,154
<        call retnodd(x,x2,bval(1),eval(1),bval(2),eval(2))
---
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> 
>       call retnodd(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
42c159
<       subroutine retnodd(array1,array2,a1,a2,b1,b2)
---
>       subroutine retnodd(array1,array2,a1,a2,b1,b2,index,type) 
46c163
< c
---
> c 
51c168
<       include 'int_gen_parms.h'
---
>       include 'int_gen_parms.h'  
53,80c170,199
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< c
< c     Determine range of doubly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       ndzero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
< c        do a = 1, nbeta_occupied
<          do a = nalpha_occupied+1, b2
<             ndzero = ndzero + 1
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
< c        do a = 1, nalpha_occupied
<          do a = nbeta_occupied+1, a2
<             ndzero = ndzero + 1
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> c
> c     Determine range of doubly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       ndzero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
> c        do a = 1, nbeta_occupied  
>          do a = nalpha_occupied+1, b2   
>             ndzero = ndzero + 1  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
> c        do a = 1, nalpha_occupied  
>          do a = nbeta_occupied+1, a2    
>             ndzero = ndzero + 1  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
93,94c212,213
< c     Reduce first index.
< c     -------------------
---
> c     Reduce first index. 
> c     ------------------- 
96,99c215,218
<       do i = 1,  ndzero
<       do a = a1, a2
<          if (dzero(i) .eq. a) then
<          do b = b1, b2
---
>       do i = 1,  ndzero 
>       do a = a1, a2  
>          if (dzero(i) .eq. a) then 
>          do b = b1, b2 
101c220
<             array2(a,b) = 0.0
---
>             array2(a,b) = 0.0 
103,106c222,225
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
108,109c227,228
< c     Reduce second index.
< c     -------------------
---
> c     Reduce second index. 
> c     ------------------- 
111,114c230,233
<       do i = 1,  ndzero
<       do b = b1, b2
<          if (dzero(i) .eq. b) then
<          do a = a1, a2
---
>       do i = 1,  ndzero 
>       do b = b1, b2  
>          if (dzero(i) .eq. b) then 
>          do a = a1, a2 
116c235
<             array2(a,b) = 0.0
---
>             array2(a,b) = 0.0 
118,121c237,240
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
123c242
< 100   continue
---
> 100   continue 
126a246
> 
Only in /home/perera/Develop/ACESIII/sip: remove_dd.o
diff junk/remove_diagonal.F /home/perera/Develop/ACESIII/sip/remove_diagonal.F
15,18c15,20
<       subroutine remove_diagonal(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_diagonal(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
34a37
>       include 'interpreter.h'
35a39,68
>       include 'epsilon.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
37,42c70
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
>       if (dryrun) return
44c72,74
<       integer n
---
> #ifdef ALTIX
>       dptr = dshptr
> #endif
46c76,122
<       if (dryrun) return
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_diagonal routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in remove_diagonal routine 
>      *            must be static.'
>          call abort_job()
>       endif
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in remove_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
48,49c124
<       n = edim(1) - bdim(1) + 1 
<       if (nindex .eq. 2) call rdiag2(x,x2,n) 
---
>       if (nindex .eq. 2) call rdiag2(x(iarray),x(ievec),array,n) 
54c129
<       subroutine rdiag2(array1,array2,n) 
---
>       subroutine rdiag2(array1,array2,array,n) 
69a145
>       integer array 
Only in /home/perera/Develop/ACESIII/sip: remove_diagonal.o
Only in /home/perera/Develop/ACESIII/sip: remove_double.o
diff junk/remove_ds.F /home/perera/Develop/ACESIII/sip/remove_ds.F
15,18c15,21
<       subroutine remove_ds(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_ds(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,129
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_ds must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
> 
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
37c131,154
<        call retnods(x,x2,bval(1),eval(1),bval(2),eval(2))
---
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> 
>       call retnods(x(iarray),x(ievec),
>      *              val1(1),val2(1),val1(2),val2(2),index,type)
42c159
<       subroutine retnods(array1,array2,a1,a2,b1,b2)
---
>       subroutine retnods(array1,array2,a1,a2,b1,b2,index,type) 
46c163
< c
---
> c 
51,129c168
<       include 'int_gen_parms.h'
< 
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< 
< c     Initialize output array to input array.
< c     ---------------------------------------
< 
<       do a = a1, a2
<       do b = b1, b2
< 
<          array2(a,b) = array1(a,b)
< 
<       enddo ! b
<       enddo ! a
< c
< c     Determine range of singly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       nszero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          nszero = nalpha_occupied - nbeta_occupied
<          do a = nalpha_occupied, nbeta_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          nszero = nbeta_occupied - nalpha_occupied
<          do a = nbeta_occupied, nalpha_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
< 
<       if (nalpha_occupied .eq. nbeta_occupied) go to 100
< c
< c     Reduce second index.
< c     -------------------
< 
<       do i = 1,  nszero
<       do b = b1, b2
<          if (szero(i) .eq. b) then
<          do a = a1, a2
< 
<             array2(a,b) = 0.0
< 
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
< c
< c     Determine range of doubly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       ndzero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          ndzero = nbeta_occupied
<          do a = 1, nbeta_occupied
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          ndzero = nalpha_occupied
<          do a = 1, nalpha_occupied
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
< c
< c     Reduce first index.
< c     -------------------
---
>       include 'int_gen_parms.h'  
131,141c170,260
<       do i = 1,  ndzero
<       do a = a1, a2
<          if (dzero(i) .eq. a) then
<          do b = b1, b2
< 
<             array2(a,b) = 0.0
< 
<          enddo ! a
<          endif
<       enddo ! b
<       enddo ! i
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> 
> c     Initialize output array to input array. 
> c     --------------------------------------- 
> 
>       do a = a1, a2 
>       do b = b1, b2 
> 
>          array2(a,b) = array1(a,b) 
> 
>       enddo ! b 
>       enddo ! a 
> c
> c     Determine range of singly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       nszero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          nszero = nalpha_occupied - nbeta_occupied 
>          do a = nalpha_occupied, nbeta_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          nszero = nbeta_occupied - nalpha_occupied 
>          do a = nbeta_occupied, nalpha_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
> 
>       if (nalpha_occupied .eq. nbeta_occupied) go to 100 
> c
> c     Reduce second index. 
> c     ------------------- 
> 
>       do i = 1,  nszero 
>       do b = b1, b2  
>          if (szero(i) .eq. b) then 
>          do a = a1, a2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
> c
> c     Determine range of doubly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       ndzero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          ndzero = nbeta_occupied 
>          do a = 1, nbeta_occupied  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          ndzero = nalpha_occupied 
>          do a = 1, nalpha_occupied  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
> c
> c     Reduce first index. 
> c     ------------------- 
> 
>       do i = 1,  ndzero 
>       do a = a1, a2  
>          if (dzero(i) .eq. a) then 
>          do b = b1, b2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! a 
>          endif 
>       enddo ! b   
>       enddo ! i 
143c262
< 100   continue
---
> 100   continue 
Only in /home/perera/Develop/ACESIII/sip: remove_ds.o
diff junk/remove_dx.F /home/perera/Develop/ACESIII/sip/remove_dx.F
15,18c15,21
<       subroutine remove_dx(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_dx(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,70
> #ifdef ALTIX
>       dptr = dshptr
> #endif
37c72,74
<        call retnodx(x,x2,bval(1),eval(1),bval(2),eval(2))
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
39,40c76,77
<       return 
<       end 
---
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
42c79,108
<       subroutine retnodx(array1,array2,a1,a2,b1,b2)
---
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_dx must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
45,46c111
< c
< c
---
> c   Look up each array's address.
49,51c114,126
<       implicit none
<       include 'interpreter.h'
<       include 'int_gen_parms.h'
---
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
53,78c128,129
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< c
< c     Determine range of singly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       nszero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          nszero = nalpha_occupied - nbeta_occupied
<          do a = nalpha_occupied, nbeta_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          nszero = nbeta_occupied - nalpha_occupied
<          do a = nbeta_occupied, nalpha_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
---
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
80c131,132
<       if (nalpha_occupied .eq. nbeta_occupied) go to 100
---
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
82,83c134,136
< c     Initialize output array to input array.
< c     ---------------------------------------
---
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
85,86c138,150
<       do a = a1, a2
<       do b = b1, b2
---
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
88,111c152,161
<          array2(a,b) = array1(a,b)
< 
<       enddo ! b
<       enddo ! a
< c
< c     Determine range of doubly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       ndzero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          ndzero = nbeta_occupied
<          do a = 1, nbeta_occupied
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          ndzero = nalpha_occupied
<          do a = 1, nalpha_occupied
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
---
> 
>       call retnodx(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
> 
>       return 
>       end 
> 
>       subroutine retnodx(array1,array2,a1,a2,b1,b2,index,type) 
> 
> c---------------------------------------------------------------------------
113,125c163,245
< c     Reduce first index.
< c     -------------------
<       do i = 1,  ndzero
<       do a = a1, a2
<          if (dzero(i) .eq. a) then
<          do b = b1, b2
< 
<             array2(a,b) = 0.0
< 
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
> c 
> c---------------------------------------------------------------------------
> 
>       implicit none
>       include 'interpreter.h'
>       include 'int_gen_parms.h'  
> 
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> c
> c     Determine range of singly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       nszero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          nszero = nalpha_occupied - nbeta_occupied 
>          do a = nalpha_occupied, nbeta_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          nszero = nbeta_occupied - nalpha_occupied 
>          do a = nbeta_occupied, nalpha_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
> 
>       if (nalpha_occupied .eq. nbeta_occupied) go to 100 
> 
> c     Initialize output array to input array. 
> c     --------------------------------------- 
> 
>       do a = a1, a2 
>       do b = b1, b2 
> 
>          array2(a,b) = array1(a,b) 
> 
>       enddo ! b 
>       enddo ! a 
> c
> c     Determine range of doubly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       ndzero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          ndzero = nbeta_occupied 
>          do a = 1, nbeta_occupied  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          ndzero = nalpha_occupied 
>          do a = 1, nalpha_occupied  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
> c
> c     Reduce first index. 
> c     ------------------- 
> 
>       do i = 1,  ndzero 
>       do a = a1, a2  
>          if (dzero(i) .eq. a) then 
>          do b = b1, b2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
127c247
< 100   continue
---
> 100   continue 
Only in /home/perera/Develop/ACESIII/sip: remove_dx.o
diff junk/removeoo_dd.F /home/perera/Develop/ACESIII/sip/removeoo_dd.F
15,18c15,21
<       subroutine removeoo_dd(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine removeoo_dd(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,129
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_dd must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
> 
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
37c131,154
<        call retnooodd(x,x2,bval(1),eval(1),bval(2),eval(2))
---
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> 
>       call retnooodd(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
42c159
<       subroutine retnooodd(array1,array2,a1,a2,b1,b2)
---
>       subroutine retnooodd(array1,array2,a1,a2,b1,b2,index,type) 
46c163
< c
---
> c 
51c168
<       include 'int_gen_parms.h'
---
>       include 'int_gen_parms.h'  
53,78c170,197
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< c
< c     Determine range of doubly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       ndzero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          do a = 1, nbeta_occupied
<             ndzero = ndzero + 1
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          do a = 1, nalpha_occupied
<             ndzero = ndzero + 1
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       integer index(mx_array_index), type(mx_array_index) 
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> c
> c     Determine range of doubly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       ndzero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          do a = 1, nbeta_occupied  
>             ndzero = ndzero + 1  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          do a = 1, nalpha_occupied  
>             ndzero = ndzero + 1  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
91,92c210,211
< c     Reduce first index.
< c     -------------------
---
> c     Reduce first index. 
> c     ------------------- 
94,97c213,216
<       do i = 1,  ndzero
<       do a = a1, a2
<          if (dzero(i) .eq. a) then
<          do b = b1, b2
---
>       do i = 1,  ndzero 
>       do a = a1, a2  
>          if (dzero(i) .eq. a) then 
>          do b = b1, b2 
99c218
<             array2(a,b) = 0.0
---
>             array2(a,b) = 0.0 
101,104c220,226
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
> c
> c     Reduce second index. 
> c     ------------------- 
106c228,240
< 100   continue
---
>       do i = 1,  ndzero 
>       do b = b1, b2  
>          if (dzero(i) .eq. b) then 
>          do a = a1, a2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
> 
> 100   continue 
109a244
> 
Only in /home/perera/Develop/ACESIII/sip: removeoo_dd.o
Only in /home/perera/Develop/ACESIII/sip: removeoo_ss.o
diff junk/remove_sd.F /home/perera/Develop/ACESIII/sip/remove_sd.F
15,18c15,21
<       subroutine remove_sd(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_sd(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,129
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_sd must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
> 
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
37c131,154
<        call retnosd(x,x2,bval(1),eval(1),bval(2),eval(2))
---
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> 
>       call retnosd(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
42c159
<       subroutine retnosd(array1,array2,a1,a2,b1,b2)
---
>       subroutine retnosd(array1,array2,a1,a2,b1,b2,index,type) 
46c163
< c
---
> c 
51c168
<       include 'int_gen_parms.h'
---
>       include 'int_gen_parms.h'  
53,88c170,260
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< c     Initialize output array to input array.
< c     ---------------------------------------
< 
<       do a = a1, a2
<       do b = b1, b2
< 
<          array2(a,b) = array1(a,b)
< 
<       enddo ! b
<       enddo ! a
< c
< c     Determine range of singly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       nszero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          nszero = nalpha_occupied - nbeta_occupied
<          do a = nalpha_occupied, nbeta_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          nszero = nbeta_occupied - nalpha_occupied
<          do a = nbeta_occupied, nalpha_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> 
> c     Initialize output array to input array. 
> c     --------------------------------------- 
> 
>       do a = a1, a2 
>       do b = b1, b2 
> 
>          array2(a,b) = array1(a,b) 
> 
>       enddo ! b 
>       enddo ! a 
> c
> c     Determine range of singly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       nszero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          nszero = nalpha_occupied - nbeta_occupied 
>          do a = nalpha_occupied, nbeta_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          nszero = nbeta_occupied - nalpha_occupied 
>          do a = nbeta_occupied, nalpha_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
> 
>       if (nalpha_occupied .eq. nbeta_occupied) go to 100 
> c
> c     Reduce first index. 
> c     ------------------- 
> 
>       do i = 1,  nszero 
>       do a = a1, a2  
>          if (szero(i) .eq. a) then 
>          do b = b1, b2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
> c
> c     Determine range of doubly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       ndzero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          ndzero = nbeta_occupied 
>          do a = 1, nbeta_occupied  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          ndzero = nalpha_occupied 
>          do a = 1, nalpha_occupied  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
> c
> c     Reduce second index. 
> c     ------------------- 
> 
>       do i = 1,  ndzero 
>       do b = b1, b2  
>          if (dzero(i) .eq. b) then 
>          do a = a1, a2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
90,142c262
<       if (nalpha_occupied .eq. nbeta_occupied) go to 100
< c
< c     Reduce first index.
< c     -------------------
< 
<       do i = 1,  nszero
<       do a = a1, a2
<          if (szero(i) .eq. a) then
<          do b = b1, b2
< 
<             array2(a,b) = 0.0
< 
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
< c
< c     Determine range of doubly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       ndzero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          ndzero = nbeta_occupied
<          do a = 1, nbeta_occupied
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          ndzero = nalpha_occupied
<          do a = 1, nalpha_occupied
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
< c
< c     Reduce second index.
< c     -------------------
< 
<       do i = 1,  ndzero
<       do b = b1, b2
<          if (dzero(i) .eq. b) then
<          do a = a1, a2
< 
<             array2(a,b) = 0.0
< 
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
< 
< 100   continue
---
> 100   continue 
145a266
> 
Only in /home/perera/Develop/ACESIII/sip: remove_sd.o
Only in /home/perera/Develop/ACESIII/sip: remove_single_double.o
Only in /home/perera/Develop/ACESIII/sip: remove_single.o
diff junk/remove_ss.F /home/perera/Develop/ACESIII/sip/remove_ss.F
15,18c15,21
<       subroutine remove_ss(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_ss(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,70
> #ifdef ALTIX
>       dptr = dshptr
> #endif
37c72,74
<        call retnoss(x,x2,bval(1),eval(1),bval(2),eval(2))
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
39,40c76,84
<       return 
<       end 
---
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
42c86,108
<       subroutine retnoss(array1,array2,a1,a2,b1,b2)
---
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_ss must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
45,46c111
< c
< c
---
> c   Look up each array's address.
49,51c114,126
<       implicit none
<       include 'interpreter.h'
<       include 'int_gen_parms.h'
---
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
53,79c128,129
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< 
< c
< c     Determine range of singly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       nszero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          nszero = nalpha_occupied - nbeta_occupied
<          do a = nalpha_occupied, nbeta_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          nszero = nbeta_occupied - nalpha_occupied
<          do a = nbeta_occupied, nalpha_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
---
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
81c131,132
<       if (nalpha_occupied .eq. nbeta_occupied) go to 100
---
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
83,84c134,136
< c     Initialize output array to input array.
< c     ---------------------------------------
---
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
86,87c138,150
<       do a = a1, a2
<       do b = b1, b2
---
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
89,94d151
<          array2(a,b) = array1(a,b)
<       enddo ! b
<       enddo ! a
< c
< c     Reduce first index.
< c     -------------------
96,99c153,157
<       do i = 1,  nszero
<       do a = a1, a2
<          if (szero(i) .eq. a) then
<          do b = b1, b2
---
>       call retnoss(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
> 
>       return 
>       end 
101c159
<             array2(a,b) = 0.0
---
>       subroutine retnoss(array1,array2,a1,a2,b1,b2,index,type) 
103,106c161
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
> c---------------------------------------------------------------------------
108,114c163,164
< c     Reduce second index.
< c     -------------------
< 
<       do i = 1,  nszero
<       do b = b1, b2
<          if (szero(i) .eq. b) then
<          do a = a1, a2
---
> c 
> c---------------------------------------------------------------------------
116c166,168
<             array2(a,b) = 0.0
---
>       implicit none
>       include 'interpreter.h'
>       include 'int_gen_parms.h'  
118,121c170,240
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> c
> c     Determine range of singly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       nszero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          nszero = nalpha_occupied - nbeta_occupied 
>          do a = nalpha_occupied, nbeta_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          nszero = nbeta_occupied - nalpha_occupied 
>          do a = nbeta_occupied, nalpha_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
> 
>       if (nalpha_occupied .eq. nbeta_occupied) go to 100 
> 
> c     Initialize output array to input array. 
> c     --------------------------------------- 
> 
>       do a = a1, a2 
>       do b = b1, b2 
> 
>          array2(a,b) = array1(a,b) 
> 
>       enddo ! b 
>       enddo ! a 
> c
> c     Reduce first index. 
> c     ------------------- 
> 
>       do i = 1,  nszero 
>       do a = a1, a2  
>          if (szero(i) .eq. a) then 
>          do b = b1, b2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
> c
> c     Reduce second index. 
> c     ------------------- 
> 
>       do i = 1,  nszero 
>       do b = b1, b2  
>          if (szero(i) .eq. b) then 
>          do a = a1, a2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
123c242
< 100   continue
---
> 100   continue 
Only in /home/perera/Develop/ACESIII/sip: remove_ss.o
Only in /home/perera/Develop/ACESIII/sip: remove_ssss.o
diff junk/remove_sx.F /home/perera/Develop/ACESIII/sip/remove_sx.F
15,18c15,21
<       subroutine remove_sx(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_sx(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,70
> #ifdef ALTIX
>       dptr = dshptr
> #endif
37c72,74
<        call retnosx(x,x2,bval(1),eval(1),bval(2),eval(2))
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
39,40c76,87
<       return 
<       end 
---
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
42c89,108
<       subroutine retnosx(array1,array2,a1,a2,b1,b2)
---
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_sx must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
45,46c111
< c
< c
---
> c   Look up each array's address.
49,51c114,126
<       implicit none
<       include 'interpreter.h'
<       include 'int_gen_parms.h'
---
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
53,79c128,129
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< 
< c
< c     Determine range of singly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       nszero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          nszero = nalpha_occupied - nbeta_occupied
<          do a = nalpha_occupied, nbeta_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          nszero = nbeta_occupied - nalpha_occupied
<          do a = nbeta_occupied, nalpha_occupied, -1
<             b = b + 1
<             szero(b) = a
<          enddo
<       endif
---
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
81c131,132
<       if (nalpha_occupied .eq. nbeta_occupied) go to 100
---
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
83,84c134,136
< c     Initialize output array to input array.
< c     ---------------------------------------
---
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
86,87c138,150
<       do a = a1, a2
<       do b = b1, b2
---
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
89d151
<          array2(a,b) = array1(a,b)
91,95c153,157
<       enddo ! b
<       enddo ! a
< c
< c     Reduce first index.
< c     -------------------
---
>       call retnosx(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
> 
>       return 
>       end 
97,100c159
<       do i = 1,  nszero
<       do a = a1, a2
<          if (szero(i) .eq. a) then
<          do b = b1, b2
---
>       subroutine retnosx(array1,array2,a1,a2,b1,b2,index,type) 
102c161,168
<             array2(a,b) = 0.0
---
> c---------------------------------------------------------------------------
> c
> c 
> c---------------------------------------------------------------------------
> 
>       implicit none
>       include 'interpreter.h'
>       include 'int_gen_parms.h'  
104,107c170,225
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> c
> c     Determine range of singly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       nszero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          nszero = nalpha_occupied - nbeta_occupied 
>          do a = nalpha_occupied, nbeta_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          nszero = nbeta_occupied - nalpha_occupied 
>          do a = nbeta_occupied, nalpha_occupied, -1 
>             b = b + 1 
>             szero(b) = a 
>          enddo 
>       endif 
> 
>       if (nalpha_occupied .eq. nbeta_occupied) go to 100 
> 
> c     Initialize output array to input array. 
> c     --------------------------------------- 
> 
>       do a = a1, a2 
>       do b = b1, b2 
> 
>          array2(a,b) = array1(a,b) 
> 
>       enddo ! b 
>       enddo ! a 
> c
> c     Reduce first index. 
> c     ------------------- 
> 
>       do i = 1,  nszero 
>       do a = a1, a2  
>          if (szero(i) .eq. a) then 
>          do b = b1, b2 
> 
>             array2(a,b) = 0.0 
> 
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
109c227
< 100   continue
---
> 100   continue 
Only in /home/perera/Develop/ACESIII/sip: remove_sx.o
diff junk/removevv_dd.F /home/perera/Develop/ACESIII/sip/removevv_dd.F
15,18c15,21
<       subroutine removevv_dd(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine removevv_dd(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,126
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_dd must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
37c128,154
<        call retnovvdd(x,x2,bval(1),eval(1),bval(2),eval(2))
---
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> 
>       call retnovvdd(x(iarray),x(ievec),
>      *             val1(1),val2(1),val1(2),val2(2),index,type)
42c159
<       subroutine retnovvdd(array1,array2,a1,a2,b1,b2)
---
>       subroutine retnovvdd(array1,array2,a1,a2,b1,b2,index,type) 
46c163
< c
---
> c 
51c168
<       include 'int_gen_parms.h'
---
>       include 'int_gen_parms.h'  
53,79c170,197
<       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2
<       double precision array1(a1:a2,b1:b2)
<       double precision array2(a1:a2,b1:b2)
<       integer nzero, zero(100), index1, index2, index3, index4
<       integer nszero, ndzero, szero(100), dzero(100)
<       common /SINDEX/index1, index2, index3, index4
< 
< c
< c     Determine range of doubly occupied indices to be removed.
< c     ---------------------------------------------------------
< 
<       b      = 0
<       ndzero = 0
<       if (nalpha_occupied .gt. nbeta_occupied) then
<          do a = nalpha_occupied+1, b2
<             ndzero = ndzero + 1
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
<       if (nbeta_occupied .gt. nalpha_occupied) then
<          do a = nbeta_occupied+1, a2
<             ndzero = ndzero + 1
<             b = b + 1
<             dzero(b) = a
<          enddo
<       endif
---
>       integer i, a, b, c, d, a1, a2, b1, b2, c1, c2, d1, d2  
>       double precision array1(a1:a2,b1:b2) 
>       double precision array2(a1:a2,b1:b2) 
> 
>       integer index(mx_array_index), type(mx_array_index) 
>       integer nzero, zero(100), index1, index2, index3, index4 
>       integer nszero, ndzero, szero(100), dzero(100) 
>       common /SINDEX/index1, index2, index3, index4 
> c
> c     Determine range of doubly occupied indices to be removed. 
> c     --------------------------------------------------------- 
> 
>       b      = 0 
>       ndzero = 0 
>       if (nalpha_occupied .gt. nbeta_occupied) then 
>          do a = nalpha_occupied+1, b2   
>             ndzero = ndzero + 1  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
>       if (nbeta_occupied .gt. nalpha_occupied) then 
>          do a = nbeta_occupied+1, a2    
>             ndzero = ndzero + 1  
>             b = b + 1 
>             dzero(b) = a 
>          enddo 
>       endif 
92,93c210,211
< c     Reduce first index.
< c     -------------------
---
> c     Reduce first index. 
> c     ------------------- 
95,98c213,216
<       do i = 1,  ndzero
<       do a = a1, a2
<          if (dzero(i) .eq. a) then
<          do b = b1, b2
---
>       do i = 1,  ndzero 
>       do a = a1, a2  
>          if (dzero(i) .eq. a) then 
>          do b = b1, b2 
100c218
<             array2(a,b) = 0.0
---
>             array2(a,b) = 0.0 
102,105c220,223
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
107,108c225,226
< c     Reduce second index.
< c     -------------------
---
> c     Reduce second index. 
> c     ------------------- 
110,113c228,231
<       do i = 1,  ndzero
<       do b = b1, b2
<          if (dzero(i) .eq. b) then
<          do a = a1, a2
---
>       do i = 1,  ndzero 
>       do b = b1, b2  
>          if (dzero(i) .eq. b) then 
>          do a = a1, a2 
115c233
<             array2(a,b) = 0.0
---
>             array2(a,b) = 0.0 
117,120c235,238
<          enddo ! b
<          endif
<       enddo ! a
<       enddo ! i
---
>          enddo ! b 
>          endif 
>       enddo ! a   
>       enddo ! i 
122c240
< 100   continue
---
> 100   continue 
126c244
<  
---
> 
Only in /home/perera/Develop/ACESIII/sip: removevv_dd.o
Only in /home/perera/Develop/ACESIII/sip: removevv_ss.o
diff junk/remove_xd.F /home/perera/Develop/ACESIII/sip/remove_xd.F
15,18c15,21
<       subroutine remove_xd(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_xd(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,152
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_xd must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec 
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
> 
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
37c154,155
<        call retnoxd(x,x2,bval(1),eval(1),bval(2),eval(2))
---
>        call retnoxd(x(iarray),x(ievec),
>      *               val1(1),val2(1),val1(2),val2(2),index,type)
42c160
<       subroutine retnoxd(array1,array2,a1,a2,b1,b2) 
---
>       subroutine retnoxd(array1,array2,a1,a2,b1,b2,index,type) 
56a175
>       integer index(mx_array_index), type(mx_array_index) 
Only in /home/perera/Develop/ACESIII/sip: remove_xd.o
Only in /home/perera/Develop/ACESIII/sip: remove_xdxd.o
Only in /home/perera/Develop/ACESIII/sip: remove_xdxs.o
diff junk/remove_xs.F /home/perera/Develop/ACESIII/sip/remove_xs.F
15,18c15,21
<       subroutine remove_xs(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine remove_xs(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
27,33c30,65
< 
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
35a68,151
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: remove_single routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. 2) then 
>          write(6,*) ' Remove_xs must use arrays with two indices' 
>          write(6,*) ' Number given =', nindex, nindex_evec  
>          call abort_job() 
>       endif 
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       block  = find_current_block(evec_array, array_table(1,evec_array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,evec_array) 
>       ievec = get_block_index(evec_array, block, stack, blkndx,x,.true.)  
> 
> c     iarray = get_index_from_base(address_table(array), x, 2)
> c     ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
37c153,154
<        call retnoxs(x,x2,bval(1), eval(1), bval(2), eval(2))
---
>        call retnoxs(x(iarray),x(ievec),
>      *              val1(1),val2(1),val1(2),val2(2),index,type)
42c159
<       subroutine retnoxs(array1,array2,a1,a2,b1,b2) 
---
>       subroutine retnoxs(array1,array2,a1,a2,b1,b2,index,type) 
56a174
>       integer index(mx_array_index), type(mx_array_index) 
Only in /home/perera/Develop/ACESIII/sip: remove_xs.o
Only in /home/perera/Develop/ACESIII/sip: remove_xsxd.o
Only in /home/perera/Develop/ACESIII/sip: remove_xsxs.o
Only in /home/perera/Develop/ACESIII/sip: remove_xxdd.o
Only in /home/perera/Develop/ACESIII/sip: remove_xxsd.o
Only in /home/perera/Develop/ACESIII/sip: remove_xxss.o
Only in /home/perera/Develop/ACESIII/sip: reorder_energy.o
Only in /home/perera/Develop/ACESIII/sip: request_block.o
diff junk/restart.F /home/perera/Develop/ACESIII/sip/restart.F
172,175d171
<          
<          do i = 1, 4
<              msg(i) = 0
<          enddo
Only in /home/perera/Develop/ACESIII/sip: restart.o
Only in junk/: retrieve_block_info.F
Only in /home/perera/Develop/ACESIII/sip: return_1st_mom.o
Only in /home/perera/Develop/ACESIII/sip: return_2nd_mom.o
Only in /home/perera/Develop/ACESIII/sip: return_derv_xyz.o
diff junk/return_diagonal4.F /home/perera/Develop/ACESIII/sip/return_diagonal4.F
15,16c15,20
<       subroutine return_diagonal4(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine return_diagonal4(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23c27,91
<       include 'epsilon.h'
---
>       include 'blkmgr.h'
>       include 'trace.h'
>       include 'mpif.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       common /epsilon/epsilon(1000), epsilonb(1000)
>       double precision epsilon, epsilonb
>     
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
25,27c93,109
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
30,33c112,115
<          call ret_diag4(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4), 
---
>          call ret_diag4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4), 
36,37c118,119
<          call lret_diag2(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
---
>          call lret_diag2(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
42c124
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
81a164,182
> 
>       do j = j1,j2
>       do b = b1,b2
>          do i = i1, i2
>          do a = a1,a2
>             val = 0.0d0 
>             if ((atype .eq. itype) .and. (i .eq. a) .and. 
>      *          (btype .ne. jtype)) then  
>                val =  x(a,i,b,j)
>             else 
>                val = 0.0d0 
>             endif 
>             x(a,i,b,j) = val 
>          enddo
>          enddo
>       enddo
>       enddo
> 
>       return
Only in /home/perera/Develop/ACESIII/sip: return_diagonal4.o
diff junk/return_diagonal.F /home/perera/Develop/ACESIII/sip/return_diagonal.F
15,18c15,21
<       subroutine return_diagonal(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine return_diagonal(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
21,22c24,26
< c   The diagonal elements of an array(Array1) are removed and the array 
< c   without the diagonal elements is put into another array(Array2). 
---
> c   The non diagonal elements of an array(Array1) are removed and the 
> c   array which only contains diagonal elements is put into 
> c   another array(Array2). 
26c30
< c   execute remove_diagonal Array1 Array2
---
> c   execute return_diagonal Array1 Array2
28,29c32,33
< c   where Array1 is the full input matrix, usually the fock matrix.  
< c         Array2 is the matrix with zero diagonal elements.  
---
> c   where Array1 is the full input matrix, for example the cphf array.  
> c         Array2 is the matrix with zero non diagonal elements.  
34a39
>       include 'interpreter.h'
35a41,69
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer ind(mx_array_index)
>       integer junk
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
37,42c71
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2(*)
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
---
>       if (dryrun) return
44c73,75
<       integer n
---
> #ifdef ALTIX
>       dptr = dshptr
> #endif
46c77,118
<       if (dryrun) return
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       evec_array = op(c_op1_array)
> 
>       if (array .eq. 0 .or. evec_array .eq. 0) then
>          print *,'Error: return_diagonal routine requires 2 
>      *            array arguments.'
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
> 
>       array_type = array_table(c_array_type, array)
>       evec_type  = array_table(c_array_type, evec_array)
> 
>       if (array_type .ne. static_array .or. 
>      *    evec_type .ne. static_array) then
>          print *,'Error: Both arrays in remove_diagonal routine 
>      *            must be static.'
>          call abort_job()
>       endif
> 
>       nindex      = array_table(c_nindex, array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (nindex .ne. nindex_evec) then
>          print *,'Error: Both arrays in return_diagonal must use ',
>      *           'the same number of indices.'
>          print *,'First array has ',nindex,' indices.'
>          print *,'Second array has ',nindex_evec,' indices.'
>          call abort_job()
>       endif
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up each array's address.
> c---------------------------------------------------------------------------
48,49c120,125
<       n = edim(1) - bdim(1) + 1 
<       if (nindex .eq. 2) call retdiag2(x,x2,n) 
---
>       iarray = get_index_from_base(address_table(array), x, 2)
>       ievec  = get_index_from_base(address_table(evec_array), x, 2)
> 
>       n = index_table(c_index_size, ind(1))  ! pick up length of index
> 
>       if (nindex .eq. 2) call retdiag2(x(iarray),x(ievec),n) 
54a131
> 
Only in /home/perera/Develop/ACESIII/sip: return_diagonal.o
diff junk/return_h1.F /home/perera/Develop/ACESIII/sip/return_h1.F
15,16c15,20
<       subroutine return_h1(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine return_h1(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
24a29,31
>       include 'interpreter.h'
>       include 'trace.h'
>       include 'parallel_info.h'
25a33,114
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer*8 iscr 
>       integer find_current_block
>       integer*8 get_block_data_index
>       integer block
>       integer igrad, component, intermediate
> 
>       double precision dummy, y
>       integer flopcount
>       integer*8 arg64(10)
>       logical*8 l8false
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
27,29c116,143
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Fock_der requires a 2-index argument array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
31c145,152
<       integer nsend
---
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
38,39c159
<          call comp_return_h1(x, bval(1), eval(1), 
<      *                       bval(2), eval(2),nsend)
---
>          call comp_return_h1(x(indblk), a1, a2, b1, b2,nsend)
41c161
<         write(6,*) ' MUST USE ERD IN RETURN_H1!!! ' 
---
>         write(6,*) ' MUST USE ERD IN FOCK_DER!!! ' 
Only in /home/perera/Develop/ACESIII/sip: return_h1.o
Only in /home/perera/Develop/ACESIII/sip: return_ovl.o
diff junk/return_sval.F /home/perera/Develop/ACESIII/sip/return_sval.F
15,18c15,21
<       subroutine return_sval(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine return_sval(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
20c23
< c   Usage: execute return_sval array scalar
---
> c
26a30,70
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer*8 get_block_index
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
28,37c72,83
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 2) then
<          print *,'Error: return_sval at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c----------------------------------------------------------------------------
> c   Locate the data for the input matrix which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array .eq. 0) then
>          print *,'Error: The first argument in return_sval  
>      *            must be an array.'  
>          print *,(op(i),i=1,loptable_entry)
41,43c87,153
<       if (nindex2 .ne. 0) then
<          print *,'Error: return_sval at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
---
>       if (nindex .ne. 2) then 
>          write(6,*) ' The first array in return_sval must gave two 
>      *                indices.'   
>          write(6,*) ' Number given =', nindex  
>          call abort_job() 
>       endif 
> 
>       do i = 1, nindex
>          ind(i) = array_table(c_index_array1+i-1,array)
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Look up its address.
> c---------------------------------------------------------------------------
> 
>       block  = find_current_block(array, array_table(1,array),
>      *                            index_table, nindex_table,
>      *                            segment_table, nsegment_table,
>      *                            block_map_table, blkndx)
>       stack = array_table(c_array_stack,array) 
>       iarray = get_block_index(array, block, stack, blkndx, x, .true.)  
> 
>       n1 = index_table(c_index_size, ind(1))  ! pick up length of index
>       n2 = index_table(c_index_size, ind(2))  ! pick up length of index
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
> 
>       do i = 1, nindex
>          index(i) = array_table(c_index_array1+i-1,array)
>          type(i)  = index_table(c_index_type, index(i))
>          seg      = index_table(c_current_seg,index(i))
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index(i), seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar.  
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in return_sval, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()
>       endif 
> 
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,' is ',ind,' should be ',
>      *           'between 1 and ',nscalar_table
47,48c157,159
<       call doreturn(x, x2,
<      *             bval(1),eval(1),bval(2),eval(2))
---
> 
>       call doreturn(x(iarray),scalar_table(sind),
>      *             val1(1),val2(1),val1(2),val2(2))
66,68c177,179
< c      do a = a1, a2 
< c      do b = b1, b2 
< c           sval = array1(a,b) 
---
>       do a = a1, a2 
>       do b = b1, b2 
>            sval = array1(a,b) 
70,71c181,182
< c      enddo ! b 
< c      enddo ! a 
---
>       enddo ! b 
>       enddo ! a 
73d183
<       sval = array1(a2,b2)
Only in /home/perera/Develop/ACESIII/sip: return_sval.o
diff junk/return_x.F /home/perera/Develop/ACESIII/sip/return_x.F
15,16c15,20
<       subroutine return_x(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine return_x(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
25a30,31
>       include 'trace.h'
>       include 'parallel_info.h'
26a33,114
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer*8 iscr 
>       integer find_current_block
>       integer*8 get_block_data_index
>       integer block
>       integer igrad, component, intermediate
> 
>       double precision dummy, y
>       integer flopcount
>       integer*8 arg64(10)
>       logical*8 l8false
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
28,30c116,143
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Fock_der requires a 2-index argument array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
32c145,152
<       integer nsend
---
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
39,40c159
<          call comp_return_x(x, bval(1), eval(1), bval(2), eval(2),
<      *                       nsend)
---
>          call comp_return_x(x(indblk), a1, a2, b1, b2,nsend)
42c161
<         write(6,*) ' MUST USE ERD IN RETURN_X!!! ' 
---
>         write(6,*) ' MUST USE ERD IN FOCK_DER!!! ' 
Only in /home/perera/Develop/ACESIII/sip: return_x.o
Only in /home/perera/Develop/ACESIII/sip: return_xx.o
Only in /home/perera/Develop/ACESIII/sip: return_xy.o
Only in /home/perera/Develop/ACESIII/sip: return_xz.o
diff junk/return_y.F /home/perera/Develop/ACESIII/sip/return_y.F
15,16c15,20
<       subroutine return_y(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine return_y(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
20c24
< c   eyecute return_x x(mu,nu)
---
> c   execute return_y y(mu,nu)
25a30,31
>       include 'trace.h'
>       include 'parallel_info.h'
26a33,114
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer*8 iscr 
>       integer find_current_block
>       integer*8 get_block_data_index
>       integer block
>       integer igrad, component, intermediate
> 
>       double precision dummy, y
>       integer flopcount
>       integer*8 arg64(10)
>       logical*8 l8false
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
28,30c116,143
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Fock_der requires a 2-index argument array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
32c145,152
<       integer nsend
---
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
39,40c159
<          call comp_return_y(x, bval(1), eval(1), bval(2), eval(2),
<      *                       nsend)
---
>          call comp_return_y(x(indblk), a1, a2, b1, b2,nsend)
42c161
<         write(6,*) ' MUST USE ERD IN RETURN_Y!!! ' 
---
>         write(6,*) ' MUST USE ERD IN FOCK_DER!!! ' 
Only in /home/perera/Develop/ACESIII/sip: return_y.o
Only in /home/perera/Develop/ACESIII/sip: return_yy.o
Only in /home/perera/Develop/ACESIII/sip: return_yz.o
diff junk/return_z.F /home/perera/Develop/ACESIII/sip/return_z.F
15,16c15,20
<       subroutine return_z(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine return_z(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
20c24
< c   execute return_z x(mu,nu)
---
> c   execute return_z z(mu,nu)
25a30,31
>       include 'trace.h'
>       include 'parallel_info.h'
26a33,114
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       logical direct_flag
> 
>       integer i, j, k
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer*8 iscr 
>       integer find_current_block
>       integer*8 get_block_data_index
>       integer block
>       integer igrad, component, intermediate
> 
>       double precision dummy, y
>       integer flopcount
>       integer*8 arg64(10)
>       logical*8 l8false
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
28,30c116,143
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Fock_der requires a 2-index argument array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
> 
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
32c145,152
<       integer nsend
---
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
39,40c159
<          call comp_return_z(x, bval(1), eval(1), bval(2), eval(2),
<      *                       nsend)
---
>          call comp_return_z(x(indblk), a1, a2, b1, b2,nsend)
42c161
<         write(6,*) ' MUST USE ERD IN RETURN_Z`!!! ' 
---
>         write(6,*) ' MUST USE ERD IN FOCK_DER!!! ' 
Only in /home/perera/Develop/ACESIII/sip: return_z.o
Only in /home/perera/Develop/ACESIII/sip: return_zz.o
Only in /home/perera/Develop/ACESIII/sip: scf_atom_coeff.F
Only in /home/perera/Develop/ACESIII/sip: scf_atom_coeff.o
Only in /home/perera/Develop/ACESIII/sip: scf_atom.o
Only in /home/perera/Develop/ACESIII/sip: scf_rhf.o
Only in /home/perera/Develop/ACESIII/sip: scont1.o
Only in /home/perera/Develop/ACESIII/sip: scontxy.o
Only in /home/perera/Develop/ACESIII/sip: scratchpad.h
Only in /home/perera/Develop/ACESIII/sip: sdrop.F
Only in /home/perera/Develop/ACESIII/sip: sdrop.o
diff junk/second_moment.F /home/perera/Develop/ACESIII/sip/second_moment.F
15,18c15,20
<       subroutine second_moment(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine second_moment(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
20,21c22,26
< c   Usage: execute second_moment array scalar
< c   
---
> c
> c   dipole_moment must be executed with the following syntax:
> c   execute dipole_moment x(mu,nu) type ; type = 1, 2, 3, 4, 5, 6
> c                                               XX YY ZZ XY XZ YZ
> c
26d30
<       include 'int_gen_parms.h'
27a32,141
>       include 'parallel_info.h'
>       include 'int_gen_parms.h'
>       include 'machine_types.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       logical direct_flag
> 
>       integer i, j, k, type
>       integer nind, nsend
>       integer ierr, handle
>       integer blk, blkndx, maxblk
>       integer*8 indblk, get_block_index
>       integer*8 integral_scr
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer msg(len_sip_server_message)
>       integer flag
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
>       integer array, ind(mx_array_index), seg(mx_array_index)
>       integer evec_array,nindex_evec,evec_type,sind
>       integer a1, a2, b1, b2
>       integer m, n, nl2
>       integer iatom
>       integer*8 iscr 
>       integer find_current_block
>       integer*8 get_block_data_index
>       integer block
>       integer igrad, component, intermediate
> 
>       double precision dummy, y, sval
>       integer flopcount
>       integer*8 arg64(10)
>       logical*8 l8false
> 
>       common /d2int_com/jatom, jx, jcenter
>       integer jatom, jx, jcenter, dcoord
> 
>       nl2 = (nbasis * nbasis + nbasis)/2
>       handle = op(c_result_array)
>       direct_flag = .false.
> 
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c------------------------------------------------------------------------
> c   Make sure the requested block exists.  create_current_block will
> c   create the block if it does not exist, and simply return if the
> c   block is already present.
> c------------------------------------------------------------------------
> 
>       call create_current_block(handle,array_table,
>      *                 narray_table, index_table,
>      *                 nindex_table, segment_table, nsegment_table,
>      *                 block_map_table, nblock_map_table, op,
>      *                 .true., direct_flag, blk, ierr)
>       blkndx = ierr
>       call get_block_computed_flag(handle, blk, blkndx, flag)
>       if (flag .eq. 0) then
>          call set_opblock(handle, blk, blkndx, op)
>          call set_block_computed_flag(handle, blk, blkndx, 1)
>       endif
> 
>       stack = array_table(c_array_stack,handle)
>       indblk = get_block_index(handle, blk, stack,
>      *                         blkndx, x, .true.)
> 
> c--------------------------------------------------------------------------
> c   Find the ranges of the AO indices of the input block.
> c--------------------------------------------------------------------------
> 
>          array = op(c_result_array)
> 
>          nind  = array_table(c_nindex,array)
>          if (nind .ne. 2) then
>             print *,'Error: Fock_der requires a 2-index argument array.'
>             print *,'Array ',array,' is defined with ',nind,' indices.'
>             call abort_job()
>          endif       
>    
>          do i = 1, nind
>             ind(i) = array_table(c_index_array1+i-1,array)
>             seg(i) = index_table(c_current_seg,ind(i))
>          enddo
> 
>          call get_index_segment(ind(1), seg(1), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, a1, a2)
>          call get_index_segment(ind(2), seg(2), segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, b1, b2)
29,40c143,179
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       integer itype, nsend
< 
<       if (nindex .ne. 2) then
<          print *,'Error: second_moment at line ',current_line
<          print *,'First arg. must be a block of a 2-index array.'
---
> c--------------------------------------------------------------------------
> c   Form the address of the current data block.
> c--------------------------------------------------------------------------
> 
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack, array)
>          indblk = get_block_data_index(array, block, stack,
>      *                                        blkndx, x)
> 
> c---------------------------------------------------------------------------
> c   Locate the scalar that tells if derivative of X, Y, or Z
> c---------------------------------------------------------------------------
>      
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       if (evec_type .ne. scalar_value) return
> 
>       if (evec_array .lt. 1 .or. evec_array .gt. narray_table) then
>          print *,'Error: Invalid scalar in dipole_moment, line ',
>      *     current_line
>          print *,'Array index is ',array,' Allowable values are ',
>      *      ' 1 through ',narray_table
>          call abort_job()          
>       endif
>          
>       sind =  array_table(c_scalar_index, evec_array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>         print *,'Scalar table index out of range in dipole_moment, ',
>      *           'line ',current_line
>         print *,'Index for array ',evec_array,' is ',sind,' should be ',
>      *           'between 1 and ',nscalar_table
44,48c183
<       if (nindex2 .ne. 0) then
<          print *,'Error: second_moment at line ',current_line,' not ',
<      *           'called with scalar in 2nd arg.'
<          call abort_job()      
<       endif
---
>       sval = scalar_table(sind)
50,56c185,191
<       itype = 0
<       if ( (abs (x2 - 1.0)) .lt. 0.001 ) itype = 1
<       if ( (abs (x2 - 2.0)) .lt. 0.001 ) itype = 2
<       if ( (abs (x2 - 3.0)) .lt. 0.001 ) itype = 3
<       if ( (abs (x2 - 4.0)) .lt. 0.001 ) itype = 4
<       if ( (abs (x2 - 5.0)) .lt. 0.001 ) itype = 5
<       if ( (abs (x2 - 6.0)) .lt. 0.001 ) itype = 6
---
>       type = 0
>       if ( (abs (sval - 1.0)) .lt. 0.001 ) type = 1
>       if ( (abs (sval - 2.0)) .lt. 0.001 ) type = 2
>       if ( (abs (sval - 3.0)) .lt. 0.001 ) type = 3
>       if ( (abs (sval - 4.0)) .lt. 0.001 ) type = 4
>       if ( (abs (sval - 5.0)) .lt. 0.001 ) type = 5
>       if ( (abs (sval - 6.0)) .lt. 0.001 ) type = 6
64,65c199
<          call comp_second_moment(itype,x, bval(1), eval(1), 
<      *                           bval(2), eval(2), nsend)
---
>          call comp_second_moment(type,x(indblk), a1, a2, b1, b2,nsend)
67,68c201
<         write(6,*) ' MUST USE ERD IN SECOND_MOMENT!!! ' 
<         call abort_job()
---
>         write(6,*) ' MUST USE ERD IN FOCK_DER!!! ' 
Only in /home/perera/Develop/ACESIII/sip: second_moment.o
Only in /home/perera/Develop/ACESIII/sip: send_block.o
Only in /home/perera/Develop/ACESIII/sip: send_master_barrier_msg.o
Only in /home/perera/Develop/ACESIII/sip: server_barrier_data.h
Only in /home/perera/Develop/ACESIII/sip: server_barrier.o
Only in /home/perera/Develop/ACESIII/sip: server_takedown.o
Only in /home/perera/Develop/ACESIII/sip: set_effective_indices.o
Only in /home/perera/Develop/ACESIII/sip: set_flags2.o
Only in /home/perera/Develop/ACESIII/sip: set_flags4.o
Only in /home/perera/Develop/ACESIII/sip: set_flags.o
Only in /home/perera/Develop/ACESIII/sip: set_ijk_aaa.o
Only in /home/perera/Develop/ACESIII/sip: set_ijk_aab.o
Only in /home/perera/Develop/ACESIII/sip: set_index.o
Only in /home/perera/Develop/ACESIII/sip: set_np2.F
Only in /home/perera/Develop/ACESIII/sip: set_np2.o
Only in /home/perera/Develop/ACESIII/sip: set_opblock.o
Only in /home/perera/Develop/ACESIII/sip: set_program_context.o
Only in /home/perera/Develop/ACESIII/sip: set_t3blocks_a.o
Only in /home/perera/Develop/ACESIII/sip: set_t3blocks_i.o
diff junk/sip_barrier.f /home/perera/Develop/ACESIII/sip/sip_barrier.f
69,71d68
<          do i = 1, 5
<              msg(i) = 0
<          enddo
Only in /home/perera/Develop/ACESIII/sip: sip_barrier.o
Only in /home/perera/Develop/ACESIII/sip: sip_tables.h
Only in /home/perera/Develop/ACESIII/sip: slice_insert_block.o
Only in /home/perera/Develop/ACESIII/sip: smon_off.o
Only in /home/perera/Develop/ACESIII/sip: smon_on.o
Only in /home/perera/Develop/ACESIII/sip: smooth4.o
Only in /home/perera/Develop/ACESIII/sip: smooth.o
diff junk/square_root.F /home/perera/Develop/ACESIII/sip/square_root.F
15,18c15,21
<       subroutine square_root(x,nindex, type, bval,
<      *                              eval, bdim, edim,
<      *                      x2, nindex2, type2, bval2,
<      *                              eval2, bdim2, edim2)
---
>       subroutine square_root(array_table, 
>      *                      narray_table, index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
> 
29a33,87
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table 
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer type(mx_array_index) 
>       integer nscalar_table
>       double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer*8 iarray, ievec, get_index_from_base
>       integer i, j, n1, n2, n3, n4  
>       integer array, evec_array
>       integer array_type, evec_type
>       integer nindex, nindex_evec
>       integer sind, xind, ind(mx_array_index)
>       integer seg, index(mx_array_index), val1(mx_array_index), 
>      *        val2(mx_array_index), junk
> 
>       integer block, blkndx
>       integer find_current_block
>       integer stack
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c----------------------------------------------------------------------------
> c   Locate the scalar which is to be analyses.
> c---------------------------------------------------------------------------
> 
>       array      = op(c_result_array)
>       array_type = array_table(c_array_type, array)
>       nindex     = array_table(c_nindex, array)
> 
>       if (array_type .ne. scalar_value) then
>          print *,'Error: The argument in square_root   
>      *            must be a scalar.'  
>          print *,(op(i),i=1,loptable_entry)
>          call abort_job()
>       endif
31,40c89,94
<       double precision x
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
<       double precision x2
<       integer nindex2, type2(*), bval2(*), eval2(*)
<       integer bdim2(*), edim2(*)
< 
<       if (nindex .ne. 0 .or. nindex2 .ne. 0) then
<          print *,'Error: square_root instruction requires 2 scalar ',
<      *           'values as arguments.'
---
>       sind =  array_table(c_scalar_index, array)
>       if (sind .lt. 1 .or. sind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',array,' is ',sind,' should be ',
>      *           'between 1 and ',nscalar_table
44c98,115
<       x = x**x2
---
> c----------------------------------------------------------------------------
> c   Locate the power.
> c---------------------------------------------------------------------------
> 
>       evec_array  = op(c_op1_array)
>       evec_type   = array_table(c_array_type, evec_array)
>       nindex_evec = array_table(c_nindex, evec_array)
> 
>       xind =  array_table(c_scalar_index, evec_array)
>       if (xind .lt. 1 .or. xind .gt. nscalar_table) then
>          print *,'Scalar table index out of range in return_sval, ',
>      *           'line ',current_line
>          print *,'Index for array ',evec_array,'is',xind,' should be ',
>      *           'between 1 and ',nscalar_table
>          call abort_job()
>       endif
>  
>       scalar_table(sind) = scalar_table(sind)**scalar_table(xind)     
Only in /home/perera/Develop/ACESIII/sip: square_root.o
Only in /home/perera/Develop/ACESIII/sip: stack_implementation.o
Only in /home/perera/Develop/ACESIII/sip: stripi.o
Only in /home/perera/Develop/ACESIII/sip: sum_64ss.o
Only in /home/perera/Develop/ACESIII/sip: sum_blocks.o
diff junk/symm_force.F /home/perera/Develop/ACESIII/sip/symm_force.F
15,16c15,20
<       subroutine symm_force_a(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine symm_force_a(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23c27,91
<       include 'epsilon.h'
---
>       include 'blkmgr.h'
>       include 'trace.h'
>       include 'mpif.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       common /epsilon/epsilon(1000), epsilonb(1000)
>       double precision epsilon, epsilonb
>     
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
25,27c93,109
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
30,33c112,115
<          call dosymmforce(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4), 
---
>          call dosymmforce(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4), 
36c118
<          print *,'Error in symm_force_a: Result array ',
---
>          print *,'Error in return_diagonal_4: Result array ',
38c120
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
diff junk/symm_force_i.F /home/perera/Develop/ACESIII/sip/symm_force_i.F
15,16c15,20
<       subroutine symm_force_i(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine symm_force_i(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
23c27,91
<       include 'epsilon.h'
---
>       include 'blkmgr.h'
>       include 'trace.h'
>       include 'mpif.h'
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
> 
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       common /epsilon/epsilon(1000), epsilonb(1000)
>       double precision epsilon, epsilonb
>     
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
25,27c93,109
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
30,33c112,115
<          call dosymmforcei(x, bval(1),eval(1),type(1),
<      *                   bval(2),eval(2),type(2),
<      *                   bval(3),eval(3),type(3),
<      *                   bval(4),eval(4),type(4), 
---
>          call dosymmforcei4(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   val1(3),val2(3),type(3),
>      *                   val1(4),val2(4),type(4), 
35,36c117,125
<       else
<          print *,'Error in symm_force_i: Result array ',
---
>         return 
>       endif  
>       if (nindex .eq. 2) then
>          call dosymmforcei2(x(indblk), val1(1),val2(1),type(1),
>      *                   val1(2),val2(2),type(2),
>      *                   epsilon,epsilonb)
>         return 
>       endif
>          print *,'Error in return_diagonal_4: Result array ',
38c127
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
40d128
<       endif
45c133
<       subroutine dosymmforcei(x, a1,a2,atype,
---
>       subroutine dosymmforcei4(x, a1,a2,atype,
60a149,150
> c     go to 30 
>       if (atype .eq. btype .and. itype .eq. jtype) then 
85a176,206
>       endif 
> 30    continue 
> c
>       return
>       end
> 
>       subroutine dosymmforcei2(x, a1,a2,atype,
>      *                      i1,i2,itype,
>      *                       epsilon, epsilonb)
>       implicit none
>       include 'interpreter.h'
> 
>       integer a1,a2,b1,b2,i1,i2,j1,j2
>       integer atype, itype, btype, jtype
>       double precision x(a1:a2,i1:i2)
> 
>       double precision epsilon(*), epsilonb(*)
> 
>       integer a,b,i,j
>       double precision val
> 
> c
>       do a = a1,a2
>          do i = i1,i2
>             if (a .lt. i)then
>                val = x(a,i) + x(i,a) 
>                x(i,a)= val*(0.5d0)
>                x(a,i)= val*(0.5d0)
>             endif
>          enddo
>       enddo
Only in /home/perera/Develop/ACESIII/sip: symm_force_ij.F
Only in /home/perera/Develop/ACESIII/sip: symm_force_ij.o
Only in /home/perera/Develop/ACESIII/sip: symm_force_i.o
Only in /home/perera/Develop/ACESIII/sip: symm_force.o
Only in /home/perera/Develop/ACESIII/sip: temp_x.o
Only in /home/perera/Develop/ACESIII/sip: tensor_contraction.o
Only in /home/perera/Develop/ACESIII/sip: timestamp.o
Only in /home/perera/Develop/ACESIII/sip: trace.h
Only in /home/perera/Develop/ACESIII/sip: trace_off.o
Only in /home/perera/Develop/ACESIII/sip: trace_on.o
Only in /home/perera/Develop/ACESIII/sip: trnsps.o
Only in /home/perera/Develop/ACESIII/sip: twork4222.o
diff junk/udenominator.F /home/perera/Develop/ACESIII/sip/udenominator.F
15,16c15,20
<       subroutine udenominator(x, nindex, type, bval,
<      *                              eval, bdim, edim)
---
>       subroutine udenominator(array_table, narray_table, 
>      *                      index_table,
>      *                      nindex_table, segment_table, nsegment_table,
>      *                      block_map_table, nblock_map_table,
>      *                      scalar_table, nscalar_table, 
>      *                      address_table, op)
18c22
< c   Divides each sample of the block given by the array argument by the
---
> c   Divides each sample of the block given by the array argument by the 
21c25
< c   The p=q value is set to zero.
---
> c   The p=q value is set to zero.  
25a30
>       include 'trace.h'
26a32,59
> #ifdef ALTIX
>       include 'sheap.h'
> #endif
> 
>       integer narray_table, nindex_table, nsegment_table, 
>      *        nblock_map_table
>       integer op(loptable_entry)
>       integer array_table(larray_table_entry, narray_table)
>       integer index_table(lindex_table_entry, nindex_table)
>       integer segment_table(lsegment_table_entry, nsegment_table)
>       integer block_map_table(lblock_map_entry, nblock_map_table)
>       integer nscalar_table
>        double precision scalar_table(nscalar_table)
>       integer*8 address_table(narray_table)
> 
>       integer i, j, k
>       integer array, index, nindex, ierr
>       integer block, blkndx, seg
>       integer find_current_block
>       integer*8 indblk, get_block_index
>       integer stack
>       
>       integer comm
> 
>       integer val1(mx_array_index), val2(mx_array_index)
>       integer type(mx_array_index)
>       integer na1, na2, ni1, ni2
>       integer*8 addr, get_index_from_base
28,30c61,109
<       double precision x(*)
<       integer nindex, type(*), bval(*), eval(*)
<       integer bdim(*), edim(*)
---
>       double precision x(1)
> #ifdef ALTIX
>       pointer (dptr, x)
> #else
>       common x
> #endif
> 
>       if (dryrun) return
> #ifdef ALTIX
>       dptr = dshptr
> #endif
> 
> c---------------------------------------------------------------------------
> c   Find the indices of the array block.
> c---------------------------------------------------------------------------
>        
>       array = op(c_result_array)
>       nindex = array_table(c_nindex, array)
>       do i = 1, nindex
>          index = array_table(c_index_array1+i-1,array)
>          type(i) = index_table(c_index_type, index)
>          seg = index_table(c_current_seg,index)
> 
> c-------------------------------------------------------------------------
> c   Get segment ranges.
> c-------------------------------------------------------------------------
> 
>          call get_index_segment(index, seg, segment_table,
>      *                             nsegment_table, index_table,
>      *                             nindex_table, val1(i), val2(i))
>       enddo
> 
> c---------------------------------------------------------------------------
> c   Get array data address.
> c---------------------------------------------------------------------------
> 
>       if (array_table(c_array_type,array) .eq. static_array) then
>          addr = address_table(array)
>          indblk = get_index_from_base(addr, x, 2)
>       else
>          block = find_current_block(array, array_table(1,array),
>      *                             index_table, nindex_table,
>      *                             segment_table, nsegment_table,
>      *                             block_map_table, blkndx)
> 
>          stack = array_table(c_array_stack,array)
>          indblk = get_block_index(array, block, stack,
>      *                            blkndx, x, .true.)
>       endif 
33,36c112,115
<          call epsu_divide(x, bval(1),eval(1),type(1),
<      *                    bval(2),eval(2),type(2),
<      *                    bval(3),eval(3),type(3),
<      *                    bval(4),eval(4),type(4), 
---
>          call epsu_divide(x(indblk), val1(1),val2(1),type(1),
>      *                    val1(2),val2(2),type(2),
>      *                    val1(3),val2(3),type(3),
>      *                    val1(4),val2(4),type(4), 
39,42c118,132
<          call epsu_divide2(x, bval(1),eval(1),type(1),
<      *                     bdim(1), edim(1),
<      *                     bval(2),eval(2),type(2),
<      *                     bdim(2), edim(2),
---
>          if (array_table(c_array_type,array) .eq. static_array) then
>             na1 = array_table(c_index_range1, array)
>             na2 = array_table(c_index_range2,array)
>             ni1 = array_table(c_index_range1+1,array)
>             ni2 = array_table(c_index_range2+1,array)
>          else
>             na1 = val1(1)
>             na2 = val2(1)
>             ni1 = val1(2)
>             ni2 = val2(2)
>          endif 
> 
>          call epsu_divide2(x(indblk), val1(1),val2(1),type(1),
>      *                     na1, na2,
>      *                     val1(2),val2(2),type(2),ni1,ni2,
45c135
<          print *,'Error in udenominator: Result array ',
---
>          print *,'Error in energy_denominator: Result array ',
47c137
<          print *,'array has ',nindex,' indices.'
---
>          print *,'array ',array,' has ',nindex,' indices.'
Only in /home/perera/Develop/ACESIII/sip: udenominator.o
Only in /home/perera/Develop/ACESIII/sip: v_nuc_nuc.F
Only in /home/perera/Develop/ACESIII/sip: v_nuc_nuc.o
diff junk/wait_on_block.f /home/perera/Develop/ACESIII/sip/wait_on_block.f
44d43
<       call pause_timer(current_instr_unit_timer)
48,54d46
<       call update_timer(pardo_act_timer)
<       call timer_start(pardo_tserver_timer)
< c      call timer_start (timer_ovrhead)
<       call timer_start (current_instr_mpi_timer)
<       call timer_start (current_instr_blk_timer)
<       call timer_start (current_instr_mpino_timer)
< 
61,65c53
<      
<       call update_timer (current_instr_mpino_timer)
<       call update_timer (current_instr_blk_timer)
<       call update_timer (current_instr_mpi_timer)
< c      call update_timer (timer_ovrhead)
---
>       
69,71d56
<       call resume_timer(current_instr_unit_timer)
<       call timer_start(pardo_act_timer)
<       call update_timer(pardo_tserver_timer)
Only in /home/perera/Develop/ACESIII/sip: wait_on_block.o
Only in /home/perera/Develop/ACESIII/sip: write_blocks_to_list_no_mpi_io.o
Only in /home/perera/Develop/ACESIII/sip: write_blocks_to_list.o
Only in /home/perera/Develop/ACESIII/sip: write_coefficients.F
Only in /home/perera/Develop/ACESIII/sip: write_coefficients.o
Only in /home/perera/Develop/ACESIII/sip: write_master_checkpoint_data.o
Only in /home/perera/Develop/ACESIII/sip: write_scfdata.F
Only in /home/perera/Develop/ACESIII/sip: write_scfdata.o
Only in /home/perera/Develop/ACESIII/sip: xdaxpy.f
Only in /home/perera/Develop/ACESIII/sip: xdaxpy.o
Only in /home/perera/Develop/ACESIII/sip: xdcopy.f
Only in /home/perera/Develop/ACESIII/sip: xdcopy.o
Only in /home/perera/Develop/ACESIII/sip: xddot.F
Only in /home/perera/Develop/ACESIII/sip: xddot.o
